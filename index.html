<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN</title>
  <style>
    html, body { margin:0; padding:0; background:#0a0a12; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
    .hint{
      position:fixed; left:12px; bottom:10px;
      font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:rgba(255,255,255,.75);
      background:rgba(0,0,0,0.35);
      padding:8px 10px; border-radius:10px;
      user-select:none; z-index:10;
    }
  </style>
</head>
<body>
  <div class="hint">PC: WASD/Arrows • Mobile: DIRECT FOLLOW (drag) • 3 Worlds • 5 Levels • W3 Laser Boss</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    window.addEventListener("load", () => {
      const wait = setInterval(() => {
        if (typeof window.Phaser === "undefined") return;
        clearInterval(wait);

        const W = 420, H = 760;
        const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

        // ===== GRID =====
        const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
        const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
        const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

        // Movement
        const PLAYER_SPEED = 320;

        // ✅ Mobile DIRECT FOLLOW only
        const FOLLOW_RADIUS = 7;
        const FOLLOW_LERP = 0.38;
        const FOLLOW_MAX_SPEED_MULT = 2.8;

        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

        // ===== SAVE / PROGRESS =====
        const LEVELS_PER_WORLD = 5;
        const SAVE_KEY = "gridrun_progress_v4";

        function loadProgress() {
          try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
            const p = JSON.parse(raw);
            return {
              unlockedWorld: Number.isFinite(p.unlockedWorld) ? p.unlockedWorld : 0,
              unlockedLevel: Number.isFinite(p.unlockedLevel) ? p.unlockedLevel : 0,
              currentWorld: Number.isFinite(p.currentWorld) ? p.currentWorld : 0,
              currentLevel: Number.isFinite(p.currentLevel) ? p.currentLevel : 0
            };
          } catch {
            return { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
          }
        }
        function saveProgress(p) { localStorage.setItem(SAVE_KEY, JSON.stringify(p)); }
        function resetProgress() { localStorage.removeItem(SAVE_KEY); }

        function isLevelUnlocked(p, world, level) {
          if (world < p.unlockedWorld) return true;
          if (world > p.unlockedWorld) return false;
          return level <= p.unlockedLevel;
        }

        // ===== UI helpers =====
        function addTitle(scene, text, yFrac = 0.22, size = 40) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: `${size}px`, color: "#ffffff",
          }).setOrigin(0.5).setAlpha(0.96);
        }
        function addSubtitle(scene, text, yFrac = 0.28) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff",
          }).setOrigin(0.5).setAlpha(0.9);
        }
        function makeButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "18px",
            color: "#0a0a12",
            backgroundColor: "#6ef3ff",
            padding: { left: 18, right: 18, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.92));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }
        function makeGhostButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "16px",
            color: "#ffffff",
            backgroundColor: "rgba(255,255,255,0.10)",
            padding: { left: 16, right: 16, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.85));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }

        // ===== Level times (fixed) =====
        const DUR = [20, 25, 30, 38, 45];

        // Difficulty builder:
        // baseScroll + scrollRamp control obstacle travel speed.
        // spawnStart/spawnMin/spawnRamp control density (lower = denser).
        function mkLevels(cfg) {
          return DUR.map((seconds, i) => ({
            seconds,
            baseScroll: cfg.baseScroll0 + cfg.baseScrollStep * i,
            scrollRamp: cfg.ramp0 + cfg.rampStep * i,

            // density
            spawnStart: cfg.spawnStart0 - cfg.spawnStep * i,
            spawnRamp: cfg.spawnRamp0 + cfg.spawnRampStep * i,
            spawnMin: Math.max(cfg.spawnMinFloor, cfg.spawnMin0 - cfg.spawnMinStep * i),

            // obstacle footprint
            size: [cfg.sizeMin0 - cfg.sizeMinStep*i, cfg.sizeMax0 - cfg.sizeMaxStep*i]
          }));
        }

        // ===== Worlds (A+B+C mixed) with your new difficulty intent =====
        // Rule: World2 > World1, World3 > World2 across matching levels.
        // Also: W1/W2 L2-L5 bumped; W3 L1-L4 bumped slightly.
        const WORLDS = [
          {
            id: 0,
            name: "Cyber Circuit",
            subtitle: "Neon lanes. Clean reads. Warm up.",
            bg: 0x070812,
            border: 0x2a2a55,
            gridLine: 0x20204a,
            player: 0x6ef3ff,
            fx: "scanlines",
            gridStyle: "circuit",
            obstacleStyle: { palette: [0xff4d7d, 0xff6aa2, 0xff7bd0], shapes: ["tri","hex","frame","rect"] },

            // ✅ World 1: easy L1, stronger L2-L5
            levels: mkLevels({
              baseScroll0: 80, baseScrollStep: 18,     // speed ramps harder by level
              ramp0: 8.0, rampStep: 3.0,

              spawnStart0: 1020, spawnStep: 105,       // L2-5 noticeably denser
              spawnRamp0: 10, spawnRampStep: 3,
              spawnMin0: 520, spawnMinStep: 55,
              spawnMinFloor: 300,

              sizeMin0: 22, sizeMinStep: 1,
              sizeMax0: 34, sizeMaxStep: 1
            })
          },
          {
            id: 1,
            name: "Industrial Overclock",
            subtitle: "Heavy plating. Hazard stripes. Faster drops.",
            bg: 0x050611,
            border: 0x3a4a88,
            gridLine: 0x243056,
            player: 0x7cffd2,
            fx: "rain",
            gridStyle: "industrial",
            obstacleStyle: { palette: [0xffd166, 0xff4d7d, 0x7cffd2], shapes: ["bar","plus","rect","frame"] },

            // ✅ World 2: Level 1 is harder than World 1 Level 1 (and so on)
            levels: mkLevels({
              baseScroll0: 92, baseScrollStep: 20,
              ramp0: 9.0, rampStep: 3.3,

              spawnStart0: 980, spawnStep: 115,
              spawnRamp0: 11, spawnRampStep: 3.4,
              spawnMin0: 500, spawnMinStep: 60,
              spawnMinFloor: 285,

              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            })
          },
          {
            id: 2,
            name: "Blackout Glitch",
            subtitle: "Broken grid. Flicker. Laser sweeps.",
            bg: 0x02030a,
            border: 0x4b4bb0,
            gridLine: 0x1e1f3f,
            player: 0x9aa7ff,
            fx: "stars",
            gridStyle: "glitch",
            obstacleStyle: { palette: [0xff4d7d, 0xffb0ff, 0x9aa7ff], shapes: ["hex","tri","bar","frame"] },

            // ✅ World 3: slightly harder across L1-L4 (and still hardest overall)
            levels: mkLevels({
              baseScroll0: 98, baseScrollStep: 22,
              ramp0: 9.6, rampStep: 3.6,

              spawnStart0: 940, spawnStep: 120,
              spawnRamp0: 12, spawnRampStep: 3.6,
              spawnMin0: 480, spawnMinStep: 62,
              spawnMinFloor: 270,

              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            }),
            boss: {
              enabled: true,
              cycleSeconds: 5.7,
              warnSeconds: 1.20,
              activeSeconds: 1.12,
              thickness: 16,
              warnThickness: 6
            }
          }
        ];

        // ===== Background FX =====
        function buildBackdrop(scene, fxType, colorA, colorB) {
          const items = [];

          if (fxType === "scanlines") {
            const g = scene.add.graphics();
            g.setAlpha(0.22);
            g.lineStyle(1, colorB, 1);
            for (let y = 0; y < H; y += 8) {
              g.beginPath(); g.moveTo(0, y); g.lineTo(W, y); g.strokePath();
            }
            items.push(g);
          }

          if (fxType === "rain") {
            const drops = [];
            for (let i = 0; i < 42; i++) {
              const r = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(-H, H),
                2,
                Phaser.Math.Between(18, 48),
                colorB
              ).setAlpha(0.16);
              r._vy = Phaser.Math.FloatBetween(240, 460);
              drops.push(r);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const d of drops) {
                d.y += d._vy * dt;
                if (d.y > H + 60) { d.y = Phaser.Math.Between(-120, -20); d.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...drops);
          }

          if (fxType === "stars") {
            const stars = [];
            for (let i = 0; i < 62; i++) {
              const s = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(0, H),
                2, 2, colorA
              ).setAlpha(Phaser.Math.FloatBetween(0.07, 0.32));
              s._vy = Phaser.Math.FloatBetween(12, 52);
              stars.push(s);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const s of stars) {
                s.y += s._vy * dt;
                if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...stars);
          }

          return items;
        }

        // ===== Obstacle texture factory =====
        function ensureObstacleTextures(scene) {
          const makeTex = (key, drawFn) => {
            if (scene.textures.exists(key)) return;
            const g = scene.make.graphics({ x:0, y:0, add:false });
            g.clear();
            drawFn(g);
            g.generateTexture(key, 64, 64);
            g.destroy();
          };

          makeTex("obs_rect", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(8, 8, 48, 48, 10);
          });

          makeTex("obs_frame", (g) => {
            g.lineStyle(6, 0xffffff, 1);
            g.strokeRoundedRect(10, 10, 44, 44, 10);
            g.lineStyle(2, 0xffffff, 0.7);
            g.strokeRoundedRect(16, 16, 32, 32, 8);
          });

          makeTex("obs_tri", (g) => {
            g.fillStyle(0xffffff, 1);
            g.beginPath();
            g.moveTo(32, 8);
            g.lineTo(56, 56);
            g.lineTo(8, 56);
            g.closePath();
            g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });

          makeTex("obs_hex", (g) => {
            g.fillStyle(0xffffff, 1);
            const pts = [
              {x:32,y:6},{x:54,y:18},{x:54,y:46},{x:32,y:58},{x:10,y:46},{x:10,y:18}
            ];
            g.beginPath();
            g.moveTo(pts[0].x, pts[0].y);
            for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
            g.closePath(); g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });

          makeTex("obs_bar", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(6, 24, 52, 16, 8);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(6, 24, 52, 16, 8);
          });

          makeTex("obs_plus", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(26, 10, 12, 44, 5);
            g.fillRoundedRect(10, 26, 44, 12, 5);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(26, 10, 12, 44, 5);
            g.strokeRoundedRect(10, 26, 44, 12, 5);
          });
        }

        const shapeToTex = {
          rect: "obs_rect",
          frame: "obs_frame",
          tri: "obs_tri",
          hex: "obs_hex",
          bar: "obs_bar",
          plus: "obs_plus"
        };

        // ===== Scenes =====
        class MenuScene extends Phaser.Scene {
          constructor() { super("Menu"); }
          create() {
            this.cameras.main.setBackgroundColor(0x0a0a12);
            addTitle(this, "GRIDRUN", 0.22, 46);
            addSubtitle(this, "3 Worlds • 5 Levels • Skill-only arcade run", 0.285);

            const p = loadProgress();
            const hasProgress = (p.unlockedWorld > 0) || (p.unlockedLevel > 0);

            makeButton(this, "PLAY (NEW RUN)", W/2, H*0.46, () => {
              const fresh = { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
              saveProgress(fresh);
              this.scene.start("WorldMap");
            });

            const cont = makeGhostButton(this, hasProgress ? "CONTINUE" : "CONTINUE (LOCKED)", W/2, H*0.56, () => {
              if (!hasProgress) return;
              const p2 = loadProgress();
              this.scene.start("WorldIntro", { world: p2.currentWorld, level: p2.currentLevel });
            });
            cont.setAlpha(hasProgress ? 1 : 0.45);

            makeGhostButton(this, "WORLD MAP / LEVEL SELECT", W/2, H*0.66, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "RESET SAVE", W/2, H*0.78, () => { resetProgress(); this.scene.restart(); }).setAlpha(0.75);

            this.add.text(W/2, H*0.88, "No login needed: progress saves locally on your device.", {
              fontFamily: uiFont, fontSize: "12px", color: "#ffffff", align: "center"
            }).setOrigin(0.5).setAlpha(0.55);
          }
        }

        class WorldMapScene extends Phaser.Scene {
          constructor() { super("WorldMap"); }
          create() {
            const p = loadProgress();
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "WORLD MAP", 0.14, 34);
            addSubtitle(this, "Select an unlocked level • Replay anytime", 0.20);

            const marginX = 18;
            const colW = (W - marginX*2);
            let y = H*0.26;

            WORLDS.forEach((w, wi) => {
              const unlockedWorld = wi <= p.unlockedWorld;

              this.add.text(marginX, y, `${wi+1}. ${w.name}`, {
                fontFamily: uiFont, fontSize: "16px",
                color: unlockedWorld ? "#ffffff" : "rgba(255,255,255,0.40)"
              }).setAlpha(0.95);

              y += 26;

              const gap = 10;
              const btnW = (colW - gap*(LEVELS_PER_WORLD-1)) / LEVELS_PER_WORLD;
              for (let li = 0; li < LEVELS_PER_WORLD; li++) {
                const unlocked = isLevelUnlocked(p, wi, li);
                const bx = marginX + li * (btnW + gap);
                const by = y;

                const b = this.add.text(bx + btnW/2, by + 18, `${li+1}`, {
                  fontFamily: uiFont, fontSize: "16px",
                  color: unlocked ? "#0a0a12" : "rgba(255,255,255,0.55)",
                  backgroundColor: unlocked ? "#6ef3ff" : "rgba(255,255,255,0.08)",
                  padding: { left: 0, right: 0, top: 8, bottom: 8 }
                }).setOrigin(0.5);

                b.setFixedSize(btnW, 36);
                if (unlocked) {
                  b.setInteractive({ useHandCursor: true });
                  b.on("pointerdown", () => {
                    const p2 = loadProgress();
                    p2.currentWorld = wi;
                    p2.currentLevel = li;
                    saveProgress(p2);
                    this.scene.start("WorldIntro", { world: wi, level: li });
                  });
                } else {
                  b.setAlpha(0.6);
                }
              }
              y += 58;
            });

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldIntroScene extends Phaser.Scene {
          constructor() { super("WorldIntro"); }
          create(data) {
            const world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            const level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);

            const w = WORLDS[world];
            const lv = w.levels[level];

            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.fx, w.player, w.border);

            addTitle(this, w.name, 0.22, 34);
            addSubtitle(this, w.subtitle, 0.285);

            this.add.text(W/2, H*0.40,
              `Level ${level + 1}/${LEVELS_PER_WORLD}\nTime: ${lv.seconds}s`,
              { fontFamily: uiFont, fontSize: "16px", color: "#ffffff", align: "center" }
            ).setOrigin(0.5).setAlpha(0.92);

            const p = loadProgress();
            p.currentWorld = world;
            p.currentLevel = level;
            saveProgress(p);

            makeButton(this, "START", W/2, H*0.60, () => this.scene.start("Play", { world, level }));
            makeGhostButton(this, "WORLD MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.79, () => this.scene.start("Menu"));
          }
        }

        class PlayScene extends Phaser.Scene {
          constructor() {
            super("Play");
            this.world = 0;
            this.level = 0;
            this.wcfg = WORLDS[0];
            this.lcfg = WORLDS[0].levels[0];

            this.elapsed = 0;
            this.score = 0;
            this.levelTime = 0;

            this.scrollSpeed = 0;
            this.spawnEvery = 0;
            this.spawnTimer = 0;

            this.gridGraphics = null;
            this.gridOffset = 0;

            this.obstacles = null;
            this.player = null;

            this.touchTarget = null;
            this.touchDot = null;

            // boss
            this.laser = null;
            this.laserWarn = null;
            this.bossT = 0;

            // world dressing
            this.decor = [];
            this.glitchFlash = null;
          }

          init(data) {
            this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            this.level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);
            this.wcfg = WORLDS[this.world];
            this.lcfg = this.wcfg.levels[this.level];
          }

          create() {
            ensureObstacleTextures(this);

            this.cameras.main.setBackgroundColor(this.wcfg.bg);
            buildBackdrop(this, this.wcfg.fx, this.wcfg.player, this.wcfg.border);

            this.gridGraphics = this.add.graphics();
            this.gridOffset = 0;

            this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

            const startX = GRID_X + GRID_W / 2;
            const startY = GRID_Y + GRID_H * 0.72;

            this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
            this.physics.add.existing(this.player);
            this.player.body.setAllowGravity(false);

            this.physics.add.overlap(this.player, this.obstacles, () => this.gameOver());

            // PC keyboard
            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys("W,A,S,D");

            // Touch target dot
            this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0);
            this.touchTarget = null;

            this.input.on("pointerdown", (p) => {
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointermove", (p) => {
              if (!p.isDown) return;
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointerup", () => {
              this.touchTarget = null;
              this.touchDot.setAlpha(0);
            });

            // HUD
            this.uiTop = this.add.text(14, 10, "", { fontFamily: uiFont, fontSize: "14px", color: "#ffffff" }).setAlpha(0.95);
            this.uiTime = this.add.text(14, 30, "", { fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff" }).setAlpha(0.95);

            // glitch overlay (W3)
            this.glitchFlash = this.add.rectangle(W/2, H/2, W, H, 0xffffff).setAlpha(0).setDepth(50);

            // run state
            this.elapsed = 0;
            this.score = 0;
            this.levelTime = 0;

            this.scrollSpeed = this.lcfg.baseScroll;
            this.spawnEvery = this.lcfg.spawnStart;
            this.spawnTimer = 0;

            this.setupBoss();
            this.setupDecor();
            this.updateHud();
          }

          setupDecor() {
            for (const d of this.decor) d.destroy();
            this.decor = [];

            if (this.wcfg.gridStyle === "industrial") {
              for (let i = 0; i < 8; i++) {
                const r = this.add.rectangle(GRID_X - 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                const r2 = this.add.rectangle(GRID_X + GRID_W + 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                this.decor.push(r, r2);
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              for (let i=0;i<16;i++){
                const b = this.add.rectangle(
                  Phaser.Math.Between(0, W),
                  Phaser.Math.Between(-H, H),
                  Phaser.Math.Between(10, 26),
                  Phaser.Math.Between(4, 12),
                  0x9aa7ff
                ).setAlpha(Phaser.Math.FloatBetween(0.06, 0.14));
                b._vy = Phaser.Math.FloatBetween(40, 110);
                this.decor.push(b);
              }
            }
          }

          setupBoss() {
            this.bossT = 0;
            if (this.laser) this.laser.destroy();
            if (this.laserWarn) this.laserWarn.destroy();

            const boss = this.wcfg.boss;
            if (!boss || !boss.enabled) return;

            this.laserWarn = this.add.rectangle(
              GRID_X + GRID_W/2, GRID_Y + GRID_H/2,
              GRID_W, boss.warnThickness, 0xffffff
            ).setAlpha(0).setDepth(20);

            this.laser = this.add.rectangle(
              GRID_X + GRID_W/2, GRID_Y + GRID_H/2,
              GRID_W, boss.thickness, 0xff4d7d
            ).setAlpha(0).setDepth(21);
          }

          update(_, deltaMs) {
            const dt = deltaMs / 1000;
            this.elapsed += dt;
            this.levelTime += dt;

            if (this.levelTime >= this.lcfg.seconds) {
              this.levelComplete();
              return;
            }

            // speed curve
            this.scrollSpeed = this.lcfg.baseScroll + this.elapsed * this.lcfg.scrollRamp;

            // spawn curve
            const targetSpawn = this.lcfg.spawnStart - this.elapsed * this.lcfg.spawnRamp;
            this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);

            // score
            this.score += dt * 10;
            this.updateHud();

            // ===== Movement =====
            if (!IS_TOUCH) {
              let kvx = 0, kvy = 0;
              const left = this.cursors.left.isDown || this.keys.A.isDown;
              const right = this.cursors.right.isDown || this.keys.D.isDown;
              const up = this.cursors.up.isDown || this.keys.W.isDown;
              const down = this.cursors.down.isDown || this.keys.S.isDown;
              if (left) kvx -= 1;
              if (right) kvx += 1;
              if (up) kvy -= 1;
              if (down) kvy += 1;
              const mag = Math.hypot(kvx, kvy);
              if (mag > 1) { kvx /= mag; kvy /= mag; }
              this.player.body.setVelocity(kvx * PLAYER_SPEED, kvy * PLAYER_SPEED);
            } else {
              // ✅ Mobile direct follow only
              if (this.touchTarget) {
                const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
                const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

                const dx = tx - this.player.x;
                const dy = ty - this.player.y;
                const dist = Math.hypot(dx, dy);

                if (dist > FOLLOW_RADIUS) {
                  const nx = this.player.x + dx * FOLLOW_LERP;
                  const ny = this.player.y + dy * FOLLOW_LERP;

                  const maxStep = PLAYER_SPEED * FOLLOW_MAX_SPEED_MULT * dt;
                  const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);

                  if (stepDist > maxStep) {
                    const s = maxStep / stepDist;
                    this.player.x = this.player.x + (nx - this.player.x) * s;
                    this.player.y = this.player.y + (ny - this.player.y) * s;
                  } else {
                    this.player.x = nx;
                    this.player.y = ny;
                  }

                  this.player.body.reset(this.player.x, this.player.y);
                } else {
                  this.player.body.setVelocity(0, 0);
                }
              } else {
                this.player.body.setVelocity(0, 0);
              }
            }

            // clamp to grid
            const pad = 14;
            const nx = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
            const ny = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
            if (nx !== this.player.x || ny !== this.player.y) {
              this.player.x = nx; this.player.y = ny;
              this.player.body.reset(nx, ny);
            }

            // decor
            if (this.wcfg.gridStyle === "glitch") {
              for (const b of this.decor) {
                b.y += b._vy * dt;
                if (b.y > H + 20) { b.y = -20; b.x = Phaser.Math.Between(0, W); }
              }
              if (Math.random() < 0.015) {
                this.glitchFlash.setAlpha(0.07);
                this.tweens.add({ targets: this.glitchFlash, alpha: 0, duration: 120, ease: "Linear" });
              }
            }

            // spawn
            this.spawnTimer += deltaMs;
            while (this.spawnTimer >= this.spawnEvery) {
              this.spawnTimer -= this.spawnEvery;
              this.spawnObstacle();
            }

            // move obstacles
            this.obstacles.children.iterate((o) => {
              if (!o) return;
              o.y += this.scrollSpeed * dt;
              if (o.y > GRID_Y + GRID_H + 140) o.destroy();
            });

            // boss
            this.updateBoss(dt);

            // grid
            this.drawGrid(dt);
          }

          updateHud() {
            const timeLeft = Math.max(0, Math.ceil(this.lcfg.seconds - this.levelTime));
            this.uiTop.setText(`${this.wcfg.name} • Level ${this.level+1}/${LEVELS_PER_WORLD} • Score: ${Math.floor(this.score)}`);
            this.uiTime.setText(`Time Left: ${timeLeft}s`);
          }

          drawGrid(dt) {
            this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
            const g = this.gridGraphics;
            g.clear();

            g.lineStyle(2, this.wcfg.border, 0.92);
            g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

            if (this.wcfg.gridStyle === "circuit") {
              g.lineStyle(1, this.wcfg.gridLine, 0.95);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.fillStyle(this.wcfg.player, 0.12);
              for (let c = 0; c <= GRID_COLS; c++) {
                for (let r = 0; r <= GRID_ROWS; r++) {
                  if ((c + r) % 3 !== 0) continue;
                  g.fillCircle(GRID_X + c*TILE, GRID_Y + r*TILE, 2.2);
                }
              }
            }

            if (this.wcfg.gridStyle === "industrial") {
              g.lineStyle(2, this.wcfg.gridLine, 0.9);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.lineStyle(1, 0xffd166, 0.07);
              for (let x = GRID_X - GRID_H; x < GRID_X + GRID_W + GRID_H; x += 18) {
                g.beginPath();
                g.moveTo(x, GRID_Y);
                g.lineTo(x + GRID_H, GRID_Y + GRID_H);
                g.strokePath();
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              const flick = 0.75 + Math.sin(this.elapsed * 8) * 0.10;
              g.lineStyle(1, this.wcfg.gridLine, flick);

              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                let y0 = GRID_Y;
                while (y0 < GRID_Y + GRID_H) {
                  const seg = Phaser.Math.Between(18, 64);
                  const gap = Phaser.Math.Between(10, 40);
                  if (Math.random() > 0.22) {
                    g.beginPath();
                    g.moveTo(x, y0);
                    g.lineTo(x, Math.min(GRID_Y + GRID_H, y0 + seg));
                    g.strokePath();
                  }
                  y0 += seg + gap;
                }
              }

              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                let x0 = GRID_X;
                while (x0 < GRID_X + GRID_W) {
                  const seg = Phaser.Math.Between(20, 70);
                  const gap = Phaser.Math.Between(12, 44);
                  if (Math.random() > 0.25) {
                    g.beginPath();
                    g.moveTo(x0, y);
                    g.lineTo(Math.min(GRID_X + GRID_W, x0 + seg), y);
                    g.strokePath();
                  }
                  x0 += seg + gap;
                }
              }
            }
          }

          spawnObstacle() {
            const col = Phaser.Math.Between(0, GRID_COLS - 1);
            const x = GRID_X + col * TILE + TILE / 2;
            const y = GRID_Y - 70;

            const style = this.wcfg.obstacleStyle;
            const shape = style.shapes[Phaser.Math.Between(0, style.shapes.length - 1)];
            const tex = shapeToTex[shape] || "obs_rect";
            const color = style.palette[Phaser.Math.Between(0, style.palette.length - 1)];

            const [smin, smax] = this.lcfg.size;
            let w = Phaser.Math.Between(smin, smax);
            let h = Phaser.Math.Between(smin, smax);

            if (shape === "bar") { w = Phaser.Math.Between(smax+8, smax+26); h = Phaser.Math.Between(14, 22); }
            if (shape === "tri") { w = Phaser.Math.Between(smin, smax+4); h = Phaser.Math.Between(smin, smax+8); }
            if (shape === "frame") { w = Phaser.Math.Between(smin+2, smax+10); h = Phaser.Math.Between(smin+2, smax+10); }
            if (shape === "plus") { w = Phaser.Math.Between(smin, smax+10); h = Phaser.Math.Between(smin, smax+10); }

            const s = this.add.image(x, y, tex);
            s.setTint(color);
            s.setAlpha(0.95);
            s.displayWidth = w;
            s.displayHeight = h;

            this.physics.add.existing(s);
            s.body.setAllowGravity(false);
            s.body.setImmovable(true);
            s.body.setSize(w * 0.88, h * 0.88, true);
            this.obstacles.add(s);

            // extra piece (mild, increases later + in harder worlds)
            const worldBonus = this.world * 0.02; // W2/W3 get a touch more
            const later = this.level >= 2 ? 1 : 0;
            const chance = Phaser.Math.Clamp(0.05 + later*0.06 + worldBonus + (this.elapsed * 0.0025), 0.05, 0.24);
            if (Math.random() < chance && this.levelTime > 5) {
              let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
              if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;
              const x2 = GRID_X + col2 * TILE + TILE / 2;

              const shape2 = style.shapes[Phaser.Math.Between(0, style.shapes.length - 1)];
              const tex2 = shapeToTex[shape2] || "obs_rect";
              const color2 = style.palette[Phaser.Math.Between(0, style.palette.length - 1)];

              const s2 = this.add.image(x2, y - Phaser.Math.Between(22, 90), tex2);
              s2.setTint(color2);
              s2.setAlpha(0.9);
              s2.displayWidth = Math.max(14, w * 0.78);
              s2.displayHeight = Math.max(14, h * 0.78);

              this.physics.add.existing(s2);
              s2.body.setAllowGravity(false);
              s2.body.setImmovable(true);
              s2.body.setSize(s2.displayWidth * 0.88, s2.displayHeight * 0.88, true);
              this.obstacles.add(s2);
            }
          }

          updateBoss(dt) {
            const boss = this.wcfg.boss;
            if (!boss || !boss.enabled || !this.laser || !this.laserWarn) return;

            this.bossT += dt;
            const cycle = boss.cycleSeconds;
            const t = this.bossT % cycle;

            const drift = (this.bossT * 0.22) % 1;
            const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + drift) % 1);

            this.laserWarn.setPosition(GRID_X + GRID_W/2, yPos);
            this.laser.setPosition(GRID_X + GRID_W/2, yPos);

            const warnOn = t < boss.warnSeconds;
            const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

            this.laserWarn.setAlpha(warnOn ? 0.35 : 0);
            this.laser.setAlpha(activeOn ? 0.85 : 0);

            if (activeOn) {
              const pr = this.player.getBounds();
              const lr = this.laser.getBounds();
              if (Phaser.Geom.Intersects.RectangleToRectangle(pr, lr)) this.gameOver();
            }
          }

          levelComplete() {
            const p = loadProgress();

            let nextWorld = this.world;
            let nextLevel = this.level + 1;
            let worldClear = false;

            if (nextLevel >= LEVELS_PER_WORLD) {
              worldClear = true;
              nextLevel = 0;
              nextWorld = this.world + 1;
            }

            if (worldClear) {
              p.unlockedWorld = Math.max(p.unlockedWorld, this.world + 1);
              p.unlockedLevel = 0;
            } else {
              if (p.unlockedWorld < this.world) p.unlockedWorld = this.world;
              if (p.unlockedWorld === this.world) p.unlockedLevel = Math.max(p.unlockedLevel, this.level + 1);
            }

            if (nextWorld >= WORLDS.length) {
              p.currentWorld = WORLDS.length - 1;
              p.currentLevel = LEVELS_PER_WORLD - 1;
            } else {
              p.currentWorld = nextWorld;
              p.currentLevel = nextLevel;
            }
            saveProgress(p);

            if (nextWorld >= WORLDS.length) this.scene.start("CampaignComplete", { score: Math.floor(this.score) });
            else if (worldClear) this.scene.start("WorldComplete", { world: this.world, score: Math.floor(this.score) });
            else this.scene.start("LevelComplete", { world: this.world, level: this.level, score: Math.floor(this.score) });
          }

          gameOver() {
            this.scene.start("GameOver", {
              world: this.world,
              level: this.level,
              score: Math.floor(this.score),
              timeLeft: Math.max(0, Math.ceil(this.lcfg.seconds - this.levelTime))
            });
          }
        }

        class LevelCompleteScene extends Phaser.Scene {
          constructor() { super("LevelComplete"); }
          create(data) {
            const world = data?.world ?? 0;
            const level = data?.level ?? 0;
            const score = data?.score ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.fx, w.player, w.border);

            addTitle(this, "LEVEL CLEAR", 0.30, 34);
            this.add.text(W/2, H*0.40, `${w.name} • Level ${level + 1}/${LEVELS_PER_WORLD}`, {
              fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#ffffff"
            }).setOrigin(0.5);

            makeButton(this, "NEXT", W/2, H*0.60, () => {
              const p = loadProgress();
              this.scene.start("WorldIntro", { world: p.currentWorld, level: p.currentLevel });
            });

            makeGhostButton(this, "WORLD MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.79, () => this.scene.start("Menu"));
          }
        }

        class WorldCompleteScene extends Phaser.Scene {
          constructor() { super("WorldComplete"); }
          create(data) {
            const world = data?.world ?? 0;
            const score = data?.score ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.fx, w.player, w.border);

            addTitle(this, "WORLD CLEAR", 0.30, 34);
            this.add.text(W/2, H*0.40, `${w.name} completed`, {
              fontFamily: uiFont, fontSize: "16px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#b7b7ff"
            }).setOrigin(0.5);

            makeButton(this, "NEXT WORLD", W/2, H*0.62, () => {
              const p = loadProgress();
              this.scene.start("WorldIntro", { world: p.currentWorld, level: p.currentLevel });
            });

            makeGhostButton(this, "WORLD MAP", W/2, H*0.72, () => this.scene.start("WorldMap"));
          }
        }

        class CampaignCompleteScene extends Phaser.Scene {
          constructor() { super("CampaignComplete"); }
          create(data) {
            this.cameras.main.setBackgroundColor(0x020208);

            addTitle(this, "CAMPAIGN CLEAR", 0.30, 32);
            this.add.text(W/2, H*0.42, "You cleared all worlds.", {
              fontFamily: uiFont, fontSize: "16px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.50, `Final Score: ${data?.score ?? 0}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#b7b7ff"
            }).setOrigin(0.5);

            makeButton(this, "PLAY AGAIN", W/2, H*0.64, () => {
              const fresh = { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
              saveProgress(fresh);
              this.scene.start("WorldMap");
            });

            makeGhostButton(this, "MAIN MENU", W/2, H*0.74, () => this.scene.start("Menu"));
          }
        }

        class GameOverScene extends Phaser.Scene {
          constructor() { super("GameOver"); }
          create(data) {
            const world = data?.world ?? 0;
            const level = data?.level ?? 0;
            const score = data?.score ?? 0;
            const timeLeft = data?.timeLeft ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "RUN ENDED", 0.33, 34);
            this.add.text(W/2, H*0.42, `${w.name} • Level ${level + 1}/${LEVELS_PER_WORLD}`, {
              fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.54, `Time left: ${timeLeft}s`, {
              fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff"
            }).setOrigin(0.5).setAlpha(0.85);

            makeButton(this, "RETRY LEVEL", W/2, H*0.66, () => this.scene.start("Play", { world, level }));
            makeGhostButton(this, "WORLD MAP", W/2, H*0.76, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.84, () => this.scene.start("Menu"));
          }
        }

        new Phaser.Game({
          type: Phaser.AUTO,
          width: W,
          height: H,
          physics: { default: "arcade", arcade: { debug: false } },
          scene: [
            MenuScene,
            WorldMapScene,
            WorldIntroScene,
            PlayScene,
            LevelCompleteScene,
            WorldCompleteScene,
            CampaignCompleteScene,
            GameOverScene
          ],
        });

      }, 50);
    });
  </script>
</body>
</html>
