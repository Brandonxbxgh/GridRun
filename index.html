<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TXC GRIDRUN</title>
  <style>
    :root{
      --bg0:#070812;
      --bg1:#0b0f25;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --line:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);

      --accent:#6ee7ff;
      --accent2:#b7ff6e;
      --warn:#ff6ee7;
      --danger:#ff4d4d;

      --btn:#141a38;
      --btnH:#1b2350;

      --lb:#2a1a55;      /* leaderboard button color */
      --lbH:#3a2580;
      --reset:#5a1f1f;   /* reset button color */
      --resetH:#7a2b2b;

      --shadow: 0 14px 45px rgba(0,0,0,.45);
      --radius: 18px;
    }

    html,body{height:100%; background:radial-gradient(1200px 800px at 20% 15%, #1a1e4a 0%, var(--bg0) 55%, #02030a 100%); margin:0; color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    *{box-sizing:border-box;}
    button{font:inherit; color:inherit; -webkit-tap-highlight-color: transparent;}
    .app{min-height:100%; display:flex; align-items:center; justify-content:center; padding:18px;}

    /* Subtle animated grid */
    .bg-grid{
      position:fixed; inset:0; pointer-events:none; opacity:.18;
      background:
        linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
      background-size: 40px 40px;
      mask-image: radial-gradient(closest-side at 50% 45%, rgba(0,0,0,1), rgba(0,0,0,.25) 60%, rgba(0,0,0,0) 100%);
      animation: drift 14s linear infinite;
    }
    @keyframes drift{
      from{ transform: translate3d(0,0,0); }
      to{ transform: translate3d(-40px,-40px,0); }
    }

    .shell{
      width:min(1040px, 100%);
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .shell{grid-template-columns:1fr; max-width:700px;}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .left{
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .brand{
      padding:14px 14px 10px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(110,231,255,.16), rgba(183,255,110,.10));
      border:1px solid rgba(255,255,255,.12);
      position:relative;
      overflow:hidden;
    }
    .brand:before{
      content:"";
      position:absolute; inset:-40px;
      background: radial-gradient(400px 160px at 20% 30%, rgba(110,231,255,.24), transparent 60%),
                  radial-gradient(360px 140px at 70% 55%, rgba(255,110,231,.16), transparent 60%);
      filter: blur(0px);
      transform: rotate(-8deg);
    }
    .brand > *{position:relative;}
    .title{
      display:flex; align-items:center; gap:10px;
      font-weight:900; letter-spacing:.12em; font-size:22px;
      text-transform:uppercase;
    }
    .glyph{
      width:34px; height:34px; border-radius:12px;
      background: conic-gradient(from 110deg, var(--accent), var(--warn), var(--accent2), var(--accent));
      box-shadow: 0 10px 30px rgba(110,231,255,.22);
      border:1px solid rgba(255,255,255,.14);
    }
    /* removed subtitle under GRIDRUN per request */

    .menu{
      display:flex; flex-direction:column; gap:10px;
      padding:14px;
      border-radius:16px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
    }

    .btn{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, var(--btn), rgba(255,255,255,.02));
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      display:flex; align-items:center; justify-content:space-between;
      touch-action: manipulation;
      user-select:none;
    }
    .btn:hover{background: linear-gradient(180deg, var(--btnH), rgba(255,255,255,.02));}
    .btn:active{transform: translateY(1px) scale(.998);}
    .btn .hint{font-size:12px; color:var(--muted); letter-spacing:.06em;}

    .btn.lb{ background: linear-gradient(180deg, var(--lb), rgba(255,255,255,.02)); }
    .btn.lb:hover{ background: linear-gradient(180deg, var(--lbH), rgba(255,255,255,.02)); }
    .btn.reset{ background: linear-gradient(180deg, var(--reset), rgba(255,255,255,.02)); }
    .btn.reset:hover{ background: linear-gradient(180deg, var(--resetH), rgba(255,255,255,.02)); }

    .tiny{
      display:flex; gap:10px;
    }
    .tiny .btn{padding:10px 12px;}
    .tiny .btn span{font-size:13px;}

    .panelTitle{
      font-weight:800; letter-spacing:.08em; text-transform:uppercase;
      color:rgba(255,255,255,.85); font-size:12px;
      margin:2px 0 6px;
    }

    .note{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.35;
    }
    /* removed bottom PC/mobile instructions text per request */

    .right{padding:0; display:flex; flex-direction:column;}
    .topbar{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      background: rgba(0,0,0,.20);
    }
    .stats{
      display:flex; flex-wrap:wrap; gap:10px;
      font-size:12.5px;
      color:rgba(255,255,255,.85);
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      display:flex; gap:8px; align-items:center;
    }
    .pill b{color:var(--text); font-weight:800;}
    .pill .dot{width:8px; height:8px; border-radius:999px; background: var(--accent); box-shadow: 0 0 18px rgba(110,231,255,.35);}

    .topActions{
      display:flex; gap:10px; align-items:center;
    }
    .iconBtn{
      padding:9px 12px;
      border-radius:12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      cursor:pointer;
      transition:.15s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .iconBtn:hover{background: rgba(255,255,255,.09);}
    .iconBtn:active{transform: translateY(1px);}

    .canvasWrap{
      position:relative;
      padding:14px;
      display:flex;
      justify-content:center;
      align-items:center;
      background: rgba(0,0,0,.18);
      flex: 1 1 auto;
    }
    canvas{
      width:100%;
      max-width: 700px;
      aspect-ratio: 9/16;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(6,7,16,1), rgba(2,3,10,1));
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
      touch-action: none; /* allow our touch controls without scroll */
    }

    .overlay{
      position:absolute; inset:14px;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .modal{
      width:min(520px, 100%);
      background: rgba(10,12,26,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding:14px;
      box-shadow: var(--shadow);
      pointer-events:auto;
      backdrop-filter: blur(8px);
    }
    .modal h3{margin:0 0 10px; font-size:14px; letter-spacing:.08em; text-transform:uppercase; color:rgba(255,255,255,.86);}
    .modal p{margin:0 0 10px; color:rgba(255,255,255,.76); font-size:13px; line-height:1.35;}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap;}
    .modal .row .btn{width:auto; flex:1 1 160px;}

    .leaderboard{
      margin-top:8px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
    }
    .lbHead{
      display:flex; justify-content:space-between; gap:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.10);
      font-size:12px; letter-spacing:.08em; text-transform:uppercase;
      color:rgba(255,255,255,.80);
    }
    .lbList{max-height: 260px; overflow:auto; background: rgba(0,0,0,.18);}
    .lbRow{
      display:grid;
      grid-template-columns: 42px 1fr 120px;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
      color:rgba(255,255,255,.84);
      align-items:center;
    }
    .lbRow:last-child{border-bottom:none;}
    .rank{
      width:28px; height:28px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      font-weight:800;
      color:rgba(255,255,255,.86);
    }
    .name{color:rgba(255,255,255,.86); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .score{font-variant-numeric: tabular-nums; text-align:right; font-weight:900; color:rgba(255,255,255,.92);}
    .modeTag{
      display:inline-flex; align-items:center; gap:8px;
      margin-top:10px;
      font-size:12px; color:rgba(255,255,255,.78);
    }
    .modeTag .badge{
      padding:5px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      letter-spacing:.08em;
      text-transform:uppercase;
      font-weight:800;
      font-size:11px;
    }
  </style>
</head>

<body>
  <div class="bg-grid"></div>
  <div class="app">
    <div class="shell">
      <div class="card left">
        <div class="brand">
          <div class="title">
            <div class="glyph"></div>
            <div>GRIDRUN</div>
          </div>
          <!-- subtitle removed per request -->
        </div>

        <div class="menu" id="menuMain">
          <div class="panelTitle">Main Menu</div>

          <button class="btn" id="btnCampaign">
            <span><b>Campaign</b></span>
            <span class="hint">replay unlocked levels</span>
          </button>

          <button class="btn" id="btnEndless">
            <span><b>Endless</b></span>
            <span class="hint">starts at W1-L1 difficulty</span>
          </button>

          <button class="btn lb" id="btnLeaderboards">
            <span><b>Leaderboards</b></span>
            <span class="hint">campaign / endless</span>
          </button>

          <div class="tiny">
            <button class="btn reset" id="btnResetSave">
              <span><b>Reset Save</b></span>
              <span class="hint">local only</span>
            </button>
            <button class="btn" id="btnExit">
              <span><b>Exit</b></span>
              <span class="hint">close tab</span>
            </button>
          </div>
        </div>

        <!-- Submenus -->
        <div class="menu" id="menuCampaign" style="display:none;">
          <div class="panelTitle">Campaign</div>
          <div class="note">
            Pick a level. You can replay any level you’ve beaten.
            <div class="modeTag"><span class="badge">Campaign</span><span id="campaignProgressText"></span></div>
          </div>
          <div id="campaignLevels"></div>
          <button class="btn" id="btnBackFromCampaign"><span><b>Back</b></span><span class="hint">menu</span></button>
        </div>

        <div class="menu" id="menuLeaderboards" style="display:none;">
          <div class="panelTitle">Leaderboards</div>

          <div class="note" style="margin-bottom:10px;">
            Scoring is the same in both modes, tracked separately.
            Effects begin at <b>30s</b> and stack earlier.
          </div>

          <div class="tiny" style="margin-bottom:10px;">
            <button class="btn lb" id="lbShowCampaign"><span><b>Campaign</b></span><span class="hint">top scores</span></button>
            <button class="btn lb" id="lbShowEndless"><span><b>Endless</b></span><span class="hint">top scores</span></button>
          </div>

          <div class="leaderboard">
            <div class="lbHead">
              <span id="lbTitle">Campaign</span>
              <span id="lbCount">Top 10</span>
            </div>
            <div class="lbList" id="lbList"></div>
          </div>

          <button class="btn" id="btnBackFromLB"><span><b>Back</b></span><span class="hint">menu</span></button>
        </div>

        <div class="note">
          <!-- bottom instructions removed per request -->
          <b>Tip:</b> On mobile, drag to move. Tap <b>Pause</b> anytime.
        </div>
      </div>

      <div class="card right">
        <div class="topbar">
          <div class="stats">
            <div class="pill"><span class="dot"></span><span>Mode: <b id="statMode">Menu</b></span></div>
            <div class="pill"><span>Score: <b id="statScore">0</b></span></div>
            <div class="pill"><span>Time: <b id="statTime">0.0</b>s</span></div>
            <div class="pill"><span>Speed: <b id="statSpeed">1.00</b>x</span></div>
          </div>
          <div class="topActions">
            <button class="iconBtn" id="btnPause" aria-label="Pause">Pause</button>
            <button class="iconBtn" id="btnMenu" aria-label="Menu">Menu</button>
          </div>
        </div>

        <div class="canvasWrap">
          <canvas id="game" width="720" height="1280"></canvas>

          <div class="overlay" id="overlay" style="display:none;">
            <div class="modal" id="modal">
              <h3 id="modalTitle">Paused</h3>
              <p id="modalText">Game paused.</p>
              <div class="row">
                <button class="btn" id="btnResume"><span><b>Resume</b></span></button>
                <button class="btn" id="btnRestart"><span><b>Restart</b></span></button>
                <button class="btn" id="btnToMenu"><span><b>Main Menu</b></span></button>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

<script>
(() => {
  // =========================
  // Storage / Save / LB
  // =========================
  const KEY_SAVE = "gridrun_save_v1";
  const KEY_LB_CAMPAIGN = "gridrun_lb_campaign_v1";
  const KEY_LB_ENDLESS = "gridrun_lb_endless_v1";

  const defaultSave = () => ({
    campaign: {
      unlockedLevel: 1, // 1..N
      bestPerLevel: {}  // level -> bestScore
    }
  });

  function loadSave(){
    try{
      const raw = localStorage.getItem(KEY_SAVE);
      if(!raw) return defaultSave();
      const obj = JSON.parse(raw);
      // minimal shape validation:
      if(!obj || !obj.campaign) return defaultSave();
      if(typeof obj.campaign.unlockedLevel !== "number") obj.campaign.unlockedLevel = 1;
      if(!obj.campaign.bestPerLevel || typeof obj.campaign.bestPerLevel !== "object") obj.campaign.bestPerLevel = {};
      return obj;
    }catch(e){
      return defaultSave();
    }
  }
  function saveSave(s){ localStorage.setItem(KEY_SAVE, JSON.stringify(s)); }

  function loadLB(key){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    }catch(e){
      return [];
    }
  }
  function saveLB(key, arr){ localStorage.setItem(key, JSON.stringify(arr)); }

  function addLeaderboardScore(mode, score, meta){
    const key = (mode === "campaign") ? KEY_LB_CAMPAIGN : KEY_LB_ENDLESS;
    const list = loadLB(key);

    // keep anonymous names but allow prompt if you want later
    const entry = {
      name: (meta && meta.name) ? meta.name : "Runner",
      score: Math.floor(score),
      ts: Date.now(),
      detail: meta || {}
    };
    list.push(entry);
    list.sort((a,b) => b.score - a.score || a.ts - b.ts);
    const trimmed = list.slice(0, 10);
    saveLB(key, trimmed);
    return trimmed;
  }

  // =========================
  // UI Wiring
  // =========================
  const $ = (id) => document.getElementById(id);

  const menuMain = $("menuMain");
  const menuCampaign = $("menuCampaign");
  const menuLeaderboards = $("menuLeaderboards");
  const campaignLevelsEl = $("campaignLevels");
  const campaignProgressText = $("campaignProgressText");

  const statMode = $("statMode");
  const statScore = $("statScore");
  const statTime = $("statTime");
  const statSpeed = $("statSpeed");

  const overlay = $("overlay");
  const modalTitle = $("modalTitle");
  const modalText = $("modalText");

  const btnPause = $("btnPause");
  const btnMenu = $("btnMenu");
  const btnResume = $("btnResume");
  const btnRestart = $("btnRestart");
  const btnToMenu = $("btnToMenu");

  const lbListEl = $("lbList");
  const lbTitle = $("lbTitle");
  const lbCount = $("lbCount");

  let save = loadSave();

  function showMenu(which){
    menuMain.style.display = "none";
    menuCampaign.style.display = "none";
    menuLeaderboards.style.display = "none";
    which.style.display = "flex";
  }

  function renderCampaignMenu(){
    const maxLevels = 8; // adjust as desired
    const unlocked = Math.max(1, Math.min(maxLevels, save.campaign.unlockedLevel));
    campaignProgressText.textContent = `Unlocked: ${unlocked}/${maxLevels}`;

    campaignLevelsEl.innerHTML = "";
    for(let i=1;i<=maxLevels;i++){
      const isLocked = i > unlocked;
      const best = save.campaign.bestPerLevel[String(i)] || 0;

      const btn = document.createElement("button");
      btn.className = "btn";
      btn.disabled = isLocked;
      btn.style.opacity = isLocked ? ".45" : "1";
      btn.innerHTML = `<span><b>Level ${i}</b> <span style="color:rgba(255,255,255,.65);font-weight:700;">• Best ${best}</span></span>
                       <span class="hint">${isLocked ? "locked" : "start"}</span>`;
      btn.addEventListener("click", () => startCampaign(i), {passive:true});
      campaignLevelsEl.appendChild(btn);
    }
  }

  function renderLeaderboards(mode){
    const key = (mode === "campaign") ? KEY_LB_CAMPAIGN : KEY_LB_ENDLESS;
    const list = loadLB(key);
    lbTitle.textContent = (mode === "campaign") ? "Campaign" : "Endless";
    lbCount.textContent = `Top ${Math.max(1, Math.min(10, list.length || 10))}`;

    lbListEl.innerHTML = "";
    const shown = list.length ? list : Array.from({length:10}, (_,i)=>({name:"—", score:0, ts:0}));
    shown.slice(0,10).forEach((e, idx) => {
      const row = document.createElement("div");
      row.className = "lbRow";
      row.innerHTML = `
        <div class="rank">${idx+1}</div>
        <div class="name">${escapeHtml(e.name || "Runner")}</div>
        <div class="score">${Number(e.score||0).toLocaleString()}</div>
      `;
      lbListEl.appendChild(row);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[c]));
  }

  // Buttons
  $("btnCampaign").addEventListener("click", () => { renderCampaignMenu(); showMenu(menuCampaign); }, {passive:true});
  $("btnEndless").addEventListener("click", () => startEndless(), {passive:true});
  $("btnLeaderboards").addEventListener("click", () => { renderLeaderboards("campaign"); showMenu(menuLeaderboards); }, {passive:true});
  $("btnBackFromCampaign").addEventListener("click", () => showMenu(menuMain), {passive:true});
  $("btnBackFromLB").addEventListener("click", () => showMenu(menuMain), {passive:true});
  $("lbShowCampaign").addEventListener("click", () => renderLeaderboards("campaign"), {passive:true});
  $("lbShowEndless").addEventListener("click", () => renderLeaderboards("endless"), {passive:true});

  $("btnResetSave").addEventListener("click", () => {
    if(confirm("Reset local save + best scores?")){
      save = defaultSave();
      saveSave(save);
      alert("Save reset.");
      renderCampaignMenu();
    }
  }, {passive:true});

  $("btnExit").addEventListener("click", () => {
    // Best-effort "exit"
    window.close();
  }, {passive:true});

  // =========================
  // Game Core
  // =========================
  const canvas = $("game");
  const ctx = canvas.getContext("2d", { alpha: true });

  // Input
  let inputX = 0;
  let dragging = false;

  // Mobile + Desktop controls
  canvas.addEventListener("pointerdown", (e) => {
    dragging = true;
    inputX = getPointerX(e);
    canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointermove", (e) => {
    if(!dragging) return;
    inputX = getPointerX(e);
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointerup", (e) => {
    dragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
  }, {passive:false});

  function getPointerX(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    return Math.max(0, Math.min(1, x));
  }

  // Make pause reliably work on mobile:
  // - use pointerdown with passive:false so taps always register
  // - stop propagation to avoid canvas capturing it
  // - toggle our paused state and overlay
  function bindPauseButton(btn){
    const onToggle = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if(state.screen === "game"){
        togglePause();
      }
    };
    btn.addEventListener("pointerdown", onToggle, {passive:false});
    btn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); }, {passive:false});
  }
  bindPauseButton(btnPause);

  btnMenu.addEventListener("pointerdown", (e) => {
    e.preventDefault(); e.stopPropagation();
    goToMenu();
  }, {passive:false});

  btnResume.addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); setPaused(false); }, {passive:false});
  btnRestart.addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); restartRun(); }, {passive:false});
  btnToMenu.addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); goToMenu(); }, {passive:false});

  // Auto-pause on tab background / focus loss (mobile safety)
  document.addEventListener("visibilitychange", () => {
    if(document.hidden && state.screen === "game" && !state.paused){
      setPaused(true, true);
    }
  }, {passive:true});
  window.addEventListener("blur", () => {
    if(state.screen === "game" && !state.paused){
      setPaused(true, true);
    }
  }, {passive:true});

  // State
  const state = {
    screen: "menu",       // menu | game
    mode: "endless",      // endless | campaign
    level: 1,             // for campaign
    paused: false,
    autoPaused: false,
    running: false,

    t: 0,                 // elapsed seconds
    score: 0,

    // difficulty
    baseSpeed: 1.0,       // multiplier
    hazardRate: 1.0,      // spawn scaling

    // player
    player: { x: 0.5, y: 0.86, r: 18, inv: 0 },

    // hazards
    hazards: [],
    particles: [],

    // effects
    effects: {
      glitch: false,
      shake: 0,
      scanlines: false,
      invert: false,
      lasers: false,
    },

    // timers
    spawnAcc: 0,
    laserAcc: 0,
    glitchAcc: 0,
  };

  // Hazards
  function makeBlock(){
    // horizontal moving blocks descending
    const laneW = 1/7;
    const lane = Math.floor(rand(0, 7));
    const w = laneW * rand(1.4, 2.2);
    const x = (lane * laneW) + rand(0, laneW) - w/2;
    return {
      kind: "block",
      x: clamp(x, 0.02, 0.98 - w),
      y: -0.12,
      w, h: rand(0.04, 0.07),
      vx: rand(-0.10, 0.10) * pick([-1,1]),
      vy: rand(0.45, 0.72),
      hot: false
    };
  }

  function makeLaserVertical(){
    // vertical laser columns appear, warn then fire
    const x = rand(0.12, 0.88);
    const w = rand(0.03, 0.06);
    return {
      kind: "vlaser",
      x: x - w/2, w,
      y: 0,
      h: 1,
      phase: "warn",      // warn -> fire -> fade
      t: 0,
      warnTime: 0.65,
      fireTime: 0.55,
      fadeTime: 0.35
    };
  }

  // Utility
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  // =========================
  // Scoring (same for both modes)
  // =========================
  // - score grows with survival time and difficulty multipliers
  // - no separate formula; separate leaderboards
  function scorePerSecond(){
    // base 30 pts/sec + scaling with speed and active effects
    let mult = 1.0;
    if(state.effects.glitch) mult += 0.15;
    if(state.effects.scanlines) mult += 0.10;
    if(state.effects.invert) mult += 0.10;
    if(state.effects.lasers) mult += 0.20;

    // speed impacts
    mult *= (0.85 + state.baseSpeed * 0.35);
    return 30 * mult;
  }

  // =========================
  // Effects schedule (start at 30s, earlier variety)
  // =========================
  function updateEffects(){
    const t = state.t;

    // Always ramp speed slowly
    // Starts at 1.0 and ramps beyond (endless + campaign)
    const speedRamp = 1 + (t * 0.010); // ~ +0.6 at 60s
    state.baseSpeed = clamp(speedRamp, 1.0, 3.0);

    // Hazard rate ramp
    state.hazardRate = clamp(1 + (t * 0.012), 1, 3.4);

    // Effects begin at 30 seconds (first effect)
    // Stack earlier than before
    state.effects.glitch = (t >= 30);
    state.effects.scanlines = (t >= 42);
    state.effects.lasers = (t >= 55);     // vertical lasers start early-ish
    state.effects.invert = (t >= 75);

    // screen shake spikes
    if(t >= 30 && Math.floor(t) % 12 === 0){
      state.effects.shake = Math.max(state.effects.shake, 6);
    }
  }

  // =========================
  // Pause handling (robust)
  // =========================
  function setPaused(p, auto=false){
    state.paused = p;
    state.autoPaused = auto;
    overlay.style.display = p ? "flex" : "none";
    btnPause.textContent = p ? "Resume" : "Pause";

    if(p){
      modalTitle.textContent = auto ? "Paused (Auto)" : "Paused";
      modalText.textContent = "Game paused.";
    }
  }
  function togglePause(){
    setPaused(!state.paused, false);
  }

  // =========================
  // Screens / Start / Restart
  // =========================
  function startCampaign(level){
    state.mode = "campaign";
    state.level = level;
    startRun();
  }
  function startEndless(){
    state.mode = "endless";
    state.level = 1;
    startRun();
  }

  function startRun(){
    state.screen = "game";
    showMenu(menuMain);
    overlay.style.display = "none";

    // Reset run state
    state.running = true;
    state.paused = false;
    state.autoPaused = false;

    state.t = 0;
    state.score = 0;

    state.player.x = 0.5;
    state.player.inv = 0;

    state.hazards.length = 0;
    state.particles.length = 0;

    state.spawnAcc = 0;
    state.laserAcc = 0;
    state.glitchAcc = 0;

    state.effects.glitch = false;
    state.effects.scanlines = false;
    state.effects.invert = false;
    state.effects.lasers = false;
    state.effects.shake = 0;

    // Campaign difficulty scaling by level, but ensure Endless starts at at least W1-L1 difficulty:
    // We'll treat Level 1 baseline as the minimum for BOTH.
    // Campaign levels slightly bump starting rate/speed.
    if(state.mode === "campaign"){
      const bump = (state.level - 1) * 0.12;
      state.baseSpeed = 1.0 + bump;
      state.hazardRate = 1.0 + bump;
    } else {
      state.baseSpeed = 1.0;
      state.hazardRate = 1.0;
    }

    statMode.textContent = (state.mode === "campaign") ? `Campaign L${state.level}` : "Endless";
    setPaused(false);
  }

  function restartRun(){
    if(state.screen !== "game") return;
    startRun();
  }

  function goToMenu(){
    state.screen = "menu";
    state.running = false;
    setPaused(false);
    statMode.textContent = "Menu";
    statScore.textContent = "0";
    statTime.textContent = "0.0";
    statSpeed.textContent = "1.00";
    showMenu(menuMain);
  }

  // =========================
  // Game Over / Results
  // =========================
  function endRun(){
    state.running = false;
    setPaused(true, false);
    modalTitle.textContent = "Run Complete";
    modalText.textContent = `Score: ${Math.floor(state.score).toLocaleString()} • Time: ${state.t.toFixed(1)}s`;

    // Update save + leaderboards
    if(state.mode === "campaign"){
      const lvlKey = String(state.level);
      const prevBest = save.campaign.bestPerLevel[lvlKey] || 0;
      if(state.score > prevBest){
        save.campaign.bestPerLevel[lvlKey] = Math.floor(state.score);
      }
      // unlock next level if completed (survived at least 20s OR score threshold)
      // (This can be tuned. Keeps campaign moving.)
      const unlockIf = (state.t >= 20) || (state.score >= 900);
      if(unlockIf){
        save.campaign.unlockedLevel = Math.max(save.campaign.unlockedLevel, Math.min(8, state.level + 1));
      }
      saveSave(save);

      addLeaderboardScore("campaign", state.score, { level: state.level });
      renderCampaignMenu();
    } else {
      addLeaderboardScore("endless", state.score, { });
    }
  }

  // =========================
  // Main Loop
  // =========================
  let last = performance.now();

  function tick(now){
    requestAnimationFrame(tick);

    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if(state.screen !== "game"){
      // Idle draw background
      draw(dt);
      return;
    }

    // Update UI stats even while paused (time frozen)
    statScore.textContent = Math.floor(state.score).toLocaleString();
    statTime.textContent = state.t.toFixed(1);
    statSpeed.textContent = state.baseSpeed.toFixed(2);

    if(!state.running){
      draw(dt);
      return;
    }

    if(state.paused){
      draw(dt);
      return;
    }

    // ===== update =====
    state.t += dt;

    // Effects schedule and difficulty
    updateEffects();

    // Score
    state.score += scorePerSecond() * dt;

    // Player move towards input
    const targetX = dragging ? inputX : state.player.x;
    state.player.x += (targetX - state.player.x) * (1 - Math.pow(0.0005, dt)); // smooth
    state.player.x = clamp(state.player.x, 0.07, 0.93);

    if(state.player.inv > 0) state.player.inv = Math.max(0, state.player.inv - dt);

    // Spawning hazards
    // blocks
    const baseSpawn = 0.55; // seconds
    const spawnInterval = clamp(baseSpawn / state.hazardRate, 0.20, 0.55);
    state.spawnAcc += dt;
    while(state.spawnAcc >= spawnInterval){
      state.spawnAcc -= spawnInterval;
      state.hazards.push(makeBlock());
    }

    // vertical lasers (if active)
    if(state.effects.lasers){
      const baseLaser = 1.45;
      const laserInterval = clamp(baseLaser / (0.7 + state.hazardRate*0.25), 0.65, 1.45);
      state.laserAcc += dt;
      if(state.laserAcc >= laserInterval){
        state.laserAcc = 0;
        state.hazards.push(makeLaserVertical());
      }
    }

    // glitch jitter pulses (visual)
    if(state.effects.glitch){
      state.glitchAcc += dt;
      if(state.glitchAcc >= 0.18){
        state.glitchAcc = 0;
        state.effects.shake = Math.max(state.effects.shake, rand(2, 7));
      }
    }

    // Update hazards
    for(let i = state.hazards.length - 1; i >= 0; i--){
      const h = state.hazards[i];

      if(h.kind === "block"){
        h.y += h.vy * dt * state.baseSpeed;
        h.x += h.vx * dt * (0.6 + state.baseSpeed*0.25);
        // bounce
        if(h.x < 0.02 || h.x + h.w > 0.98) h.vx *= -1;

        // offscreen
        if(h.y > 1.15){
          state.hazards.splice(i,1);
          continue;
        }
      } else if(h.kind === "vlaser"){
        h.t += dt * state.baseSpeed;

        if(h.phase === "warn" && h.t >= h.warnTime){
          h.phase = "fire";
          h.t = 0;
          state.effects.shake = Math.max(state.effects.shake, 10);
        } else if(h.phase === "fire" && h.t >= h.fireTime){
          h.phase = "fade";
          h.t = 0;
        } else if(h.phase === "fade" && h.t >= h.fadeTime){
          state.hazards.splice(i,1);
          continue;
        }
      }
    }

    // Collisions
    const px = state.player.x, py = state.player.y, pr = state.player.r;
    const pRect = {
      x: px - pr/720, // normalize to canvas-ish units later in draw; for collision we keep normalized
      y: py - pr/1280,
      w: (pr*2)/720,
      h: (pr*2)/1280
    };

    // collision test with normalized rects
    for(const h of state.hazards){
      if(h.kind === "block"){
        const r = { x: h.x, y: h.y, w: h.w, h: h.h };
        if(rectOverlap(pRect, r) && state.player.inv <= 0){
          // no "deaths mode" etc; end run
          spawnBurst(state.player.x, state.player.y);
          endRun();
          break;
        }
      } else if(h.kind === "vlaser"){
        if(h.phase === "fire"){
          const r = { x: h.x, y: 0, w: h.w, h: 1 };
          if(rectOverlap(pRect, r) && state.player.inv <= 0){
            spawnBurst(state.player.x, state.player.y);
            endRun();
            break;
          }
        }
      }
    }

    // Particles
    for(let i = state.particles.length - 1; i >= 0; i--){
      const p = state.particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 0.35 * dt;
      if(p.t > p.life) state.particles.splice(i,1);
    }

    // Shake decay
    state.effects.shake *= Math.pow(0.02, dt); // quick decay

    // Campaign run length cap per level? (optional)
    // We'll keep it open; you can always replay.

    // Draw
    draw(dt);
  }

  function rectOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnBurst(x,y){
    for(let i=0;i<26;i++){
      state.particles.push({
        x,y,
        vx: rand(-0.6,0.6),
        vy: rand(-0.9,0.2),
        t:0,
        life: rand(0.35, 0.9)
      });
    }
  }

  // =========================
  // Draw
  // =========================
  function draw(dt){
    const W = canvas.width, H = canvas.height;

    // camera shake
    const shake = Math.min(18, state.effects.shake);
    const sx = (Math.random()*2-1) * shake;
    const sy = (Math.random()*2-1) * shake;

    ctx.save();
    ctx.clearRect(0,0,W,H);

    // base background
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0,0,W,H);

    ctx.translate(sx, sy);

    // vignette + gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(20,22,50,0.95)");
    g.addColorStop(1, "rgba(0,0,0,0.95)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // grid lines
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    const grid = 54;
    for(let y=0;y<=H;y+=grid){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(W,y);
      ctx.stroke();
    }
    for(let x=0;x<=W;x+=grid){
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,H);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // center lane glow
    ctx.globalAlpha = 0.20;
    const gg = ctx.createRadialGradient(W/2,H*0.65, 10, W/2,H*0.65, H*0.7);
    gg.addColorStop(0, "rgba(110,231,255,0.40)");
    gg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gg;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // hazards
    for(const h of state.hazards){
      if(h.kind === "block"){
        const x = h.x * W, y = h.y * H, w = h.w * W, hh = h.h * H;
        ctx.save();
        ctx.shadowColor = "rgba(255,110,231,0.35)";
        ctx.shadowBlur = 16;
        ctx.fillStyle = "rgba(255,110,231,0.85)";
        ctx.fillRect(x, y, w, hh);
        ctx.restore();

        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x+1, y+1, w-2, hh-2);
      } else if(h.kind === "vlaser"){
        const x = h.x * W, w = h.w * W;
        if(h.phase === "warn"){
          // warning stripes
          ctx.save();
          ctx.globalAlpha = 0.55;
          ctx.fillStyle = "rgba(110,231,255,0.15)";
          ctx.fillRect(x, 0, w, H);
          ctx.globalAlpha = 0.9;
          ctx.strokeStyle = "rgba(110,231,255,0.85)";
          ctx.setLineDash([12, 10]);
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x + w/2, 0);
          ctx.lineTo(x + w/2, H);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        } else if(h.phase === "fire"){
          ctx.save();
          ctx.shadowColor = "rgba(110,231,255,0.55)";
          ctx.shadowBlur = 28;
          ctx.fillStyle = "rgba(110,231,255,0.85)";
          ctx.fillRect(x, 0, w, H);
          ctx.restore();
        } else {
          const alpha = 1 - (h.t / h.fadeTime);
          ctx.save();
          ctx.globalAlpha = alpha * 0.8;
          ctx.fillStyle = "rgba(110,231,255,0.70)";
          ctx.fillRect(x, 0, w, H);
          ctx.restore();
        }
      }
    }

    // player
    const px = state.player.x * W;
    const py = state.player.y * H;
    const r = state.player.r;

    ctx.save();
    ctx.shadowColor = "rgba(183,255,110,0.45)";
    ctx.shadowBlur = 26;

    // glitch jitter rendering
    const jitter = (state.effects.glitch && state.screen === "game" && state.running && !state.paused) ? rand(-3,3) : 0;
    ctx.translate(jitter, 0);

    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(183,255,110,0.92)";
    ctx.fill();

    // inner core
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(px, py, r*0.45, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fill();

    ctx.restore();

    // particles
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillRect(p.x * W, p.y * H, 4, 4);
    }
    ctx.globalAlpha = 1;

    // scanlines effect
    if(state.effects.scanlines){
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      for(let y=0; y<H; y+=8){
        ctx.fillRect(0, y, W, 1);
      }
      ctx.restore();
    }

    // invert-ish overlay
    if(state.effects.invert){
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "rgba(255,110,231,0.35)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    // HUD hint minimal (kept clean)
    // (no bottom device instructions)

    ctx.restore();
  }

  // =========================
  // Initialize
  // =========================
  function init(){
    showMenu(menuMain);
    renderCampaignMenu();
    renderLeaderboards("campaign");
    goToMenu();
    requestAnimationFrame(tick);
  }

  init();

})();
</script>
</body>
</html>
