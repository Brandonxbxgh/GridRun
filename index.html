<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TXC GRIDRUN</title>
  <style>
    :root{
      --bg:#0b0f25;
      --panel:#141a38;
      --panel2:#0f1430;
      --line:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#6ee7ff;
      --good:#b7ff6e;
      --bad:#ff6ee7;
    }
    *{box-sizing:border-box;}
    html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--text);}
    button{font:inherit; color:inherit; -webkit-tap-highlight-color:transparent;}
    .wrap{min-height:100%; display:flex; align-items:center; justify-content:center; padding:14px;}
    .app{width:min(720px,100%); border:1px solid var(--line); background:rgba(0,0,0,.20); border-radius:14px; overflow:hidden;}
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px; border-bottom:1px solid var(--line);
      background:rgba(0,0,0,.25);
    }
    .brand{display:flex; align-items:center; gap:10px;}
    .logo{
      width:28px; height:28px; border-radius:10px;
      background:conic-gradient(from 110deg, var(--accent), var(--bad), var(--good), var(--accent));
      border:1px solid rgba(255,255,255,.18);
    }
    .title{font-weight:900; letter-spacing:.12em; text-transform:uppercase;}
    .subtitle{font-size:12px; color:var(--muted); margin-top:2px;}
    .hud{display:flex; flex-wrap:wrap; gap:8px; justify-content:flex-end; font-size:12px; color:rgba(255,255,255,.85);}
    .pill{padding:5px 8px; border:1px solid rgba(255,255,255,.12); border-radius:999px; background:rgba(255,255,255,.06); white-space:nowrap;}
    .pill b{color:var(--text);}

    .content{padding:14px;}
    .screen{display:none;}
    .screen.active{display:block;}

    .panel{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      border-radius:12px;
      padding:12px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap;}
    .row > *{flex:1 1 180px;}
    .btn{
      width:100%;
      padding:12px 10px;
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      cursor:pointer;
      display:flex; align-items:center; justify-content:space-between;
      touch-action:manipulation;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}
    .hint{font-size:12px; color:var(--muted);}
    .divider{height:10px;}
    .note{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.35;
    }

    .gameWrap{display:flex; flex-direction:column; align-items:center; gap:10px;}
    canvas{
      width:100%;
      max-width:560px;
      aspect-ratio: 9/16;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      background:#050612;
      touch-action:none; /* critical for mobile drag */
    }
    .controls{
      width:100%;
      display:flex; gap:10px; flex-wrap:wrap; justify-content:center;
    }
    .mini{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      cursor:pointer;
      touch-action:manipulation;
      user-select:none;
    }
    .mini:active{transform:translateY(1px);}

    /* Simple overlay modal */
    .overlay{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      padding:16px;
      background:rgba(0,0,0,.55);
      z-index:100;
    }
    .overlay.show{display:flex;}
    .modal{
      width:min(520px,100%);
      background:#0b0f25;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:14px;
    }
    .modal h3{margin:0 0 8px; font-size:14px; letter-spacing:.08em; text-transform:uppercase;}
    .modal p{margin:0 0 10px; color:rgba(255,255,255,.78); font-size:13px; line-height:1.35;}
  </style>
</head>

<body>
<div class="wrap">
  <div class="app">
    <div class="top">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="title">GRIDRUN</div>
          <!-- restored text under GRIDRUN (old style) -->
          <div class="subtitle">Dodge • Survive • Score</div>
        </div>
      </div>

      <div class="hud">
        <div class="pill">Mode: <b id="statMode">Menu</b></div>
        <div class="pill">Score: <b id="statScore">0</b></div>
        <div class="pill">Time: <b id="statTime">0.0</b>s</div>
      </div>
    </div>

    <div class="content">
      <!-- MAIN -->
      <div class="screen active" id="screenMain">
        <div class="panel">
          <div class="row">
            <button class="btn" id="goCampaign"><span><b>Campaign</b></span><span class="hint">worlds & levels</span></button>
            <button class="btn" id="goEndless"><span><b>Endless</b></span><span class="hint">infinite run</span></button>
          </div>
          <div class="divider"></div>
          <div class="row">
            <button class="btn" id="goLB"><span><b>Leaderboards</b></span><span class="hint">local</span></button>
            <button class="btn" id="resetSave"><span><b>Reset Save</b></span><span class="hint">local only</span></button>
          </div>

          <!-- restored bottom instructions (old style) -->
          <div class="note">
            <b>PC:</b> WASD / Arrow Keys • <b>Mobile:</b> drag anywhere to move • Tap <b>Pause</b> to stop.
          </div>
        </div>
      </div>

      <!-- CAMPAIGN -->
      <div class="screen" id="screenCampaign">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Campaign</b> <span style="color:var(--muted); font-size:12px;" id="campProgress"></span></div>
            <button class="mini" id="backFromCampaign">Back</button>
          </div>
          <div class="divider"></div>
          <div id="campaignList"></div>
          <div class="note">Replay any beaten level. Progress unlocks forward.</div>
        </div>
      </div>

      <!-- ENDLESS -->
      <div class="screen" id="screenEndless">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Endless</b> <span style="color:var(--muted); font-size:12px;">Starts at W1-L1 difficulty</span></div>
            <button class="mini" id="backFromEndless">Back</button>
          </div>
          <div class="divider"></div>
          <button class="btn" id="startEndless"><span><b>Start</b></span><span class="hint">go</span></button>
          <div class="note">Same scoring as Campaign, tracked separately.</div>
        </div>
      </div>

      <!-- LEADERBOARDS -->
      <div class="screen" id="screenLB">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Leaderboards</b> <span style="color:var(--muted); font-size:12px;">Local only</span></div>
            <button class="mini" id="backFromLB">Back</button>
          </div>
          <div class="divider"></div>
          <div class="row">
            <button class="btn" id="lbCamp"><span><b>Campaign</b></span><span class="hint">top</span></button>
            <button class="btn" id="lbEnd"><span><b>Endless</b></span><span class="hint">top</span></button>
          </div>
          <div class="divider"></div>
          <div id="lbList" class="note" style="margin-top:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono'; white-space:pre; overflow:auto; max-height:320px;"></div>
          <div class="divider"></div>
          <button class="btn" id="clearLB"><span><b>Clear Leaderboards</b></span><span class="hint">local</span></button>
        </div>
      </div>

      <!-- GAME -->
      <div class="screen" id="screenGame">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b id="runLabel">Run</b></div>
            <div style="color:var(--muted); font-size:12px;" id="runHint">Drag (mobile) / WASD (PC)</div>
          </div>
          <div class="divider"></div>

          <div class="gameWrap">
            <canvas id="game" width="720" height="1280"></canvas>
            <div class="controls">
              <button class="mini" id="pauseBtn">Pause</button>
              <button class="mini" id="restartBtn">Restart</button>
              <button class="mini" id="menuBtn">Menu</button>
            </div>
          </div>

          <!-- restored bottom instructions -->
          <div class="note">
            <b>PC:</b> WASD / Arrows • <b>Mobile:</b> drag anywhere (2D) • Avoid blocks + lasers.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="overlay" id="overlay">
  <div class="modal">
    <h3 id="modalTitle">Paused</h3>
    <p id="modalText">Game paused.</p>
    <div class="row">
      <button class="btn" id="resumeBtn"><span><b>Resume</b></span><span class="hint"></span></button>
      <button class="btn" id="modalRestartBtn"><span><b>Restart</b></span><span class="hint"></span></button>
      <button class="btn" id="toMenuBtn"><span><b>Main Menu</b></span><span class="hint"></span></button>
    </div>
  </div>
</div>

<script>
(() => {
  // =========================
  // Minimal, stable baseline
  // =========================

  const KEY_SAVE = "gridrun_save_stable_v1";
  const KEY_LB_C = "gridrun_lb_campaign_stable_v1";
  const KEY_LB_E = "gridrun_lb_endless_stable_v1";

  // Restore worlds/levels structure
  const WORLDS = [
    { id: 1, name: "World 1", levels: 5 },
    { id: 2, name: "World 2", levels: 5 },
    { id: 3, name: "World 3", levels: 5 },
    { id: 4, name: "World 4", levels: 5 },
  ];
  const totalLevels = WORLDS.reduce((a,w)=>a+w.levels,0);

  const $ = (id) => document.getElementById(id);

  const screens = {
    main: $("screenMain"),
    campaign: $("screenCampaign"),
    endless: $("screenEndless"),
    lb: $("screenLB"),
    game: $("screenGame"),
  };

  function showScreen(name){
    Object.values(screens).forEach(s => s.classList.remove("active"));
    screens[name].classList.add("active");
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function clampInt(v,a,b){ v = (v|0); return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function loadJSON(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return fallback;
      const o = JSON.parse(raw);
      return o ?? fallback;
    }catch(_){ return fallback; }
  }
  function saveJSON(key, val){
    localStorage.setItem(key, JSON.stringify(val));
  }

  const defaultSave = () => ({
    unlocked: 1,      // linear unlock 1..totalLevels
    best: {}          // index -> best
  });

  let save = loadJSON(KEY_SAVE, defaultSave());
  save.unlocked = clampInt(save.unlocked, 1, totalLevels);

  function linearToWorldLevel(index){
    let acc = 0;
    for(const w of WORLDS){
      if(index <= acc + w.levels){
        return { world:w.id, worldName:w.name, level:index-acc, index };
      }
      acc += w.levels;
    }
    return { world:1, worldName:"World 1", level:1, index:1 };
  }

  // -------------------------
  // Leaderboards (local)
  // -------------------------
  function loadLB(mode){
    return loadJSON(mode === "campaign" ? KEY_LB_C : KEY_LB_E, []);
  }
  function saveLB(mode, arr){
    saveJSON(mode === "campaign" ? KEY_LB_C : KEY_LB_E, arr);
  }
  function addLB(mode, score, meta){
    const list = loadLB(mode);
    list.push({ name:"Runner", score:Math.floor(score), ts:Date.now(), meta: meta||{} });
    list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
    saveLB(mode, list.slice(0,10));
  }

  function renderLB(mode){
    const list = loadLB(mode);
    const lines = [];
    lines.push(mode.toUpperCase() + " TOP 10");
    lines.push("--------------------");
    if(!list.length){
      lines.push("No scores yet.");
    }else{
      list.slice(0,10).forEach((e,i)=>{
        lines.push(`${String(i+1).padStart(2," ")}. ${String(e.name).padEnd(8," ")}  ${String(e.score).padStart(8," ")}`);
      });
    }
    $("lbList").textContent = lines.join("\n");
  }

  // -------------------------
  // Campaign menu render
  // -------------------------
  function renderCampaign(){
    $("campProgress").textContent = `Unlocked ${save.unlocked}/${totalLevels}`;

    const root = $("campaignList");
    root.innerHTML = "";

    let idx = 0;
    for(const w of WORLDS){
      const box = document.createElement("div");
      box.className = "note";
      box.style.marginTop = "10px";
      box.style.whiteSpace = "normal";
      box.innerHTML = `<b>${w.name}</b><div style="height:8px"></div>`;
      for(let l=1;l<=w.levels;l++){
        idx++;
        const locked = idx > save.unlocked;
        const best = save.best[String(idx)] || 0;

        const btn = document.createElement("button");
        btn.className = "btn";
        btn.disabled = locked;
        btn.innerHTML = `<span><b>Level ${l}</b> <span class="hint">best ${best}</span></span><span class="hint">${locked?"locked":"start"}</span>`;
        btn.addEventListener("click", ()=> startCampaign(idx), {passive:true});
        box.appendChild(btn);
        box.appendChild(document.createElement("div")).style.height = "8px";
      }
      root.appendChild(box);
    }
  }

  // =========================
  // GAME
  // =========================
  const canvas = $("game");
  const ctx = canvas.getContext("2d", { alpha:true });

  const state = {
    screen: "menu",
    mode: "endless",   // campaign|endless
    levelIndex: 1,

    running: false,
    paused: false,

    t: 0,
    score: 0,

    player: { x:0.5, y:0.8, r:18 },

    hazards: [],
    spawnAcc: 0,

    // very simple difficulty (stable)
    speed: 1.0,
  };

  // Direct-follow (2D) target for mobile drag
  let dragging = false;
  const target = { x:0.5, y:0.8 };

  // Keyboard (PC) move
  const keys = new Set();
  window.addEventListener("keydown", (e)=>{ keys.add(e.key.toLowerCase()); });
  window.addEventListener("keyup", (e)=>{ keys.delete(e.key.toLowerCase()); });

  function getPointerNorm(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    const y = (e.clientY - r.top) / r.height;
    return {
      x: clamp(x, 0.06, 0.94),
      y: clamp(y, 0.10, 0.92),
    };
  }

  canvas.addEventListener("pointerdown", (e)=>{
    dragging = true;
    const p = getPointerNorm(e);
    target.x = p.x; target.y = p.y;
    canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointermove", (e)=>{
    if(!dragging) return;
    const p = getPointerNorm(e);
    target.x = p.x; target.y = p.y;
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointerup", (e)=>{
    dragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
  }, {passive:false});

  function bindTap(id, fn){
    const el = $(id);
    el.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); fn(); }, {passive:false});
    el.addEventListener("click",(e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  }

  const overlay = $("overlay");
  function setPaused(p){
    state.paused = p;
    overlay.classList.toggle("show", p);
    $("pauseBtn").textContent = p ? "Resume" : "Pause";
    $("modalTitle").textContent = p ? "Paused" : "Paused";
    $("modalText").textContent = `Score: ${Math.floor(state.score)} • Time: ${state.t.toFixed(1)}s`;
  }
  function togglePause(){
    if(!state.running) return;
    setPaused(!state.paused);
  }

  // Auto-pause when app loses focus (mobile stability)
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden && state.running && !state.paused) setPaused(true);
  }, {passive:true});
  window.addEventListener("blur", ()=>{
    if(state.running && !state.paused) setPaused(true);
  }, {passive:true});

  function startEndless(){
    state.mode = "endless";
    state.levelIndex = 1;
    startRun();
  }
  function startCampaign(levelIndex){
    state.mode = "campaign";
    state.levelIndex = levelIndex;
    startRun();
  }

  function startRun(){
    state.screen = "game";
    showScreen("game");

    state.running = true;
    state.paused = false;

    state.t = 0;
    state.score = 0;
    state.speed = 1.0; // stable baseline

    state.player.x = 0.5;
    state.player.y = 0.8;
    target.x = state.player.x;
    target.y = state.player.y;

    state.hazards.length = 0;
    state.spawnAcc = 0;

    $("statMode").textContent = state.mode === "campaign" ? "Campaign" : "Endless";
    $("runLabel").textContent = state.mode === "campaign"
      ? `Campaign • ${linearToWorldLevel(state.levelIndex).worldName} • L${linearToWorldLevel(state.levelIndex).level}`
      : "Endless";
    setPaused(false);
  }

  function goMenu(){
    state.running = false;
    state.paused = false;
    overlay.classList.remove("show");
    $("statMode").textContent = "Menu";
    $("statScore").textContent = "0";
    $("statTime").textContent = "0.0";
    showScreen("main");
  }

  function endRun(){
    state.running = false;
    setPaused(true);

    // Save + unlock + LB
    if(state.mode === "campaign"){
      const idx = String(state.levelIndex);
      const prev = save.best[idx] || 0;
      if(state.score > prev) save.best[idx] = Math.floor(state.score);

      // simple unlock rule: survive 15s
      if(state.t >= 15) save.unlocked = clampInt(Math.max(save.unlocked, state.levelIndex + 1), 1, totalLevels);

      saveJSON(KEY_SAVE, save);
      addLB("campaign", state.score, { levelIndex: state.levelIndex });
    }else{
      addLB("endless", state.score, {});
    }
  }

  // Hazards (simple descending blocks only — stability first)
  function spawnBlock(){
    const w = rand(0.08, 0.16);
    return { x: rand(0.04, 0.96-w), y: -0.15, w, h: rand(0.05, 0.09), vy: rand(0.55, 0.85) };
  }

  function rectOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  let last = performance.now();
  function tick(now){
    requestAnimationFrame(tick);
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    $("statScore").textContent = String(Math.floor(state.score));
    $("statTime").textContent = state.t.toFixed(1);

    if(!state.running || state.paused){
      draw();
      return;
    }

    state.t += dt;
    state.score += 25 * dt;

    // PC movement
    const sp = 0.85 * dt;
    if(keys.has("w") || keys.has("arrowup")) state.player.y -= sp;
    if(keys.has("s") || keys.has("arrowdown")) state.player.y += sp;
    if(keys.has("a") || keys.has("arrowleft")) state.player.x -= sp;
    if(keys.has("d") || keys.has("arrowright")) state.player.x += sp;

    // Mobile direct follow overrides smoothly when dragging
    if(dragging){
      const follow = 1 - Math.pow(0.000001, dt);
      state.player.x += (target.x - state.player.x) * follow;
      state.player.y += (target.y - state.player.y) * follow;
    }

    state.player.x = clamp(state.player.x, 0.06, 0.94);
    state.player.y = clamp(state.player.y, 0.10, 0.92);

    // Spawn cadence
    state.spawnAcc += dt;
    const interval = clamp(0.55 / state.speed, 0.22, 0.55);
    while(state.spawnAcc >= interval){
      state.spawnAcc -= interval;
      state.hazards.push(spawnBlock());
    }

    // Update hazards
    for(let i=state.hazards.length-1;i>=0;i--){
      const h = state.hazards[i];
      h.y += h.vy * dt * state.speed;
      if(h.y > 1.2) state.hazards.splice(i,1);
    }

    // Collisions
    const pr = state.player.r;
    const pRect = { x: state.player.x - pr/720, y: state.player.y - pr/1280, w:(pr*2)/720, h:(pr*2)/1280 };
    for(const h of state.hazards){
      const r = { x:h.x, y:h.y, w:h.w, h:h.h };
      if(rectOverlap(pRect, r)){
        endRun();
        break;
      }
    }

    draw();
  }

  function draw(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // Background
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(14,18,55,1)");
    g.addColorStop(1, "rgba(3,4,14,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // Grid (simple)
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = "rgba(255,255,255,.7)";
    ctx.lineWidth = 1;
    for(let y=0;y<=H;y+=60){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    for(let x=0;x<=W;x+=60){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // Hazards
    for(const h of state.hazards){
      ctx.fillStyle = "rgba(255,110,231,0.85)";
      ctx.fillRect(h.x*W, h.y*H, h.w*W, h.h*H);
    }

    // Player
    const px = state.player.x * W;
    const py = state.player.y * H;
    const r = state.player.r;
    ctx.shadowColor = "rgba(183,255,110,0.45)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(183,255,110,0.92)";
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(px, py, r*0.45, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fill();
  }

  // -------------------------
  // UI bindings
  // -------------------------
  $("goCampaign").addEventListener("click", ()=>{ renderCampaign(); showScreen("campaign"); }, {passive:true});
  $("goEndless").addEventListener("click", ()=> showScreen("endless"), {passive:true});
  $("goLB").addEventListener("click", ()=>{ renderLB("campaign"); showScreen("lb"); }, {passive:true});

  $("backFromCampaign").addEventListener("click", ()=> showScreen("main"), {passive:true});
  $("backFromEndless").addEventListener("click", ()=> showScreen("main"), {passive:true});
  $("backFromLB").addEventListener("click", ()=> showScreen("main"), {passive:true});

  $("startEndless").addEventListener("click", ()=> startEndless(), {passive:true});
  $("lbCamp").addEventListener("click", ()=> renderLB("campaign"), {passive:true});
  $("lbEnd").addEventListener("click", ()=> renderLB("endless"), {passive:true});

  $("clearLB").addEventListener("click", ()=>{
    if(confirm("Clear local leaderboards?")){
      saveLB("campaign", []);
      saveLB("endless", []);
      renderLB("campaign");
    }
  }, {passive:true});

  $("resetSave").addEventListener("click", ()=>{
    if(confirm("Reset local save + best scores?")){
      save = defaultSave();
      saveJSON(KEY_SAVE, save);
      alert("Save reset.");
    }
  }, {passive:true});

  $("btnCampaign")?.addEventListener?.("click", ()=>{}, {passive:true});

  $("btnExit")?.addEventListener?.("click", ()=> window.close(), {passive:true});

  // game buttons (robust tap)
  bindTap("pauseBtn", ()=> togglePause());
  bindTap("restartBtn", ()=> startRun());
  bindTap("menuBtn", ()=> goMenu());

  bindTap("resumeBtn", ()=> setPaused(false));
  bindTap("modalRestartBtn", ()=> startRun());
  bindTap("toMenuBtn", ()=> goMenu());

  // Init
  showScreen("main");
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
