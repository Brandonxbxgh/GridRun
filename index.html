<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN</title>
  <style>
    html, body { margin:0; padding:0; background:#0a0a12; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
    .hint{
      position:fixed; left:12px; bottom:10px;
      font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:rgba(255,255,255,.75);
      background:rgba(0,0,0,0.35);
      padding:8px 10px; border-radius:10px;
      user-select:none; z-index:10;
    }
  </style>
</head>
<body>
  <div class="hint">PC: WASD/Arrows • Mobile: DIRECT FOLLOW (drag) • Campaign + Endless • Separate Leaderboards • Same scoring rules</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    window.addEventListener("load", () => {
      const wait = setInterval(() => {
        if (typeof window.Phaser === "undefined") return;
        clearInterval(wait);

        const W = 420, H = 760;
        const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

        // ===== GRID =====
        const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
        const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
        const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

        // ===== Movement =====
        const PLAYER_SPEED = 320;

        // ✅ Mobile DIRECT FOLLOW only (tunable in Settings)
        const FOLLOW_RADIUS = 7;
        const DEFAULT_FOLLOW_LERP = 0.38;
        const DEFAULT_FOLLOW_MAX_MULT = 2.8;

        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const lerp = (a,b,t) => a + (b-a)*t;
        const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

        // ===== Storage =====
        const SAVE_KEY = "gridrun_progress_v5";
        const SETTINGS_KEY = "gridrun_settings_v1";
        const LEADER_KEY = "gridrun_leaderboards_v1";

        const LEVELS_PER_WORLD = 5;
        const WORLDS_COUNT = 3;
        const TOTAL_LEVELS = WORLDS_COUNT * LEVELS_PER_WORLD;

        // ===== Settings =====
        function loadSettings() {
          try {
            const raw = localStorage.getItem(SETTINGS_KEY);
            if (!raw) return {
              shake: true,
              sfx: false,
              followLerp: DEFAULT_FOLLOW_LERP,
              followMaxMult: DEFAULT_FOLLOW_MAX_MULT
            };
            const s = JSON.parse(raw);
            return {
              shake: s.shake !== false,
              sfx: s.sfx === true,
              followLerp: Number.isFinite(s.followLerp) ? clamp(s.followLerp, 0.18, 0.70) : DEFAULT_FOLLOW_LERP,
              followMaxMult: Number.isFinite(s.followMaxMult) ? clamp(s.followMaxMult, 1.6, 4.0) : DEFAULT_FOLLOW_MAX_MULT
            };
          } catch {
            return { shake:true, sfx:false, followLerp: DEFAULT_FOLLOW_LERP, followMaxMult: DEFAULT_FOLLOW_MAX_MULT };
          }
        }
        function saveSettings(s) { localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }

        // ===== Progress =====
        function loadProgress() {
          try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) {
              return {
                unlockedWorld: 0,
                unlockedLevel: 0,
                currentWorld: 0,
                currentLevel: 0,
                // per-level best score (campaign)
                levelBest: Array(TOTAL_LEVELS).fill(0)
              };
            }
            const p = JSON.parse(raw);
            const levelBest = Array.isArray(p.levelBest) ? p.levelBest.map(x => Math.max(0, Math.floor(x||0))) : Array(TOTAL_LEVELS).fill(0);
            while (levelBest.length < TOTAL_LEVELS) levelBest.push(0);
            return {
              unlockedWorld: Number.isFinite(p.unlockedWorld) ? clamp(p.unlockedWorld, 0, WORLDS_COUNT-1) : 0,
              unlockedLevel: Number.isFinite(p.unlockedLevel) ? clamp(p.unlockedLevel, 0, LEVELS_PER_WORLD-1) : 0,
              currentWorld: Number.isFinite(p.currentWorld) ? clamp(p.currentWorld, 0, WORLDS_COUNT-1) : 0,
              currentLevel: Number.isFinite(p.currentLevel) ? clamp(p.currentLevel, 0, LEVELS_PER_WORLD-1) : 0,
              levelBest
            };
          } catch {
            return { unlockedWorld:0, unlockedLevel:0, currentWorld:0, currentLevel:0, levelBest: Array(TOTAL_LEVELS).fill(0) };
          }
        }
        function saveProgress(p) { localStorage.setItem(SAVE_KEY, JSON.stringify(p)); }
        function resetAllSaves() {
          localStorage.removeItem(SAVE_KEY);
          localStorage.removeItem(LEADER_KEY);
        }

        function levelId(world, level) { return world * LEVELS_PER_WORLD + level; }
        function campaignTotalScore(p) { return p.levelBest.reduce((a,b)=>a+b, 0); }
        function worldSubtotal(p, world) {
          const start = world * LEVELS_PER_WORLD;
          let sum = 0;
          for (let i=0;i<LEVELS_PER_WORLD;i++) sum += (p.levelBest[start+i]||0);
          return sum;
        }
        function isLevelUnlocked(p, world, level) {
          if (world < p.unlockedWorld) return true;
          if (world > p.unlockedWorld) return false;
          return level <= p.unlockedLevel;
        }

        // ===== Leaderboards (local) =====
        // Separate: Campaign Total and Endless Best Run
        function loadLeaderboards() {
          try {
            const raw = localStorage.getItem(LEADER_KEY);
            if (!raw) return { campaignTop: [], endlessTop: [] };
            const lb = JSON.parse(raw);
            const normalize = (arr) => (Array.isArray(arr) ? arr : [])
              .map(x => ({ score: Math.max(0, Math.floor(x?.score||0)), meta: x?.meta || "" }))
              .sort((a,b)=>b.score-a.score)
              .slice(0,10);
            return { campaignTop: normalize(lb.campaignTop), endlessTop: normalize(lb.endlessTop) };
          } catch {
            return { campaignTop: [], endlessTop: [] };
          }
        }
        function saveLeaderboards(lb) { localStorage.setItem(LEADER_KEY, JSON.stringify(lb)); }
        function maybeInsertTop(list, entry) {
          const next = [...list, entry].sort((a,b)=>b.score-a.score).slice(0,10);
          return next;
        }

        // ===== UI helpers =====
        function addTitle(scene, text, yFrac = 0.22, size = 40) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: `${size}px`, color: "#ffffff",
          }).setOrigin(0.5).setAlpha(0.96);
        }
        function addSubtitle(scene, text, yFrac = 0.28) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff",
          }).setOrigin(0.5).setAlpha(0.9);
        }
        function makeButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "18px",
            color: "#0a0a12",
            backgroundColor: "#6ef3ff",
            padding: { left: 18, right: 18, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.92));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }
        function makeGhostButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "16px",
            color: "#ffffff",
            backgroundColor: "rgba(255,255,255,0.10)",
            padding: { left: 16, right: 16, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.85));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }

        // ===== Level times =====
        const DUR = [20, 25, 30, 38, 45];

        // Difficulty builder
        function mkLevels(cfg) {
          return DUR.map((seconds, i) => ({
            seconds,
            baseScroll: cfg.baseScroll0 + cfg.baseScrollStep * i,
            scrollRamp: cfg.ramp0 + cfg.rampStep * i,

            spawnStart: cfg.spawnStart0 - cfg.spawnStep * i,
            spawnRamp: cfg.spawnRamp0 + cfg.spawnRampStep * i,
            spawnMin: Math.max(cfg.spawnMinFloor, cfg.spawnMin0 - cfg.spawnMinStep * i),

            size: [cfg.sizeMin0 - cfg.sizeMinStep*i, cfg.sizeMax0 - cfg.sizeMaxStep*i]
          }));
        }

        // ===== Worlds =====
        const WORLDS = [
          {
            id: 0,
            name: "Cyber Circuit",
            subtitle: "Neon lanes. Clean reads. Warm up.",
            bg: 0x070812,
            border: 0x2a2a55,
            gridLine: 0x20204a,
            player: 0x6ef3ff,
            fx: "scanlines",
            gridStyle: "circuit",
            obstacleStyle: { palette: [0xff4d7d, 0xff6aa2, 0xff7bd0], shapes: ["tri","hex","frame","rect"] },
            levels: mkLevels({
              baseScroll0: 80, baseScrollStep: 18,
              ramp0: 8.0, rampStep: 3.0,
              spawnStart0: 1020, spawnStep: 105,
              spawnRamp0: 10, spawnRampStep: 3,
              spawnMin0: 520, spawnMinStep: 55,
              spawnMinFloor: 300,
              sizeMin0: 22, sizeMinStep: 1,
              sizeMax0: 34, sizeMaxStep: 1
            })
          },
          {
            id: 1,
            name: "Industrial Overclock",
            subtitle: "Heavy plating. Hazard stripes. Faster drops.",
            bg: 0x050611,
            border: 0x3a4a88,
            gridLine: 0x243056,
            player: 0x7cffd2,
            fx: "rain",
            gridStyle: "industrial",
            obstacleStyle: { palette: [0xffd166, 0xff4d7d, 0x7cffd2], shapes: ["bar","plus","rect","frame"] },
            levels: mkLevels({
              baseScroll0: 92, baseScrollStep: 20,
              ramp0: 9.0, rampStep: 3.3,
              spawnStart0: 980, spawnStep: 115,
              spawnRamp0: 11, spawnRampStep: 3.4,
              spawnMin0: 500, spawnMinStep: 60,
              spawnMinFloor: 285,
              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            })
          },
          {
            id: 2,
            name: "Blackout Glitch",
            subtitle: "Broken grid. Flicker. Laser sweeps.",
            bg: 0x02030a,
            border: 0x4b4bb0,
            gridLine: 0x1e1f3f,
            player: 0x9aa7ff,
            fx: "stars",
            gridStyle: "glitch",
            obstacleStyle: { palette: [0xff4d7d, 0xffb0ff, 0x9aa7ff], shapes: ["hex","tri","bar","frame"] },
            levels: mkLevels({
              baseScroll0: 98, baseScrollStep: 22,
              ramp0: 9.6, rampStep: 3.6,
              spawnStart0: 940, spawnStep: 120,
              spawnRamp0: 12, spawnRampStep: 3.6,
              spawnMin0: 480, spawnMinStep: 62,
              spawnMinFloor: 270,
              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            }),
            boss: {
              enabled: true,
              cycleSeconds: 5.7,
              warnSeconds: 1.20,
              activeSeconds: 1.12,
              thickness: 16,
              warnThickness: 6
            }
          }
        ];

        // ===== Background FX =====
        function buildBackdrop(scene, fxType, colorA, colorB) {
          const items = [];
          if (fxType === "scanlines") {
            const g = scene.add.graphics();
            g.setAlpha(0.22);
            g.lineStyle(1, colorB, 1);
            for (let y = 0; y < H; y += 8) {
              g.beginPath(); g.moveTo(0, y); g.lineTo(W, y); g.strokePath();
            }
            items.push(g);
          }
          if (fxType === "rain") {
            const drops = [];
            for (let i = 0; i < 42; i++) {
              const r = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(-H, H),
                2,
                Phaser.Math.Between(18, 48),
                colorB
              ).setAlpha(0.16);
              r._vy = Phaser.Math.FloatBetween(240, 460);
              drops.push(r);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const d of drops) {
                d.y += d._vy * dt;
                if (d.y > H + 60) { d.y = Phaser.Math.Between(-120, -20); d.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...drops);
          }
          if (fxType === "stars") {
            const stars = [];
            for (let i = 0; i < 62; i++) {
              const s = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(0, H),
                2, 2, colorA
              ).setAlpha(Phaser.Math.FloatBetween(0.07, 0.32));
              s._vy = Phaser.Math.FloatBetween(12, 52);
              stars.push(s);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const s of stars) {
                s.y += s._vy * dt;
                if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...stars);
          }
          return items;
        }

        // ===== Obstacle textures =====
        function ensureObstacleTextures(scene) {
          const makeTex = (key, drawFn) => {
            if (scene.textures.exists(key)) return;
            const g = scene.make.graphics({ x:0, y:0, add:false });
            g.clear();
            drawFn(g);
            g.generateTexture(key, 64, 64);
            g.destroy();
          };

          makeTex("obs_rect", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(8, 8, 48, 48, 10);
          });

          makeTex("obs_frame", (g) => {
            g.lineStyle(6, 0xffffff, 1);
            g.strokeRoundedRect(10, 10, 44, 44, 10);
            g.lineStyle(2, 0xffffff, 0.7);
            g.strokeRoundedRect(16, 16, 32, 32, 8);
          });

          makeTex("obs_tri", (g) => {
            g.fillStyle(0xffffff, 1);
            g.beginPath();
            g.moveTo(32, 8);
            g.lineTo(56, 56);
            g.lineTo(8, 56);
            g.closePath();
            g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });

          makeTex("obs_hex", (g) => {
            g.fillStyle(0xffffff, 1);
            const pts = [
              {x:32,y:6},{x:54,y:18},{x:54,y:46},{x:32,y:58},{x:10,y:46},{x:10,y:18}
            ];
            g.beginPath();
            g.moveTo(pts[0].x, pts[0].y);
            for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
            g.closePath(); g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });

          makeTex("obs_bar", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(6, 24, 52, 16, 8);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(6, 24, 52, 16, 8);
          });

          makeTex("obs_plus", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(26, 10, 12, 44, 5);
            g.fillRoundedRect(10, 26, 44, 12, 5);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(26, 10, 12, 44, 5);
            g.strokeRoundedRect(10, 26, 44, 12, 5);
          });
        }

        const shapeToTex = {
          rect: "obs_rect",
          frame: "obs_frame",
          tri: "obs_tri",
          hex: "obs_hex",
          bar: "obs_bar",
          plus: "obs_plus"
        };

        // ===== Scoring (shared rules; separate totals per mode) =====
        // Survival points per second
        const SCORE_PPS = 12;

        // Near miss: if obstacle passes within NEAR_DIST of player center, award points; chain multiplier
        const NEAR_DIST = 30; // pixels
        const NEAR_POINTS = 20;
        const COMBO_DECAY_SEC = 1.35;  // if no near-miss in this time, combo resets
        const COMBO_STEP = 0.12;       // multiplier increase per near-miss
        const COMBO_MAX = 3.25;

        // Campaign clear bonus per level (small, consistent)
        const LEVEL_CLEAR_BONUS = 160;

        function formatTime(sec) {
          const m = Math.floor(sec / 60);
          const s = Math.floor(sec % 60);
          return m > 0 ? `${m}:${String(s).padStart(2,"0")}` : `${s}s`;
        }

        // ===== Endless blending model =====
        // Starts at >= World 1 Level 1 difficulty (your requirement).
        // We blend visuals & hazards over time and ramp difficulty forever.
        const ENDLESS = {
          // baseline anchored to World 1 L1
          baseScroll0: WORLDS[0].levels[0].baseScroll,
          ramp0: WORLDS[0].levels[0].scrollRamp,
          spawnStart0: WORLDS[0].levels[0].spawnStart,
          spawnRamp0: WORLDS[0].levels[0].spawnRamp,
          spawnMinFloor: 230,

          // how fast endless increases over time
          scrollRampGrowth: 0.010,   // extra ramp per second
          scrollBaseGrowth: 0.020,   // base speed growth per second
          spawnTighten: 0.20,        // ms per second tighten
          spawnRampGrowth: 0.010,    // extra spawnRamp per second

          // stage timeline (seconds)
          t_industrial: 70,
          t_glitch: 150,
          t_laserWarnOnly: 220,
          t_laserActive: 320
        };

        function getEndlessBlend(t) {
          // returns blend weights for world styles + hazard unlocks
          const w1 = 1;
          const w2 = clamp((t - ENDLESS.t_industrial) / 80, 0, 1);
          const w3 = clamp((t - ENDLESS.t_glitch) / 90, 0, 1);
          // normalize feel (not strictly necessary)
          const total = w1 + w2 + w3;
          return {
            a1: w1/total, a2: w2/total, a3: w3/total,
            laserWarn: t >= ENDLESS.t_laserWarnOnly,
            laserActive: t >= ENDLESS.t_laserActive
          };
        }

        function mixColor(c1, c2, t) {
          const r1 = (c1>>16)&255, g1 = (c1>>8)&255, b1 = c1&255;
          const r2 = (c2>>16)&255, g2 = (c2>>8)&255, b2 = c2&255;
          const r = Math.floor(lerp(r1,r2,t));
          const g = Math.floor(lerp(g1,g2,t));
          const b = Math.floor(lerp(b1,b2,t));
          return (r<<16)|(g<<8)|b;
        }

        // ===== Scenes =====
        class MenuScene extends Phaser.Scene {
          constructor() { super("Menu"); }
          create() {
            this.cameras.main.setBackgroundColor(0x0a0a12);
            addTitle(this, "GRIDRUN", 0.20, 46);
            addSubtitle(this, "Campaign + Endless • Skill-only • Separate leaderboards", 0.27);

            makeButton(this, "CAMPAIGN", W/2, H*0.44, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "ENDLESS", W/2, H*0.54, () => this.scene.start("EndlessIntro"));
            makeGhostButton(this, "LEADERBOARDS", W/2, H*0.64, () => this.scene.start("Leaderboards"));
            makeGhostButton(this, "SETTINGS", W/2, H*0.74, () => this.scene.start("Settings"));
            makeGhostButton(this, "RESET SAVES", W/2, H*0.84, () => { resetAllSaves(); this.scene.restart(); }).setAlpha(0.75);

            const p = loadProgress();
            const total = campaignTotalScore(p);
            this.add.text(W/2, H*0.92, `Campaign Total: ${total}`, {
              fontFamily: uiFont, fontSize: "12px", color: "#ffffff"
            }).setOrigin(0.5).setAlpha(0.55);
          }
        }

        class SettingsScene extends Phaser.Scene {
          constructor() { super("Settings"); }
          create() {
            this.cameras.main.setBackgroundColor(0x070710);
            addTitle(this, "SETTINGS", 0.16, 34);
            addSubtitle(this, "Tweak feel • Saved locally", 0.22);

            const s = loadSettings();

            const mkToggle = (label, y, value, onToggle) => {
              const t = this.add.text(W/2, y, `${label}: ${value ? "ON" : "OFF"}`, {
                fontFamily: uiFont, fontSize: "16px", color: "#ffffff",
                backgroundColor: "rgba(255,255,255,0.10)",
                padding: { left: 16, right: 16, top: 10, bottom: 10 },
              }).setOrigin(0.5).setInteractive({ useHandCursor:true });
              t.on("pointerdown", () => onToggle(t));
              return t;
            };

            const mkSlider = (label, y, min, max, step, get, set) => {
              const text = this.add.text(W/2, y, "", {
                fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
              }).setOrigin(0.5);

              const minus = makeGhostButton(this, "−", W/2 - 110, y + 40, () => {
                const v = clamp(get() - step, min, max); set(v); refresh();
              });
              const plus  = makeGhostButton(this, "+", W/2 + 110, y + 40, () => {
                const v = clamp(get() + step, min, max); set(v); refresh();
              });

              const refresh = () => text.setText(`${label}: ${get().toFixed(2)}  (− / +)`);
              refresh();
              return { text, minus, plus, refresh };
            };

            const tShake = mkToggle("Screen Shake", H*0.32, s.shake, (t)=>{
              s.shake = !s.shake; t.setText(`Screen Shake: ${s.shake?"ON":"OFF"}`); saveSettings(s);
            });

            const tSfx = mkToggle("SFX (stub)", H*0.40, s.sfx, (t)=>{
              s.sfx = !s.sfx; t.setText(`SFX (stub): ${s.sfx?"ON":"OFF"}`); saveSettings(s);
            });

            mkSlider("Touch Follow Lerp", H*0.50, 0.18, 0.70, 0.02,
              ()=>s.followLerp, (v)=>{ s.followLerp=v; saveSettings(s); }
            );

            mkSlider("Touch Max Speed Mult", H*0.63, 1.60, 4.00, 0.10,
              ()=>s.followMaxMult, (v)=>{ s.followMaxMult=v; saveSettings(s); }
            );

            makeGhostButton(this, "BACK", W/2, H*0.90, () => this.scene.start("Menu"));
          }
        }

        class LeaderboardsScene extends Phaser.Scene {
          constructor() { super("Leaderboards"); }
          create() {
            this.cameras.main.setBackgroundColor(0x070710);
            addTitle(this, "LEADERBOARDS", 0.14, 32);
            addSubtitle(this, "Local device scores (global later)", 0.20);

            const p = loadProgress();
            const lb = loadLeaderboards();

            const campaignNow = campaignTotalScore(p);
            const endlessBest = lb.endlessTop[0]?.score || 0;

            this.add.text(W/2, H*0.27, `Your Campaign Total: ${campaignNow}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.9);

            this.add.text(W/2, H*0.31, `Your Endless Best: ${endlessBest}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.85);

            const drawList = (title, arr, x, y) => {
              this.add.text(x, y, title, { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" }).setOrigin(0,0);
              let yy = y + 18;
              if (!arr.length) {
                this.add.text(x, yy, "— none yet —", { fontFamily: uiFont, fontSize:"12px", color:"rgba(255,255,255,0.55)" }).setOrigin(0,0);
                return;
              }
              arr.forEach((e, i) => {
                this.add.text(x, yy, `${i+1}. ${e.score}`, {
                  fontFamily: uiFont, fontSize:"12px", color:"#ffffff"
                }).setOrigin(0,0).setAlpha(0.9);
                if (e.meta) {
                  this.add.text(x+70, yy, e.meta, {
                    fontFamily: uiFont, fontSize:"11px", color:"rgba(255,255,255,0.55)"
                  }).setOrigin(0,0);
                }
                yy += 18;
              });
            };

            drawList("Campaign Total Top 10", lb.campaignTop, 34, H*0.38);
            drawList("Endless Top 10", lb.endlessTop, 240, H*0.38);

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldMapScene extends Phaser.Scene {
          constructor() { super("WorldMap"); }
          create() {
            const p = loadProgress();
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "CAMPAIGN", 0.14, 34);
            addSubtitle(this, "Replay unlocked levels • Total = sum of level bests", 0.20);

            const total = campaignTotalScore(p);
            this.add.text(W/2, H*0.24, `Campaign Total: ${total}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.85);

            const marginX = 18;
            const colW = (W - marginX*2);
            let y = H*0.28;

            WORLDS.forEach((w, wi) => {
              const unlockedWorld = wi <= p.unlockedWorld;

              const sub = worldSubtotal(p, wi);
              this.add.text(marginX, y, `${wi+1}. ${w.name}`, {
                fontFamily: uiFont, fontSize: "16px",
                color: unlockedWorld ? "#ffffff" : "rgba(255,255,255,0.40)"
              }).setAlpha(0.95);

              this.add.text(W - marginX, y, `Subtotal: ${sub}`, {
                fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.65)"
              }).setOrigin(1,0).setAlpha(0.9);

              y += 26;

              const gap = 10;
              const btnW = (colW - gap*(LEVELS_PER_WORLD-1)) / LEVELS_PER_WORLD;
              for (let li = 0; li < LEVELS_PER_WORLD; li++) {
                const unlocked = isLevelUnlocked(p, wi, li);
                const bx = marginX + li * (btnW + gap);
                const by = y;

                const best = p.levelBest[levelId(wi, li)] || 0;
                const label = `${li+1}\n${best}`;

                const b = this.add.text(bx + btnW/2, by + 22, label, {
                  fontFamily: uiFont,
                  fontSize: "12px",
                  align: "center",
                  color: unlocked ? "#0a0a12" : "rgba(255,255,255,0.55)",
                  backgroundColor: unlocked ? "#6ef3ff" : "rgba(255,255,255,0.08)",
                  padding: { left: 0, right: 0, top: 8, bottom: 8 }
                }).setOrigin(0.5);

                b.setFixedSize(btnW, 44);
                if (unlocked) {
                  b.setInteractive({ useHandCursor: true });
                  b.on("pointerdown", () => {
                    const p2 = loadProgress();
                    p2.currentWorld = wi;
                    p2.currentLevel = li;
                    saveProgress(p2);
                    this.scene.start("WorldIntro", { world: wi, level: li });
                  });
                } else {
                  b.setAlpha(0.6);
                }
              }

              y += 68;
            });

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldIntroScene extends Phaser.Scene {
          constructor() { super("WorldIntro"); }
          create(data) {
            const world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            const level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);

            const w = WORLDS[world];
            const lv = w.levels[level];

            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.fx, w.player, w.border);

            addTitle(this, w.name, 0.20, 34);
            addSubtitle(this, w.subtitle, 0.26);

            const p = loadProgress();
            const best = p.levelBest[levelId(world, level)] || 0;

            this.add.text(W/2, H*0.40,
              `Level ${level + 1}/${LEVELS_PER_WORLD} • ${lv.seconds}s\nBest: ${best}`,
              { fontFamily: uiFont, fontSize: "16px", color: "#ffffff", align: "center" }
            ).setOrigin(0.5).setAlpha(0.92);

            const p2 = loadProgress();
            p2.currentWorld = world;
            p2.currentLevel = level;
            saveProgress(p2);

            makeButton(this, "START", W/2, H*0.58, () => this.scene.start("Play", { mode:"campaign", world, level }));
            makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.80, () => this.scene.start("Menu"));
          }
        }

        class EndlessIntroScene extends Phaser.Scene {
          constructor() { super("EndlessIntro"); }
          create() {
            this.cameras.main.setBackgroundColor(0x050512);
            addTitle(this, "ENDLESS", 0.20, 36);
            addSubtitle(this, "Starts at World 1 Level 1 difficulty • Ramps forever • Blends all worlds", 0.27);

            const lb = loadLeaderboards();
            const best = lb.endlessTop[0]?.score || 0;

            this.add.text(W/2, H*0.40, `Best: ${best}`, {
              fontFamily: uiFont, fontSize:"18px", color:"#ffffff"
            }).setOrigin(0.5).setAlpha(0.9);

            makeButton(this, "START ENDLESS", W/2, H*0.58, () => this.scene.start("Play", { mode:"endless" }));
            makeGhostButton(this, "LEADERBOARDS", W/2, H*0.70, () => this.scene.start("Leaderboards"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.80, () => this.scene.start("Menu"));
          }
        }

        // ===== Play Scene (Campaign + Endless) =====
        class PlayScene extends Phaser.Scene {
          constructor() {
            super("Play");
            this.mode = "campaign"; // or "endless"
            this.world = 0;
            this.level = 0;

            this.wcfg = WORLDS[0];
            this.lcfg = WORLDS[0].levels[0];

            // runtime
            this.t = 0;
            this.score = 0;
            this.paused = false;

            // scoring breakdown
            this.survivalPts = 0;
            this.nearPts = 0;
            this.clearBonusPts = 0;
            this.combo = 1;
            this.comboTimer = 0;
            this.maxCombo = 1;

            // pacing
            this.scrollSpeed = 0;
            this.spawnEvery = 0;
            this.spawnTimer = 0;

            // rendering
            this.gridGraphics = null;
            this.gridOffset = 0;

            // entities
            this.obstacles = null;
            this.player = null;

            // touch
            this.touchTarget = null;
            this.touchDot = null;

            // pause UI
            this.pauseOverlay = null;

            // boss laser (campaign W3 + endless later)
            this.laser = null;
            this.laserWarn = null;
            this.bossT = 0;
            this.laserEnabled = false;
            this.laserWarnOnly = false;

            // decor
            this.decor = [];
            this.glitchFlash = null;

            // settings
            this.settings = loadSettings();

            // near-miss bookkeeping
            this.nearSeen = new WeakSet();
          }

          init(data) {
            this.mode = data?.mode || "campaign";
            if (this.mode === "campaign") {
              this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
              this.level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);
              this.wcfg = WORLDS[this.world];
              this.lcfg = this.wcfg.levels[this.level];
            } else {
              // endless starts at >= world1 level1 difficulty
              this.world = 0;
              this.level = 0;
              this.wcfg = WORLDS[0];
              this.lcfg = WORLDS[0].levels[0];
            }
          }

          create() {
            ensureObstacleTextures(this);

            this.settings = loadSettings();
            this.cameras.main.setBackgroundColor(this.wcfg.bg);
            buildBackdrop(this, this.wcfg.fx, this.wcfg.player, this.wcfg.border);

            this.gridGraphics = this.add.graphics();
            this.gridOffset = 0;

            this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

            const startX = GRID_X + GRID_W / 2;
            const startY = GRID_Y + GRID_H * 0.72;

            this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
            this.physics.add.existing(this.player);
            this.player.body.setAllowGravity(false);

            this.physics.add.overlap(this.player, this.obstacles, (_, o) => {
              // obstacle hit
              this.endRun({ reason: "OBSTACLE" });
            });

            // keyboard
            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys("W,A,S,D,ESC");

            // touch indicator
            this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0);
            this.touchTarget = null;

            this.input.on("pointerdown", (p) => {
              if (this.paused) { this.togglePause(false); return; }
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointermove", (p) => {
              if (!p.isDown || this.paused) return;
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointerup", () => {
              this.touchTarget = null;
              this.touchDot.setAlpha(0);
            });

            // HUD
            this.uiTop = this.add.text(14, 10, "", { fontFamily: uiFont, fontSize: "14px", color: "#ffffff" }).setAlpha(0.95);
            this.uiSub = this.add.text(14, 30, "", { fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff" }).setAlpha(0.95);
            this.uiCombo = this.add.text(W-14, 10, "", { fontFamily: uiFont, fontSize: "12px", color: "#ffffff" })
              .setOrigin(1,0).setAlpha(0.85);

            // pause button (mobile)
            this.pauseBtn = this.add.text(W-14, 30, "PAUSE", {
              fontFamily: uiFont, fontSize: "12px",
              color: "#ffffff", backgroundColor: "rgba(255,255,255,0.10)",
              padding: { left: 10, right: 10, top: 6, bottom: 6 }
            }).setOrigin(1,0).setInteractive({ useHandCursor:true }).setAlpha(0.9);
            this.pauseBtn.on("pointerdown", () => this.togglePause(!this.paused));

            // overlay for glitch flash
            this.glitchFlash = this.add.rectangle(W/2, H/2, W, H, 0xffffff).setAlpha(0).setDepth(50);

            // reset state
            this.t = 0;
            this.score = 0;
            this.paused = false;

            this.survivalPts = 0;
            this.nearPts = 0;
            this.clearBonusPts = 0;
            this.combo = 1;
            this.comboTimer = 0;
            this.maxCombo = 1;

            this.spawnTimer = 0;
            this.nearSeen = new WeakSet();

            // initial pacing
            if (this.mode === "campaign") {
              this.scrollSpeed = this.lcfg.baseScroll;
              this.spawnEvery = this.lcfg.spawnStart;
            } else {
              this.scrollSpeed = ENDLESS.baseScroll0;
              this.spawnEvery = ENDLESS.spawnStart0;
            }

            this.setupBoss();
            this.setupDecor();
            this.updateHud();

            // ESC pause
            this.input.keyboard.on("keydown-ESC", () => this.togglePause(!this.paused));
          }

          togglePause(on) {
            this.paused = on;
            if (on) {
              this.pauseOverlay = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0.55).setDepth(90);
              this.pauseText = this.add.text(W/2, H*0.44, "PAUSED", { fontFamily: uiFont, fontSize:"28px", color:"#ffffff" })
                .setOrigin(0.5).setDepth(91);
              this.pauseSub = this.add.text(W/2, H*0.52, "Tap / Press ESC to resume", { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" })
                .setOrigin(0.5).setDepth(91).setAlpha(0.9);
            } else {
              if (this.pauseOverlay) this.pauseOverlay.destroy();
              if (this.pauseText) this.pauseText.destroy();
              if (this.pauseSub) this.pauseSub.destroy();
              this.pauseOverlay = null;
            }
          }

          setupDecor() {
            for (const d of this.decor) d.destroy();
            this.decor = [];

            if (this.wcfg.gridStyle === "industrial") {
              for (let i = 0; i < 8; i++) {
                const r = this.add.rectangle(GRID_X - 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                const r2 = this.add.rectangle(GRID_X + GRID_W + 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                this.decor.push(r, r2);
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              for (let i=0;i<16;i++){
                const b = this.add.rectangle(
                  Phaser.Math.Between(0, W),
                  Phaser.Math.Between(-H, H),
                  Phaser.Math.Between(10, 26),
                  Phaser.Math.Between(4, 12),
                  0x9aa7ff
                ).setAlpha(Phaser.Math.FloatBetween(0.06, 0.14));
                b._vy = Phaser.Math.FloatBetween(40, 110);
                this.decor.push(b);
              }
            }
          }

          setupBoss() {
            this.bossT = 0;
            if (this.laser) this.laser.destroy();
            if (this.laserWarn) this.laserWarn.destroy();
            this.laser = null;
            this.laserWarn = null;

            // campaign: boss enabled only in world 3
            if (this.mode === "campaign") {
              const boss = this.wcfg.boss;
              this.laserEnabled = !!(boss && boss.enabled);
              this.laserWarnOnly = false;
              if (!this.laserEnabled) return;

              this.laserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.warnThickness, 0xffffff)
                .setAlpha(0).setDepth(20);
              this.laser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.thickness, 0xff4d7d)
                .setAlpha(0).setDepth(21);
              return;
            }

            // endless: created now but may be warn-only or active based on time
            const boss = WORLDS[2].boss;
            this.laserEnabled = false;
            this.laserWarnOnly = false;

            this.laserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.warnThickness, 0xffffff)
              .setAlpha(0).setDepth(20);
            this.laser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.thickness, 0xff4d7d)
              .setAlpha(0).setDepth(21);
          }

          update(_, deltaMs) {
            if (this.paused) return;

            const dt = deltaMs / 1000;
            this.t += dt;

            // combo decay
            this.comboTimer += dt;
            if (this.comboTimer > COMBO_DECAY_SEC) {
              this.combo = 1;
            }

            // === Mode pacing ===
            let timeLeft = 0;
            if (this.mode === "campaign") {
              timeLeft = Math.max(0, this.lcfg.seconds - this.t);

              // end level
              if (this.t >= this.lcfg.seconds) {
                this.clearBonusPts += LEVEL_CLEAR_BONUS;
                this.score += LEVEL_CLEAR_BONUS;
                this.levelComplete();
                return;
              }

              // campaign curve
              this.scrollSpeed = this.lcfg.baseScroll + this.t * this.lcfg.scrollRamp;
              const targetSpawn = this.lcfg.spawnStart - this.t * this.lcfg.spawnRamp;
              this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);

            } else {
              // endless ramps forever, starts at >= W1 L1
              const base = ENDLESS.baseScroll0 + (this.t * ENDLESS.scrollBaseGrowth * 60) / 60; // keep simple
              const ramp = ENDLESS.ramp0 + this.t * ENDLESS.scrollRampGrowth;
              this.scrollSpeed = base + this.t * ramp;

              const spawnStart = ENDLESS.spawnStart0 - this.t * (ENDLESS.spawnTighten);
              const spawnRamp = ENDLESS.spawnRamp0 + this.t * ENDLESS.spawnRampGrowth;
              const targetSpawn = spawnStart - this.t * spawnRamp;

              this.spawnEvery = clamp(targetSpawn, ENDLESS.spawnMinFloor, ENDLESS.spawnStart0);

              // blend world feel over time
              const b = getEndlessBlend(this.t);
              this.applyEndlessBlend(b);
              timeLeft = 0;
            }

            // === Survival scoring ===
            const add = SCORE_PPS * dt;
            this.survivalPts += add;
            this.score += add;

            // === Movement ===
            if (!IS_TOUCH) {
              let kvx = 0, kvy = 0;
              const left = this.cursors.left.isDown || this.keys.A.isDown;
              const right = this.cursors.right.isDown || this.keys.D.isDown;
              const up = this.cursors.up.isDown || this.keys.W.isDown;
              const down = this.cursors.down.isDown || this.keys.S.isDown;
              if (left) kvx -= 1;
              if (right) kvx += 1;
              if (up) kvy -= 1;
              if (down) kvy += 1;
              const mag = Math.hypot(kvx, kvy);
              if (mag > 1) { kvx /= mag; kvy /= mag; }
              this.player.body.setVelocity(kvx * PLAYER_SPEED, kvy * PLAYER_SPEED);
            } else {
              if (this.touchTarget) {
                const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
                const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

                const dx = tx - this.player.x;
                const dy = ty - this.player.y;
                const dist = Math.hypot(dx, dy);

                if (dist > FOLLOW_RADIUS) {
                  const nx = this.player.x + dx * this.settings.followLerp;
                  const ny = this.player.y + dy * this.settings.followLerp;

                  const maxStep = PLAYER_SPEED * this.settings.followMaxMult * dt;
                  const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);

                  if (stepDist > maxStep) {
                    const s = maxStep / stepDist;
                    this.player.x = this.player.x + (nx - this.player.x) * s;
                    this.player.y = this.player.y + (ny - this.player.y) * s;
                  } else {
                    this.player.x = nx;
                    this.player.y = ny;
                  }

                  this.player.body.reset(this.player.x, this.player.y);
                } else {
                  this.player.body.setVelocity(0, 0);
                }
              } else {
                this.player.body.setVelocity(0, 0);
              }
            }

            // clamp to grid
            const pad = 14;
            const px = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
            const py = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
            if (px !== this.player.x || py !== this.player.y) {
              this.player.x = px; this.player.y = py;
              this.player.body.reset(px, py);
            }

            // decor updates (glitch)
            if (this.wcfg.gridStyle === "glitch") {
              for (const b of this.decor) {
                b.y += b._vy * dt;
                if (b.y > H + 20) { b.y = -20; b.x = Phaser.Math.Between(0, W); }
              }
              if (Math.random() < 0.012) {
                this.glitchFlash.setAlpha(0.06);
                this.tweens.add({ targets: this.glitchFlash, alpha: 0, duration: 120, ease: "Linear" });
              }
            }

            // spawn obstacles
            this.spawnTimer += deltaMs;
            while (this.spawnTimer >= this.spawnEvery) {
              this.spawnTimer -= this.spawnEvery;
              this.spawnObstacle();
            }

            // move obstacles + near-miss scoring
            this.obstacles.children.iterate((o) => {
              if (!o) return;
              o.y += this.scrollSpeed * dt;
              if (o.y > GRID_Y + GRID_H + 140) { o.destroy(); return; }
              this.checkNearMiss(o);
            });

            // boss laser update
            this.updateBoss(dt);

            // draw grid
            this.drawGrid(dt);

            // HUD
            this.updateHud(timeLeft);
          }

          applyEndlessBlend(blend) {
            // Blend visuals toward W2/W3 over time
            const w1 = WORLDS[0], w2 = WORLDS[1], w3 = WORLDS[2];

            // background / border / grid line / player tint blend
            const bg12 = mixColor(w1.bg, w2.bg, blend.a2);
            const bg = mixColor(bg12, w3.bg, blend.a3);
            const border12 = mixColor(w1.border, w2.border, blend.a2);
            const border = mixColor(border12, w3.border, blend.a3);
            const grid12 = mixColor(w1.gridLine, w2.gridLine, blend.a2);
            const grid = mixColor(grid12, w3.gridLine, blend.a3);
            const player12 = mixColor(w1.player, w2.player, blend.a2);
            const player = mixColor(player12, w3.player, blend.a3);

            // choose dominant style for grid style + fx
            let gridStyle = "circuit";
            if (blend.a3 > 0.40) gridStyle = "glitch";
            else if (blend.a2 > 0.45) gridStyle = "industrial";

            this.wcfg = {
              id: 99,
              name: "Endless",
              subtitle: "",
              bg, border, gridLine: grid, player,
              fx: (gridStyle==="glitch") ? "stars" : (gridStyle==="industrial" ? "rain" : "scanlines"),
              gridStyle,
              obstacleStyle: {
                palette: [...w1.obstacleStyle.palette, ...w2.obstacleStyle.palette, ...w3.obstacleStyle.palette],
                shapes: [
                  ...w1.obstacleStyle.shapes,
                  ...(blend.a2>0.2 ? w2.obstacleStyle.shapes : []),
                  ...(blend.a3>0.2 ? w3.obstacleStyle.shapes : [])
                ]
              },
              boss: WORLDS[2].boss
            };

            // Update player color
            this.player.fillColor = player;
            this.touchDot.fillColor = player;

            // Laser unlocks
            this.laserWarnOnly = blend.laserWarn && !blend.laserActive;
            this.laserEnabled = blend.laserActive;

            // Adjust decor style when crossing thresholds (cheap approach)
            // If we just switched into industrial/glitch, re-init decor occasionally
            if (!this._lastGridStyle) this._lastGridStyle = this.wcfg.gridStyle;
            if (this._lastGridStyle !== this.wcfg.gridStyle) {
              this._lastGridStyle = this.wcfg.gridStyle;
              this.setupDecor();
            }
          }

          updateHud(timeLeft) {
            const modeLabel = this.mode === "campaign" ? `Campaign • ${this.wcfg.name} L${this.level+1}` : "Endless";
            const tLabel = this.mode === "campaign" ? `Time: ${Math.ceil(timeLeft)}s` : `Time: ${formatTime(this.t)}`;

            this.uiTop.setText(`${modeLabel} • Score: ${Math.floor(this.score)}`);
            this.uiSub.setText(`${tLabel} • Near: ${Math.floor(this.nearPts)} • PPS: ${SCORE_PPS}`);
            const cm = Math.min(COMBO_MAX, this.combo);
            this.uiCombo.setText(cm > 1.01 ? `x${cm.toFixed(2)}` : "");
          }

          drawGrid(dt) {
            this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
            const g = this.gridGraphics;
            g.clear();

            g.lineStyle(2, this.wcfg.border, 0.92);
            g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

            if (this.wcfg.gridStyle === "circuit") {
              g.lineStyle(1, this.wcfg.gridLine, 0.95);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.fillStyle(this.wcfg.player, 0.12);
              for (let c = 0; c <= GRID_COLS; c++) {
                for (let r = 0; r <= GRID_ROWS; r++) {
                  if ((c + r) % 3 !== 0) continue;
                  g.fillCircle(GRID_X + c*TILE, GRID_Y + r*TILE, 2.2);
                }
              }
            }

            if (this.wcfg.gridStyle === "industrial") {
              g.lineStyle(2, this.wcfg.gridLine, 0.9);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.lineStyle(1, 0xffd166, 0.07);
              for (let x = GRID_X - GRID_H; x < GRID_X + GRID_W + GRID_H; x += 18) {
                g.beginPath();
                g.moveTo(x, GRID_Y);
                g.lineTo(x + GRID_H, GRID_Y + GRID_H);
                g.strokePath();
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              const flick = 0.75 + Math.sin(this.t * 8) * 0.10;
              g.lineStyle(1, this.wcfg.gridLine, flick);

              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                let y0 = GRID_Y;
                while (y0 < GRID_Y + GRID_H) {
                  const seg = Phaser.Math.Between(18, 64);
                  const gap = Phaser.Math.Between(10, 40);
                  if (Math.random() > 0.22) {
                    g.beginPath();
                    g.moveTo(x, y0);
                    g.lineTo(x, Math.min(GRID_Y + GRID_H, y0 + seg));
                    g.strokePath();
                  }
                  y0 += seg + gap;
                }
              }

              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                let x0 = GRID_X;
                while (x0 < GRID_X + GRID_W) {
                  const seg = Phaser.Math.Between(20, 70);
                  const gap = Phaser.Math.Between(12, 44);
                  if (Math.random() > 0.25) {
                    g.beginPath();
                    g.moveTo(x0, y);
                    g.lineTo(Math.min(GRID_X + GRID_W, x0 + seg), y);
                    g.strokePath();
                  }
                  x0 += seg + gap;
                }
              }
            }
          }

          spawnObstacle() {
            const col = Phaser.Math.Between(0, GRID_COLS - 1);
            const x = GRID_X + col * TILE + TILE / 2;
            const y = GRID_Y - 70;

            const style = this.wcfg.obstacleStyle;
            const shapes = style.shapes;
            const shape = shapes[Phaser.Math.Between(0, shapes.length - 1)];
            const tex = shapeToTex[shape] || "obs_rect";
            const palette = style.palette;
            const color = palette[Phaser.Math.Between(0, palette.length - 1)];

            // size depends on campaign level, or slowly shrinks in endless
            let smin = 20, smax = 32;
            if (this.mode === "campaign") {
              const [a,b] = this.lcfg.size;
              smin = a; smax = b;
            } else {
              // very gentle shrink over time (readability preserved)
              smin = clamp(22 - Math.floor(this.t/120), 16, 22);
              smax = clamp(34 - Math.floor(this.t/140), 22, 34);
            }

            let w = Phaser.Math.Between(smin, smax);
            let h = Phaser.Math.Between(smin, smax);

            if (shape === "bar") { w = Phaser.Math.Between(smax+8, smax+26); h = Phaser.Math.Between(14, 22); }
            if (shape === "tri") { w = Phaser.Math.Between(smin, smax+4); h = Phaser.Math.Between(smin, smax+8); }
            if (shape === "frame") { w = Phaser.Math.Between(smin+2, smax+10); h = Phaser.Math.Between(smin+2, smax+10); }
            if (shape === "plus") { w = Phaser.Math.Between(smin, smax+10); h = Phaser.Math.Between(smin, smax+10); }

            const s = this.add.image(x, y, tex);
            s.setTint(color);
            s.setAlpha(0.95);
            s.displayWidth = w;
            s.displayHeight = h;

            this.physics.add.existing(s);
            s.body.setAllowGravity(false);
            s.body.setImmovable(true);
            s.body.setSize(w * 0.88, h * 0.88, true);

            // mark for near-miss scoring
            s._nearAwarded = false;

            this.obstacles.add(s);

            // extra piece chance increases later / harder worlds; in endless increases slowly with time
            let chance = 0.06;
            if (this.mode === "campaign") {
              const worldBonus = this.world * 0.02;
              const later = this.level >= 2 ? 1 : 0;
              chance = Phaser.Math.Clamp(0.05 + later*0.06 + worldBonus + (this.t * 0.0022), 0.05, 0.24);
            } else {
              chance = Phaser.Math.Clamp(0.06 + (this.t * 0.0016), 0.06, 0.22);
            }

            if (Math.random() < chance && this.t > 5) {
              let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
              if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;
              const x2 = GRID_X + col2 * TILE + TILE / 2;

              const shape2 = shapes[Phaser.Math.Between(0, shapes.length - 1)];
              const tex2 = shapeToTex[shape2] || "obs_rect";
              const color2 = palette[Phaser.Math.Between(0, palette.length - 1)];

              const s2 = this.add.image(x2, y - Phaser.Math.Between(22, 90), tex2);
              s2.setTint(color2);
              s2.setAlpha(0.9);
              s2.displayWidth = Math.max(14, w * 0.78);
              s2.displayHeight = Math.max(14, h * 0.78);

              this.physics.add.existing(s2);
              s2.body.setAllowGravity(false);
              s2.body.setImmovable(true);
              s2.body.setSize(s2.displayWidth * 0.88, s2.displayHeight * 0.88, true);
              s2._nearAwarded = false;

              this.obstacles.add(s2);
            }
          }

          checkNearMiss(o) {
            if (!o || o._nearAwarded) return;

            // Only score near miss when obstacle is near player's y-band (passes by)
            const dy = Math.abs(o.y - this.player.y);
            if (dy > 28) return;

            const dx = Math.abs(o.x - this.player.x);
            const dist = Math.hypot(dx, dy);

            if (dist <= NEAR_DIST) {
              // award once
              o._nearAwarded = true;

              this.comboTimer = 0;
              this.combo = Math.min(COMBO_MAX, this.combo + COMBO_STEP);
              this.maxCombo = Math.max(this.maxCombo, this.combo);

              const award = NEAR_POINTS * this.combo;
              this.nearPts += award;
              this.score += award;

              if (this.settings.shake) this.cameras.main.shake(60, 0.002);
            }
          }

          updateBoss(dt) {
            // campaign: only in W3. endless: unlocked by time stages.
            const boss = WORLDS[2].boss;
            if (!boss || !this.laser || !this.laserWarn) return;

            // If campaign and boss not enabled, keep hidden
            if (this.mode === "campaign") {
              if (!this.laserEnabled) { this.laserWarn.setAlpha(0); this.laser.setAlpha(0); return; }
            }

            // endless: show warn or active depending on unlock
            if (this.mode === "endless") {
              if (!this.laserEnabled && !this.laserWarnOnly) { this.laserWarn.setAlpha(0); this.laser.setAlpha(0); return; }
            }

            this.bossT += dt;
            const cycle = boss.cycleSeconds;
            const t = this.bossT % cycle;

            const drift = (this.bossT * 0.22) % 1;
            const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + drift) % 1);

            this.laserWarn.setPosition(GRID_X + GRID_W/2, yPos);
            this.laser.setPosition(GRID_X + GRID_W/2, yPos);

            const warnOn = t < boss.warnSeconds;
            const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

            // endless warn-only stage: show warning, no active beam
            if (this.mode === "endless" && this.laserWarnOnly) {
              this.laserWarn.setAlpha(warnOn ? 0.35 : 0);
              this.laser.setAlpha(0);
              return;
            }

            // active stage (campaign W3 OR endless active)
            this.laserWarn.setAlpha(warnOn ? 0.35 : 0);
            this.laser.setAlpha(activeOn ? 0.85 : 0);

            if (activeOn) {
              const pr = this.player.getBounds();
              const lr = this.laser.getBounds();
              if (Phaser.Geom.Intersects.RectangleToRectangle(pr, lr)) {
                this.endRun({ reason: "LASER" });
              }
            }
          }

          levelComplete() {
            // update per-level best, campaign total leaderboard, unlock next
            const p = loadProgress();
            const id = levelId(this.world, this.level);
            const thisScore = Math.floor(this.score);
            const prevBest = p.levelBest[id] || 0;

            let pbLevel = false;
            if (thisScore > prevBest) {
              p.levelBest[id] = thisScore;
              pbLevel = true;
            }

            // unlock logic
            let nextWorld = this.world;
            let nextLevel = this.level + 1;
            let worldClear = false;

            if (nextLevel >= LEVELS_PER_WORLD) {
              worldClear = true;
              nextLevel = 0;
              nextWorld = this.world + 1;
            }

            if (worldClear) {
              p.unlockedWorld = Math.max(p.unlockedWorld, Math.min(WORLDS_COUNT-1, this.world + 1));
              p.unlockedLevel = 0;
            } else {
              if (p.unlockedWorld < this.world) p.unlockedWorld = this.world;
              if (p.unlockedWorld === this.world) p.unlockedLevel = Math.max(p.unlockedLevel, this.level + 1);
            }

            // set current selection
            if (nextWorld >= WORLDS.length) {
              p.currentWorld = WORLDS.length - 1;
              p.currentLevel = LEVELS_PER_WORLD - 1;
            } else {
              p.currentWorld = nextWorld;
              p.currentLevel = nextLevel;
            }

            saveProgress(p);

            // update campaign leaderboard with TOTAL (separate from endless)
            const total = campaignTotalScore(p);
            const lb = loadLeaderboards();
            lb.campaignTop = maybeInsertTop(lb.campaignTop, { score: total, meta: "Total" });
            saveLeaderboards(lb);

            this.scene.start("Results", {
              mode: "campaign",
              world: this.world,
              level: this.level,
              score: thisScore,
              prevBest,
              pb: pbLevel,
              total,
              breakdown: this.getBreakdown(),
              reason: "CLEAR"
            });
          }

          getBreakdown() {
            return {
              survival: Math.floor(this.survivalPts),
              near: Math.floor(this.nearPts),
              clear: Math.floor(this.clearBonusPts),
              maxCombo: Number(this.maxCombo.toFixed(2))
            };
          }

          endRun({ reason }) {
            const thisScore = Math.floor(this.score);

            if (this.settings.shake) this.cameras.main.shake(120, 0.006);
            this.glitchFlash.setAlpha(0.10);
            this.tweens.add({ targets: this.glitchFlash, alpha: 0, duration: 150, ease: "Linear" });

            if (this.mode === "endless") {
              const lb = loadLeaderboards();
              const prevBest = lb.endlessTop[0]?.score || 0;
              const pb = thisScore > prevBest;
              lb.endlessTop = maybeInsertTop(lb.endlessTop, { score: thisScore, meta: formatTime(this.t) });
              saveLeaderboards(lb);

              this.scene.start("Results", {
                mode: "endless",
                score: thisScore,
                prevBest,
                pb,
                total: null,
                breakdown: this.getBreakdown(),
                reason
              });
              return;
            }

            // campaign death: no level best update (only on clear), keep it simple
            const p = loadProgress();
            const id = levelId(this.world, this.level);
            const prevBest = p.levelBest[id] || 0;
            const total = campaignTotalScore(p);

            this.scene.start("Results", {
              mode: "campaign",
              world: this.world,
              level: this.level,
              score: thisScore,
              prevBest,
              pb: false,
              total,
              breakdown: this.getBreakdown(),
              reason
            });
          }
        }

        class ResultsScene extends Phaser.Scene {
          constructor() { super("Results"); }
          create(data) {
            this.cameras.main.setBackgroundColor(0x070710);

            const mode = data?.mode || "campaign";
            const score = data?.score || 0;
            const prevBest = data?.prevBest || 0;
            const pb = !!data?.pb;
            const total = data?.total;
            const reason = data?.reason || "";

            const breakdown = data?.breakdown || { survival:0, near:0, clear:0, maxCombo:1 };

            addTitle(this, mode === "endless" ? "ENDLESS RESULT" : "LEVEL RESULT", 0.16, 30);

            const subtitle =
              mode === "endless"
                ? `Reason: ${reason}`
                : `${WORLDS[data.world].name} • Level ${data.level+1} • ${reason==="CLEAR"?"CLEARED":"FAILED"}`;

            addSubtitle(this, subtitle, 0.22);

            this.add.text(W/2, H*0.34, `Score: ${score}`, {
              fontFamily: uiFont, fontSize:"24px", color:"#ffffff"
            }).setOrigin(0.5).setAlpha(0.95);

            this.add.text(W/2, H*0.40, `Best: ${Math.max(prevBest, (pb?score:prevBest))}${pb ? "  •  NEW PB!" : ""}`, {
              fontFamily: uiFont, fontSize:"14px", color: pb ? "#6ef3ff" : "#b7b7ff"
            }).setOrigin(0.5).setAlpha(0.95);

            // breakdown
            const lines = [
              `Survival: ${breakdown.survival}`,
              `Near-miss: ${breakdown.near}`,
              `Clear Bonus: ${breakdown.clear}`,
              `Max Combo: x${breakdown.maxCombo}`
            ];
            this.add.text(W/2, H*0.52, lines.join("\n"), {
              fontFamily: uiFont, fontSize:"14px", color:"rgba(255,255,255,0.85)", align:"center"
            }).setOrigin(0.5);

            if (mode === "campaign") {
              this.add.text(W/2, H*0.66, `Campaign Total: ${total}`, {
                fontFamily: uiFont, fontSize:"14px", color:"#ffffff"
              }).setOrigin(0.5).setAlpha(0.85);

              makeButton(this, "RETRY", W/2, H*0.76, () => this.scene.start("Play", { mode:"campaign", world:data.world, level:data.level }));
              makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.85, () => this.scene.start("WorldMap"));
            } else {
              makeButton(this, "RETRY ENDLESS", W/2, H*0.76, () => this.scene.start("Play", { mode:"endless" }));
              makeGhostButton(this, "LEADERBOARDS", W/2, H*0.85, () => this.scene.start("Leaderboards"));
            }

            makeGhostButton(this, "MAIN MENU", W/2, H*0.93, () => this.scene.start("Menu"));
          }
        }

        // ===== Game config =====
        new Phaser.Game({
          type: Phaser.AUTO,
          width: W,
          height: H,
          physics: { default: "arcade", arcade: { debug: false } },
          scene: [
            MenuScene,
            SettingsScene,
            LeaderboardsScene,
            WorldMapScene,
            WorldIntroScene,
            EndlessIntroScene,
            PlayScene,
            ResultsScene
          ],
        });

      }, 50);
    });
  </script>
</body>
</html>
