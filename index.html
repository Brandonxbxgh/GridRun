<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TXC GRIDRUN</title>
  <style>
    :root{
      --bg:#0b0f25;
      --panel:#141a38;
      --panel2:#0f1430;
      --line:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#6ee7ff;
      --good:#b7ff6e;
      --bad:#ff6ee7;
      --warn:#ffd36e;
    }
    *{box-sizing:border-box;}
    html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--text);}
    button{font:inherit; color:inherit; -webkit-tap-highlight-color:transparent;}

    .wrap{min-height:100%; display:flex; align-items:center; justify-content:center; padding:14px;}
    .app{width:min(720px,100%); border:1px solid var(--line); background:rgba(0,0,0,.20); border-radius:14px; overflow:hidden;}
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px; border-bottom:1px solid var(--line);
      background:rgba(0,0,0,.25);
    }
    .brand{display:flex; align-items:center; gap:10px;}
    .logo{
      width:28px; height:28px; border-radius:10px;
      background:conic-gradient(from 110deg, var(--accent), var(--bad), var(--good), var(--accent));
      border:1px solid rgba(255,255,255,.18);
    }
    .title{font-weight:900; letter-spacing:.12em; text-transform:uppercase;}
    .subtitle{font-size:12px; color:var(--muted); margin-top:2px;}

    .hud{display:flex; flex-wrap:wrap; gap:8px; justify-content:flex-end; font-size:12px; color:rgba(255,255,255,.85);}
    .pill{padding:5px 8px; border:1px solid rgba(255,255,255,.12); border-radius:999px; background:rgba(255,255,255,.06); white-space:nowrap;}
    .pill b{color:var(--text);}
    .pill .dot{display:inline-block; width:8px; height:8px; border-radius:99px; background:var(--accent); box-shadow:0 0 14px rgba(110,231,255,.35); margin-right:6px; vertical-align:middle;}

    .content{padding:14px;}
    .screen{display:none;}
    .screen.active{display:block;}

    .panel{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      border-radius:12px;
      padding:12px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap;}
    .row > *{flex:1 1 180px;}
    .btn{
      width:100%;
      padding:12px 10px;
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      cursor:pointer;
      display:flex; align-items:center; justify-content:space-between;
      touch-action:manipulation;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}
    .btn:disabled{opacity:.45; cursor:not-allowed;}
    .hint{font-size:12px; color:var(--muted);}
    .divider{height:10px;}

    .note{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.35;
    }

    .tag{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      font-size:12px;
      color:rgba(255,255,255,.82);
      margin-left:6px;
    }

    .gameWrap{display:flex; flex-direction:column; align-items:center; gap:10px;}
    canvas{
      width:100%;
      max-width:560px;
      aspect-ratio: 9/16;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      background:#050612;
      touch-action:none;
    }
    .controls{
      width:100%;
      display:flex; gap:10px; flex-wrap:wrap; justify-content:center;
    }
    .mini{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      cursor:pointer;
      touch-action:manipulation;
      user-select:none;
    }
    .mini:active{transform:translateY(1px);}

    /* overlay modal */
    .overlay{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      padding:16px;
      background:rgba(0,0,0,.55);
      z-index:100;
    }
    .overlay.show{display:flex;}
    .modal{
      width:min(520px,100%);
      background:#0b0f25;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:14px;
    }
    .modal h3{margin:0 0 8px; font-size:14px; letter-spacing:.08em; text-transform:uppercase;}
    .modal p{margin:0 0 10px; color:rgba(255,255,255,.78); font-size:13px; line-height:1.35;}
  </style>
</head>

<body>
<div class="wrap">
  <div class="app">
    <div class="top">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="title">GRIDRUN</div>
          <div class="subtitle">Dodge • Survive • Score</div>
        </div>
      </div>

      <div class="hud">
        <div class="pill"><span class="dot"></span>Mode: <b id="statMode">Menu</b></div>
        <div class="pill">Score: <b id="statScore">0</b></div>
        <div class="pill">Time: <b id="statTime">0.0</b>s</div>
        <div class="pill">Goal: <b id="statGoal">—</b></div>
      </div>
    </div>

    <div class="content">
      <!-- MAIN -->
      <div class="screen active" id="screenMain">
        <div class="panel">
          <div class="row">
            <button class="btn" id="goCampaign"><span><b>Campaign</b></span><span class="hint">worlds & levels</span></button>
            <button class="btn" id="goEndless"><span><b>Endless</b></span><span class="hint">infinite run</span></button>
          </div>
          <div class="divider"></div>
          <div class="row">
            <button class="btn" id="goLB"><span><b>Leaderboards</b></span><span class="hint">local</span></button>
            <button class="btn" id="resetSave"><span><b>Reset Save</b></span><span class="hint">local only</span></button>
          </div>

          <div class="note">
            <b>PC:</b> WASD / Arrow Keys • <b>Mobile:</b> drag anywhere to move (2D) • Tap <b>Pause</b> to stop.
            <br/>Campaign levels are cleared by meeting the <b>goal</b> shown before and during the run.
          </div>
        </div>
      </div>

      <!-- CAMPAIGN -->
      <div class="screen" id="screenCampaign">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Campaign</b> <span style="color:var(--muted); font-size:12px;" id="campProgress"></span></div>
            <button class="mini" id="backFromCampaign">Back</button>
          </div>
          <div class="divider"></div>
          <div id="campaignList"></div>
          <div class="note">
            Effects start at <b>30s</b>: glitch → scanlines → vertical lasers → invert.
            <br/>Each world has a theme; goals get tougher as you progress.
          </div>
        </div>
      </div>

      <!-- ENDLESS -->
      <div class="screen" id="screenEndless">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Endless</b> <span style="color:var(--muted); font-size:12px;">Starts at W1-L1 difficulty</span></div>
            <button class="mini" id="backFromEndless">Back</button>
          </div>
          <div class="divider"></div>
          <button class="btn" id="startEndless"><span><b>Start</b></span><span class="hint">go</span></button>
          <div class="note">Same scoring as Campaign, tracked separately.</div>
        </div>
      </div>

      <!-- LEADERBOARDS -->
      <div class="screen" id="screenLB">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div><b>Leaderboards</b> <span style="color:var(--muted); font-size:12px;">Local only</span></div>
            <button class="mini" id="backFromLB">Back</button>
          </div>
          <div class="divider"></div>
          <div class="row">
            <button class="btn" id="lbCamp"><span><b>Campaign</b></span><span class="hint">top</span></button>
            <button class="btn" id="lbEnd"><span><b>Endless</b></span><span class="hint">top</span></button>
          </div>
          <div class="divider"></div>
          <div id="lbList" class="note" style="margin-top:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono'; white-space:pre; overflow:auto; max-height:320px;"></div>
          <div class="divider"></div>
          <button class="btn" id="clearLB"><span><b>Clear Leaderboards</b></span><span class="hint">local</span></button>
        </div>
      </div>

      <!-- GAME -->
      <div class="screen" id="screenGame">
        <div class="panel">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div>
              <b id="runLabel">Run</b>
              <span class="tag" id="runThemeTag">—</span>
            </div>
            <div style="color:var(--muted); font-size:12px;" id="runHint">Drag (mobile) / WASD (PC)</div>
          </div>

          <div class="divider"></div>

          <div class="note" id="goalNote" style="margin-top:0;">
            <b>Goal:</b> — (shown here before you start)
          </div>

          <div class="divider"></div>

          <div class="gameWrap">
            <canvas id="game" width="720" height="1280"></canvas>
            <div class="controls">
              <button class="mini" id="pauseBtn">Pause</button>
              <button class="mini" id="restartBtn">Restart</button>
              <button class="mini" id="menuBtn">Menu</button>
            </div>
          </div>

          <div class="note">
            <b>PC:</b> WASD / Arrows • <b>Mobile:</b> drag anywhere (2D)
            <br/>Watch for effect shifts starting at <b>30s</b> (glitch/scanlines/lasers/invert).
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="overlay" id="overlay">
  <div class="modal">
    <h3 id="modalTitle">Paused</h3>
    <p id="modalText">Game paused.</p>
    <div class="row">
      <button class="btn" id="resumeBtn"><span><b>Resume</b></span><span class="hint"></span></button>
      <button class="btn" id="modalRestartBtn"><span><b>Restart</b></span><span class="hint"></span></button>
      <button class="btn" id="toMenuBtn"><span><b>Main Menu</b></span><span class="hint"></span></button>
    </div>
  </div>
</div>

<script>
(() => {
  // =========================
  // Stable UI + fixed Campaign indexing + effects/themes/goals
  // =========================

  const KEY_SAVE = "gridrun_save_stable_v2";
  const KEY_LB_C = "gridrun_lb_campaign_stable_v2";
  const KEY_LB_E = "gridrun_lb_endless_stable_v2";

  // World names + themes (you can edit these freely)
  const WORLDS = [
    { id: 1, name: "World 1: Neon Alley", theme: "Neon rain • tight dodges", levels: 5, tint: [110,231,255] },
    { id: 2, name: "World 2: Signal Ruins", theme: "Static haze • broken rhythm", levels: 5, tint: [183,255,110] },
    { id: 3, name: "World 3: Rift Sector", theme: "Warp spikes • unstable lanes", levels: 5, tint: [255,110,231] },
    { id: 4, name: "World 4: Overclock District", theme: "High heat • fast patterns", levels: 5, tint: [255,211,110] },
  ];
  const totalLevels = WORLDS.reduce((a,w)=>a+w.levels,0);

  const $ = (id) => document.getElementById(id);

  const screens = {
    main: $("screenMain"),
    campaign: $("screenCampaign"),
    endless: $("screenEndless"),
    lb: $("screenLB"),
    game: $("screenGame"),
  };

  function showScreen(name){
    Object.values(screens).forEach(s => s.classList.remove("active"));
    screens[name].classList.add("active");
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function clampInt(v,a,b){ v = (v|0); return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function loadJSON(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return fallback;
      const o = JSON.parse(raw);
      return o ?? fallback;
    }catch(_){ return fallback; }
  }
  function saveJSON(key, val){
    localStorage.setItem(key, JSON.stringify(val));
  }

  const defaultSave = () => ({
    unlocked: 1,      // linear unlock 1..totalLevels
    best: {}          // index -> best
  });

  let save = loadJSON(KEY_SAVE, defaultSave());
  save.unlocked = clampInt(save.unlocked, 1, totalLevels);

  function linearToWorldLevel(index){
    let acc = 0;
    for(const w of WORLDS){
      if(index <= acc + w.levels){
        return { worldId:w.id, worldName:w.name, theme:w.theme, tint:w.tint, level:index-acc, index };
      }
      acc += w.levels;
    }
    const w0 = WORLDS[0];
    return { worldId:w0.id, worldName:w0.name, theme:w0.theme, tint:w0.tint, level:1, index:1 };
  }

  // -------------------------
  // Completion goals
  // -------------------------
  // Campaign: both thresholds must be met (time AND score).
  // You can tweak these numbers later.
  function getCampaignGoal(levelIndex){
    // Increase requirements as you progress
    const baseTime = 18;                 // seconds
    const time = baseTime + Math.floor((levelIndex-1) * 1.5);   // ramps
    const baseScore = 500;
    const score = baseScore + Math.floor((levelIndex-1) * 90);  // ramps
    return { time, score };
  }

  // -------------------------
  // Leaderboards (local)
  // -------------------------
  function loadLB(mode){
    return loadJSON(mode === "campaign" ? KEY_LB_C : KEY_LB_E, []);
  }
  function saveLB(mode, arr){
    saveJSON(mode === "campaign" ? KEY_LB_C : KEY_LB_E, arr);
  }
  function addLB(mode, score, meta){
    const list = loadLB(mode);
    list.push({ name:"Runner", score:Math.floor(score), ts:Date.now(), meta: meta||{} });
    list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
    saveLB(mode, list.slice(0,10));
  }

  function renderLB(mode){
    const list = loadLB(mode);
    const lines = [];
    lines.push(mode.toUpperCase() + " TOP 10");
    lines.push("--------------------");
    if(!list.length){
      lines.push("No scores yet.");
    }else{
      list.slice(0,10).forEach((e,i)=>{
        lines.push(`${String(i+1).padStart(2," ")}. ${String(e.name).padEnd(8," ")}  ${String(e.score).padStart(8," ")}`);
      });
    }
    $("lbList").textContent = lines.join("\n");
  }

  // -------------------------
  // Campaign menu render (FIXED index bug)
  // -------------------------
  function renderCampaign(){
    $("campProgress").textContent = `Unlocked ${save.unlocked}/${totalLevels}`;

    const root = $("campaignList");
    root.innerHTML = "";

    let idx = 0;
    for(const w of WORLDS){
      const box = document.createElement("div");
      box.className = "note";
      box.style.marginTop = "10px";
      box.style.whiteSpace = "normal";

      box.innerHTML = `<b>${w.name}</b> <span class="tag">${w.theme}</span><div style="height:8px"></div>`;

      for(let l=1;l<=w.levels;l++){
        idx++;
        const levelIndex = idx; // ✅ CAPTURE HERE (fixes wrong world/level)
        const locked = levelIndex > save.unlocked;
        const best = save.best[String(levelIndex)] || 0;
        const goal = getCampaignGoal(levelIndex);

        const btn = document.createElement("button");
        btn.className = "btn";
        btn.disabled = locked;
        btn.innerHTML = `
          <span>
            <b>Level ${l}</b>
            <span class="hint">best ${best}</span>
            <span class="hint">• goal ${goal.time}s + ${goal.score} score</span>
          </span>
          <span class="hint">${locked?"locked":"start"}</span>
        `;
        btn.addEventListener("click", ()=> startCampaign(levelIndex), {passive:true});

        box.appendChild(btn);
        const spacer = document.createElement("div");
        spacer.style.height = "8px";
        box.appendChild(spacer);
      }

      root.appendChild(box);
    }
  }

  // =========================
  // GAME
  // =========================
  const canvas = $("game");
  const ctx = canvas.getContext("2d", { alpha:true });

  const state = {
    screen: "menu",
    mode: "endless",   // campaign|endless
    levelIndex: 1,

    running: false,
    paused: false,

    t: 0,
    score: 0,

    player: { x:0.5, y:0.8, r:18 },

    hazards: [],
    spawnAcc: 0,
    laserAcc: 0,

    // difficulty
    speed: 1.0,
    hazardRate: 1.0,

    // effects flags
    fx: {
      glitch:false,
      scanlines:false,
      lasers:false,
      invert:false,
      shake:0
    },

    worldTint: [110,231,255],
    worldName: "—",
    worldTheme: "—",
    goalTime: null,
    goalScore: null,
  };

  // Direct-follow (2D) target for mobile drag
  let dragging = false;
  const target = { x:0.5, y:0.8 };

  // Keyboard (PC) move
  const keys = new Set();
  window.addEventListener("keydown", (e)=>{ keys.add(e.key.toLowerCase()); });
  window.addEventListener("keyup", (e)=>{ keys.delete(e.key.toLowerCase()); });

  function getPointerNorm(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    const y = (e.clientY - r.top) / r.height;
    return {
      x: clamp(x, 0.06, 0.94),
      y: clamp(y, 0.10, 0.92),
    };
  }

  canvas.addEventListener("pointerdown", (e)=>{
    dragging = true;
    const p = getPointerNorm(e);
    target.x = p.x; target.y = p.y;
    canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointermove", (e)=>{
    if(!dragging) return;
    const p = getPointerNorm(e);
    target.x = p.x; target.y = p.y;
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointerup", (e)=>{
    dragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
  }, {passive:false});

  function bindTap(id, fn){
    const el = $(id);
    el.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); fn(); }, {passive:false});
    el.addEventListener("click",(e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  }

  const overlay = $("overlay");
  function setPaused(p){
    state.paused = p;
    overlay.classList.toggle("show", p);
    $("pauseBtn").textContent = p ? "Resume" : "Pause";
    $("modalTitle").textContent = p ? "Paused" : "Paused";
    $("modalText").textContent = `Score: ${Math.floor(state.score)} • Time: ${state.t.toFixed(1)}s`;
  }
  function togglePause(){
    if(!state.running) return;
    setPaused(!state.paused);
  }

  // Auto-pause when app loses focus (mobile stability)
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden && state.running && !state.paused) setPaused(true);
  }, {passive:true});
  window.addEventListener("blur", ()=>{
    if(state.running && !state.paused) setPaused(true);
  }, {passive:true});

  function setWorldFromLevelIndex(levelIndex){
    const wl = linearToWorldLevel(levelIndex);
    state.worldName = wl.worldName;
    state.worldTheme = wl.theme;
    state.worldTint = wl.tint;
    $("runThemeTag").textContent = wl.theme;
    return wl;
  }

  function updateGoalUI(){
    if(state.mode === "campaign"){
      $("statGoal").textContent = `${state.goalTime}s + ${state.goalScore}`;
      $("goalNote").innerHTML =
        `<b>Goal:</b> Survive <b>${state.goalTime}s</b> AND reach <b>${state.goalScore}</b> score.
         <br/><span style="color:rgba(255,255,255,.70)">Progress: time ${state.t.toFixed(1)} / ${state.goalTime}s • score ${Math.floor(state.score)} / ${state.goalScore}</span>`;
    } else {
      $("statGoal").textContent = "—";
      $("goalNote").innerHTML = `<b>Goal:</b> Endless (no completion) • survive as long as possible.`;
    }
  }

  function startEndless(){
    state.mode = "endless";
    state.levelIndex = 1;
    setWorldFromLevelIndex(1);
    state.goalTime = null;
    state.goalScore = null;
    startRun();
  }

  function startCampaign(levelIndex){
    state.mode = "campaign";
    state.levelIndex = levelIndex;

    const wl = setWorldFromLevelIndex(levelIndex);
    const goal = getCampaignGoal(levelIndex);
    state.goalTime = goal.time;
    state.goalScore = goal.score;

    startRun();
  }

  function startRun(){
    state.screen = "game";
    showScreen("game");

    state.running = true;
    state.paused = false;

    state.t = 0;
    state.score = 0;

    // baseline difficulty: campaign ramps slightly by level; endless baseline at W1-L1
    const bump = (state.mode === "campaign") ? (state.levelIndex - 1) * 0.04 : 0;
    state.speed = 1.0 + bump;
    state.hazardRate = 1.0 + bump;

    state.player.x = 0.5;
    state.player.y = 0.8;
    target.x = state.player.x;
    target.y = state.player.y;

    state.hazards.length = 0;
    state.spawnAcc = 0;
    state.laserAcc = 0;

    // reset effects
    state.fx.glitch = false;
    state.fx.scanlines = false;
    state.fx.lasers = false;
    state.fx.invert = false;
    state.fx.shake = 0;

    $("statMode").textContent = state.mode === "campaign" ? "Campaign" : "Endless";

    if(state.mode === "campaign"){
      const wl = linearToWorldLevel(state.levelIndex);
      $("runLabel").textContent = `Campaign • ${wl.worldName} • Level ${wl.level}`;
      $("runHint").textContent = `Goal: ${state.goalTime}s + ${state.goalScore} • Effects start at 30s`;
    } else {
      $("runLabel").textContent = "Endless";
      $("runHint").textContent = "Survive as long as possible • Effects start at 30s";
    }

    setPaused(false);
    updateGoalUI();
  }

  function goMenu(){
    state.running = false;
    state.paused = false;
    overlay.classList.remove("show");
    $("statMode").textContent = "Menu";
    $("statScore").textContent = "0";
    $("statTime").textContent = "0.0";
    $("statGoal").textContent = "—";
    showScreen("main");
  }

  function isCampaignComplete(){
    if(state.mode !== "campaign") return false;
    return (state.t >= state.goalTime) && (state.score >= state.goalScore);
  }

  function endRun(completed){
    state.running = false;
    setPaused(true);

    if(state.mode === "campaign"){
      const idx = String(state.levelIndex);
      const prev = save.best[idx] || 0;
      if(state.score > prev) save.best[idx] = Math.floor(state.score);

      if(completed){
        save.unlocked = clampInt(Math.max(save.unlocked, state.levelIndex + 1), 1, totalLevels);
      }
      saveJSON(KEY_SAVE, save);
      addLB("campaign", state.score, { levelIndex: state.levelIndex, completed: !!completed });
    } else {
      addLB("endless", state.score, {});
    }

    $("modalTitle").textContent = completed ? "Level Complete!" : "Run Over";
    $("modalText").textContent = `${completed ? "Completed the goal." : "You crashed."}  Score: ${Math.floor(state.score)} • Time: ${state.t.toFixed(1)}s`;
  }

  // -------------------------
  // Hazards
  // -------------------------
  function spawnBlock(){
    const w = rand(0.08, 0.16);
    return { kind:"block", x: rand(0.04, 0.96-w), y: -0.15, w, h: rand(0.05, 0.09), vy: rand(0.55, 0.85) };
  }

  function spawnVerticalLaser(){
    const w = rand(0.035, 0.06);
    const x = rand(0.08, 0.92 - w);
    return { kind:"vlaser", x, w, phase:"warn", t:0, warn:0.65, fire:0.55, fade:0.35 };
  }

  function rectOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // -------------------------
  // Effects schedule: starts at 30s
  // -------------------------
  function updateEffects(dt){
    const t = state.t;

    // ramps
    state.speed = clamp(state.speed + dt*0.004, 1.0, 3.0);
    state.hazardRate = clamp(state.hazardRate + dt*0.006, 1.0, 3.4);

    state.fx.glitch = (t >= 30);
    state.fx.scanlines = (t >= 42);
    state.fx.lasers = (t >= 55);
    state.fx.invert = (t >= 75);

    if(state.fx.glitch && (Math.floor(t*10) % 18 === 0)){
      state.fx.shake = Math.max(state.fx.shake, 6);
    }
    state.fx.shake *= Math.pow(0.02, dt);
  }

  // -------------------------
  // Loop
  // -------------------------
  let last = performance.now();
  function tick(now){
    requestAnimationFrame(tick);
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    $("statScore").textContent = String(Math.floor(state.score));
    $("statTime").textContent = state.t.toFixed(1);

    if(!state.running || state.paused){
      draw();
      return;
    }

    state.t += dt;

    // scoring baseline + slight ramp
    state.score += (25 + state.hazardRate*6) * dt;

    // effects + difficulty
    updateEffects(dt);

    // PC movement
    const sp = (0.85 + state.speed*0.10) * dt;
    if(keys.has("w") || keys.has("arrowup")) state.player.y -= sp;
    if(keys.has("s") || keys.has("arrowdown")) state.player.y += sp;
    if(keys.has("a") || keys.has("arrowleft")) state.player.x -= sp;
    if(keys.has("d") || keys.has("arrowright")) state.player.x += sp;

    // Mobile direct follow
    if(dragging){
      const follow = 1 - Math.pow(0.000001, dt);
      state.player.x += (target.x - state.player.x) * follow;
      state.player.y += (target.y - state.player.y) * follow;
    }

    state.player.x = clamp(state.player.x, 0.06, 0.94);
    state.player.y = clamp(state.player.y, 0.10, 0.92);

    // Spawn blocks
    state.spawnAcc += dt;
    const interval = clamp(0.55 / state.hazardRate, 0.20, 0.55);
    while(state.spawnAcc >= interval){
      state.spawnAcc -= interval;
      state.hazards.push(spawnBlock());
    }

    // Spawn lasers (vertical) when enabled
    if(state.fx.lasers){
      state.laserAcc += dt;
      const laserInterval = clamp(1.35 / (0.7 + state.hazardRate*0.25), 0.65, 1.35);
      if(state.laserAcc >= laserInterval){
        state.laserAcc = 0;
        state.hazards.push(spawnVerticalLaser());
      }
    }

    // Update hazards
    for(let i=state.hazards.length-1;i>=0;i--){
      const h = state.hazards[i];
      if(h.kind === "block"){
        h.y += h.vy * dt * state.speed;
        if(h.y > 1.2) state.hazards.splice(i,1);
      } else if(h.kind === "vlaser"){
        h.t += dt * state.speed;
        if(h.phase === "warn" && h.t >= h.warn){ h.phase="fire"; h.t=0; state.fx.shake = Math.max(state.fx.shake, 10); }
        else if(h.phase === "fire" && h.t >= h.fire){ h.phase="fade"; h.t=0; }
        else if(h.phase === "fade" && h.t >= h.fade){ state.hazards.splice(i,1); }
      }
    }

    // Update goal UI (live)
    updateGoalUI();

    // If campaign goal met, complete the level instantly (clean finish)
    if(isCampaignComplete()){
      endRun(true);
      draw();
      return;
    }

    // Collision
    const pr = state.player.r;
    const pRect = { x: state.player.x - pr/720, y: state.player.y - pr/1280, w:(pr*2)/720, h:(pr*2)/1280 };

    for(const h of state.hazards){
      if(h.kind === "block"){
        const r = { x:h.x, y:h.y, w:h.w, h:h.h };
        if(rectOverlap(pRect, r)){ endRun(false); break; }
      } else if(h.kind === "vlaser" && h.phase === "fire"){
        const r = { x:h.x, y:0, w:h.w, h:1 };
        if(rectOverlap(pRect, r)){ endRun(false); break; }
      }
    }

    draw();
  }

  // -------------------------
  // Draw
  // -------------------------
  function draw(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // themed background using world tint
    const [tr,tg,tb] = state.worldTint;
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, `rgba(${tr},${tg},${tb},0.14)`);
    g.addColorStop(0.35, "rgba(14,18,55,1)");
    g.addColorStop(1, "rgba(3,4,14,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // glitch shake
    const shake = Math.min(18, state.fx.shake);
    const sx = (Math.random()*2-1) * shake;
    const sy = (Math.random()*2-1) * shake;
    ctx.save();
    ctx.translate(sx, sy);

    // grid
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = "rgba(255,255,255,.7)";
    ctx.lineWidth = 1;
    for(let y=0;y<=H;y+=60){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    for(let x=0;x<=W;x+=60){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // hazards
    for(const h of state.hazards){
      if(h.kind === "block"){
        ctx.fillStyle = "rgba(255,110,231,0.85)";
        ctx.fillRect(h.x*W, h.y*H, h.w*W, h.h*H);
      } else if(h.kind === "vlaser"){
        const x = h.x*W, w = h.w*W;
        if(h.phase === "warn"){
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = "rgba(110,231,255,0.18)";
          ctx.fillRect(x,0,w,H);
          ctx.globalAlpha = 0.9;
          ctx.strokeStyle = "rgba(110,231,255,0.85)";
          ctx.setLineDash([12,10]);
          ctx.lineWidth = 4;
          ctx.beginPath(); ctx.moveTo(x+w/2,0); ctx.lineTo(x+w/2,H); ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
        } else if(h.phase === "fire"){
          ctx.fillStyle = "rgba(110,231,255,0.85)";
          ctx.fillRect(x,0,w,H);
        } else {
          const a = 1 - (h.t / h.fade);
          ctx.globalAlpha = a*0.8;
          ctx.fillStyle = "rgba(110,231,255,0.75)";
          ctx.fillRect(x,0,w,H);
          ctx.globalAlpha = 1;
        }
      }
    }

    // player
    const px = state.player.x * W;
    const py = state.player.y * H;
    const r = state.player.r;

    // glitch jitter (visual only)
    const jitter = (state.fx.glitch && state.running && !state.paused) ? rand(-3,3) : 0;
    ctx.translate(jitter, 0);

    ctx.shadowColor = "rgba(183,255,110,0.45)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(183,255,110,0.92)";
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.beginPath();
    ctx.arc(px, py, r*0.45, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fill();

    ctx.restore();

    // scanlines overlay
    if(state.fx.scanlines){
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      for(let y=0;y<H;y+=8) ctx.fillRect(0,y,W,1);
      ctx.restore();
    }

    // invert tint overlay (simple)
    if(state.fx.invert){
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }
  }

  // -------------------------
  // UI bindings
  // -------------------------
  $("goCampaign").addEventListener("click", ()=>{ renderCampaign(); showScreen("campaign"); }, {passive:true});
  $("goEndless").addEventListener("click", ()=> showScreen("endless"), {passive:true});
  $("goLB").addEventListener("click", ()=>{ renderLB("campaign"); showScreen("lb"); }, {passive:true});

  $("backFromCampaign").addEventListener("click", ()=> showScreen("main"), {passive:true});
  $("backFromEndless").addEventListener("click", ()=> showScreen("main"), {passive:true});
  $("backFromLB").addEventListener("click", ()=> showScreen("main"), {passive:true});

  $("startEndless").addEventListener("click", ()=> startEndless(), {passive:true});
  $("lbCamp").addEventListener("click", ()=> renderLB("campaign"), {passive:true});
  $("lbEnd").addEventListener("click", ()=> renderLB("endless"), {passive:true});

  $("clearLB").addEventListener("click", ()=>{
    if(confirm("Clear local leaderboards?")){
      saveLB("campaign", []);
      saveLB("endless", []);
      renderLB("campaign");
    }
  }, {passive:true});

  $("resetSave").addEventListener("click", ()=>{
    if(confirm("Reset local save + best scores?")){
      save = defaultSave();
      saveJSON(KEY_SAVE, save);
      alert("Save reset.");
    }
  }, {passive:true});

  // game buttons (robust tap)
  bindTap("pauseBtn", ()=> togglePause());
  bindTap("restartBtn", ()=> startRun());
  bindTap("menuBtn", ()=> goMenu());

  bindTap("resumeBtn", ()=> setPaused(false));
  bindTap("modalRestartBtn", ()=> startRun());
  bindTap("toMenuBtn", ()=> goMenu());

  // Init
  showScreen("main");
  renderLB("campaign");
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
