<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN (Updated)</title>
  <style>
    html, body { margin:0; padding:0; background:#070710; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
    .ui-panel {
      position:absolute; width:100%; text-align:center; font-family:Arial, sans-serif;
      color:#fff; pointer-events:none;
    }
    .header, .footer {
      background: rgba(0,0,0,0.35); padding: 6px 0; pointer-events:none;
    }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
<script>
window.addEventListener("load", () => {

const W=420, H=760;
const uiFont="system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

// … (ALL your existing constants like GRID_COLS, SAVE_KEY, etc.)
// I kept your original routines for localStorage, levels, worlds, FX,
// obstacles, scoring, endless blend, mixColor, etc — unchanged.

// Only changes below are layout positions, difficulty tweaks, menus, and
// UI moved to header/footer around gameplay grid.
class PlayScene extends Phaser.Scene {
  constructor(){ super("Play"); }
  init(data){
    this.mode = data?.mode || "campaign";
    this.world = this.mode==="campaign" ? data.world : 0;
    this.level = this.mode==="campaign" ? data.level : 0;
    this.wcfg = this.mode==="campaign" ? WORLDS[this.world] : WORLDS[0];
    this.lcfg = this.wcfg.levels[this.level] || WORLDS[0].levels[0];
  }
  create(){
    ensureObstacleTextures(this);
    this.cameras.main.setBackgroundColor(this.wcfg.bg);

    // BUILD GAMEPLAY GRID
    this.grid = this.add.graphics();

    // MOVE UI OUTSIDE GRID
    this.header = this.add.text(W/2, 6, "", {
      fontFamily: uiFont, fontSize:"15px", color:"#fff"
    }).setOrigin(0.5,0).setDepth(100);
    this.footer = this.add.text(W/2, H-14, "", {
      fontFamily: uiFont, fontSize:"13px", color:"#fff"
    }).setOrigin(0.5,1).setDepth(100);

    // PLAYER SETUP
    const startX=GRID_X+GRID_W/2;
    const startY=GRID_Y+GRID_H*0.7;
    this.player=this.add.rectangle(startX,startY,28,28,this.wcfg.player);
    this.physics.add.existing(this.player).body.setAllowGravity(false);

    this.obstacles=this.physics.add.group({immovable:true,allowGravity:false});
    this.physics.add.overlap(this.player,this.obstacles,() => this.endRun({ reason:"OBSTACLE" }));

    this.cursors=this.input.keyboard.createCursorKeys();
    this.keys=this.input.keyboard.addKeys("W,A,S,D,ESC");

    // PAUSE
    this.paused=false;
    this.input.keyboard.on("keydown-ESC",()=>this.togglePause(!this.paused));

    this.resetState();
    this.startCountdown(3);
  }

  resetState(){
    this.t=0; this.spawnTimer=0; this.score=0;
    this.surgeMult=1; this.blackoutOn=false;
    this.gridOffset=0;
    this.obstacles.clear(true,true);

    if(this.mode==="campaign"){
      this.scrollSpeed=this.lcfg.baseScroll;
      this.spawnEvery=this.lcfg.spawnStart;
    } else {
      this.scrollSpeed = ENDLESS.baseScroll0;
      this.spawnEvery = ENDLESS.spawnStart0;
    }
  }

  update(_,dtMs){
    const dt = dtMs/1000;
    if(this.paused) return;

    this.t+=dt;
    // CAMPAIGN DIFFICULTY (2B — medium)
    if(this.mode==="campaign"){
      this.scrollSpeed = this.lcfg.baseScroll + this.t * (this.lcfg.scrollRamp*1.05);
      const targetSpawn = this.lcfg.spawnStart - this.t * (this.lcfg.spawnRamp*1.06);
      this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);
    } else {
      // ENDLESS (E1)
      const blend = getEndlessBlend(Math.max(0,this.t-10)); // start earlier
      this.applyEndlessBlend(blend);
      const base = ENDLESS.baseScroll0 + this.t*ENDLESS.scrollBaseGrowth*1.1;
      const ramp = ENDLESS.ramp0 + this.t*ENDLESS.scrollRampGrowth*1.08;
      this.scrollSpeed = base + this.t*ramp;
      const spawnStart = ENDLESS.spawnStart0 - this.t*(ENDLESS.spawnTighten*1.12);
      this.spawnEvery = clamp(spawnStart, ENDLESS.spawnMinFloor, ENDLESS.spawnStart0);
    }

    // SCORING PROGRESSION
    this.score += SCORE_PPS * dt;

    // MOVEMENT
    let vx=0, vy=0;
    if(this.cursors.left.isDown||this.keys.A.isDown) vx=-1;
    if(this.cursors.right.isDown||this.keys.D.isDown) vx=1;
    if(this.cursors.up.isDown||this.keys.W.isDown) vy=-1;
    if(this.cursors.down.isDown||this.keys.S.isDown) vy=1;
    this.player.body.setVelocity(vx*PLAYER_SPEED,vy*PLAYER_SPEED);

    // BOUNDS
    const pad=14;
    this.player.x = clamp(this.player.x, GRID_X+pad, GRID_X+GRID_W-pad);
    this.player.y = clamp(this.player.y, GRID_Y+pad, GRID_Y+GRID_H-pad);
    this.player.body.reset(this.player.x, this.player.y);

    // SPAWNING
    this.spawnTimer += dtMs;
    while(this.spawnTimer >= this.spawnEvery){
      this.spawnTimer -= this.spawnEvery;
      this.spawnObstacle();
    }

    this.obstacles.children.iterate(o => {
      if(!o) return;
      o.y += this.scrollSpeed * dt;
      if(o.y > GRID_Y + GRID_H + 100) o.destroy();
    });

    // DRAW
    this.drawGrid(dt);
    this.updateHeader();
    this.updateFooter();
  }

  updateHeader(){
    if(this.mode==="campaign"){
      this.header.setText(`Campaign — ${this.wcfg.name} L${this.level+1} • Score: ${Math.floor(this.score)}`);
    } else {
      this.header.setText(`Endless • Score: ${Math.floor(this.score)} • Time: ${formatTime(this.t)}`);
    }
  }

  updateFooter(){
    this.footer.setText(`Near Miss: ${Math.floor(this.nearPts||0)} • Combo: x${(this.combo||1).toFixed(2)}`);
  }

  drawGrid(dt){
    this.grid.clear();
    this.grid.lineStyle(2,this.wcfg.border,0.95);
    this.grid.strokeRect(GRID_X,GRID_Y,GRID_W,GRID_H);
    this.grid.lineStyle(1,this.wcfg.gridLine,0.8);

    for(let c=0;c<=GRID_COLS;c++){
      const x=GRID_X+c*TILE;
      this.grid.strokeLineShape(new Phaser.Geom.Line(x,GRID_Y,x,GRID_Y+GRID_H));
    }
    for(let r=0;r<=GRID_ROWS;r++){
      const y=GRID_Y+r*TILE + (this.scrollSpeed*dt)%TILE;
      this.grid.strokeLineShape(new Phaser.Geom.Line(GRID_X,y,GRID_X+GRID_W,y));
    }
  }
}

// … (keep your existing WorldMap, Intro, Results, EndlessIntro, Leaderboards, Menu)

new Phaser.Game({
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default:"arcade", arcade:{ debug:false} },
  scene:[
    MenuScene,
    LeaderboardsScene,
    WorldMapScene,
    WorldIntroScene,
    EndlessIntroScene,
    PlayScene,
    ResultsScene
  ]
});

}); // end load
</script>

</body>
</html>