<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN</title>
  <style>
    html, body { margin:0; padding:0; background:#070710; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

<script>
window.addEventListener("load", () => {
  const wait = setInterval(() => {
    if (typeof window.Phaser === "undefined") return;
    clearInterval(wait);

    const W = 420, H = 760;
    const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

    // ===== GRID =====
    const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
    const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
    const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

    // ===== Movement =====
    const PLAYER_SPEED = 320;
    const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
    const FOLLOW_RADIUS = 7;
    const FOLLOW_LERP = 0.40;
    const FOLLOW_MAX_SPEED_MULT = 3.0;

    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a,b,t) => a + (b-a)*t;

    // ===== DIFFICULTY SANITY (speed down, spawns stay) =====
    const DIFF = {
      scrollMult: 0.88,   // slower overall
      rampMult:   0.70,   // MUCH less ramp growth
      maxScroll:  165,    // hard cap so it never becomes unplayable
      rampCapFrac: 0.60   // stop increasing speed after 60% of level time
    };

    // ===== Storage =====
    const SAVE_KEY = "gridrun_progress_v7";
    const LEADER_KEY = "gridrun_leaderboards_v3";

    const LEVELS_PER_WORLD = 5;
    const WORLDS_COUNT = 3;
    const TOTAL_LEVELS = WORLDS_COUNT * LEVELS_PER_WORLD;

    function levelId(world, level) { return world * LEVELS_PER_WORLD + level; }

    function loadProgress() {
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) {
          return {
            unlockedWorld: 0, unlockedLevel: 0,
            currentWorld: 0, currentLevel: 0,
            levelBest: Array(TOTAL_LEVELS).fill(0)
          };
        }
        const p = JSON.parse(raw);
        const levelBest = Array.isArray(p.levelBest) ? p.levelBest.map(x => Math.max(0, Math.floor(x||0))) : Array(TOTAL_LEVELS).fill(0);
        while (levelBest.length < TOTAL_LEVELS) levelBest.push(0);
        return {
          unlockedWorld: Number.isFinite(p.unlockedWorld) ? clamp(p.unlockedWorld, 0, WORLDS_COUNT-1) : 0,
          unlockedLevel: Number.isFinite(p.unlockedLevel) ? clamp(p.unlockedLevel, 0, LEVELS_PER_WORLD-1) : 0,
          currentWorld: Number.isFinite(p.currentWorld) ? clamp(p.currentWorld, 0, WORLDS_COUNT-1) : 0,
          currentLevel: Number.isFinite(p.currentLevel) ? clamp(p.currentLevel, 0, LEVELS_PER_WORLD-1) : 0,
          levelBest
        };
      } catch {
        return { unlockedWorld:0, unlockedLevel:0, currentWorld:0, currentLevel:0, levelBest: Array(TOTAL_LEVELS).fill(0) };
      }
    }
    function saveProgress(p) { localStorage.setItem(SAVE_KEY, JSON.stringify(p)); }
    function resetAllSaves() {
      localStorage.removeItem(SAVE_KEY);
      localStorage.removeItem(LEADER_KEY);
    }

    function campaignTotalScore(p) { return p.levelBest.reduce((a,b)=>a+b, 0); }
    function worldSubtotal(p, world) {
      const start = world * LEVELS_PER_WORLD;
      let sum = 0;
      for (let i=0;i<LEVELS_PER_WORLD;i++) sum += (p.levelBest[start+i]||0);
      return sum;
    }
    function isLevelUnlocked(p, world, level) {
      if (world < p.unlockedWorld) return true;
      if (world > p.unlockedWorld) return false;
      return level <= p.unlockedLevel;
    }

    // ===== Leaderboards (local) =====
    function loadLeaderboards() {
      try {
        const raw = localStorage.getItem(LEADER_KEY);
        if (!raw) return { campaignTop: [], endlessTop: [] };
        const lb = JSON.parse(raw);
        const normalize = (arr) => (Array.isArray(arr) ? arr : [])
          .map(x => ({ score: Math.max(0, Math.floor(x?.score||0)), meta: x?.meta || "" }))
          .sort((a,b)=>b.score-a.score)
          .slice(0,10);
        return { campaignTop: normalize(lb.campaignTop), endlessTop: normalize(lb.endlessTop) };
      } catch {
        return { campaignTop: [], endlessTop: [] };
      }
    }
    function saveLeaderboards(lb) { localStorage.setItem(LEADER_KEY, JSON.stringify(lb)); }
    function maybeInsertTop(list, entry) {
      const next = [...list, entry].sort((a,b)=>b.score-a.score).slice(0,10);
      return next;
    }

    // ===== UI helpers =====
    function addTitle(scene, text, yFrac = 0.22, size = 40) {
      return scene.add.text(W/2, H*yFrac, text, {
        fontFamily: uiFont, fontSize: `${size}px`, color: "#ffffff",
      }).setOrigin(0.5).setAlpha(0.98);
    }
    function addSubtitle(scene, text, yFrac = 0.28) {
      return scene.add.text(W/2, H*yFrac, text, {
        fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff",
      }).setOrigin(0.5).setAlpha(0.92);
    }
    function makeButton(scene, label, x, y, onClick, accent="#6ef3ff") {
      const btn = scene.add.text(x, y, label, {
        fontFamily: uiFont,
        fontSize: "18px",
        color: "#0a0a12",
        backgroundColor: accent,
        padding: { left: 18, right: 18, top: 10, bottom: 10 },
      }).setOrigin(0.5).setInteractive({ useHandCursor: true });

      btn.on("pointerdown", onClick);
      btn.on("pointerover", () => btn.setAlpha(0.92));
      btn.on("pointerout", () => btn.setAlpha(1));
      return btn;
    }
    function makeGhostButton(scene, label, x, y, onClick) {
      const btn = scene.add.text(x, y, label, {
        fontFamily: uiFont,
        fontSize: "16px",
        color: "#ffffff",
        backgroundColor: "rgba(255,255,255,0.10)",
        padding: { left: 16, right: 16, top: 10, bottom: 10 },
      }).setOrigin(0.5).setInteractive({ useHandCursor: true });

      btn.on("pointerdown", onClick);
      btn.on("pointerover", () => btn.setAlpha(0.85));
      btn.on("pointerout", () => btn.setAlpha(1));
      return btn;
    }

    // ===== Level durations (campaign) =====
    // Slightly friendlier early, longer later, but not exhausting.
    const DUR = [26, 30, 34, 40, 46];

    // ===== New scoring system (balanced) =====
    // Base survival is lower than before so Gold isn't automatic.
    const SCORE_PPS = 7.2;          // was 12
    const CLEAN_TICK_SEC = 4.0;     // every 4s clean: +bonus
    const CLEAN_BONUS = 28;         // reliable “good play” points

    // Precision: reward controlled movement near "lane centers"
    const PRECISION_RADIUS = 14;    // px from a tile center qualifies
    const PRECISION_PPS = 1.6;      // extra points/sec when precise

    // Dodge + Near-miss: safer option + style option
    const DODGE_DIST = 52;          // generous, achievable
    const DODGE_POINTS = 10;        // small, consistent
    const NEAR_DIST = 30;           // tighter
    const NEAR_POINTS = 22;         // style bonus, not mandatory

    // Combo: grows with dodge/near
    const COMBO_DECAY_SEC = 1.6;
    const COMBO_STEP_DODGE = 0.06;
    const COMBO_STEP_NEAR  = 0.10;
    const COMBO_MAX = 2.30;

    // Campaign clear bonus (kept modest)
    const LEVEL_CLEAR_BONUS = 130;

    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return m > 0 ? `${m}:${String(s).padStart(2,"0")}` : `${s}s`;
    }

    // ===== Tier targets (Bronze/Silver/Gold) =====
    // Dynamic targets based on world/level and duration.
    function tierTargetsFor(world, level, seconds) {
      // Baseline expected score if you just survive + a bit of clean play
      const base = seconds * SCORE_PPS;

      // Difficulty scaling
      const d = 1 + world*0.32 + level*0.12;

      // Targets push players to use SOME bonuses, but not suicidal near-miss.
      const bronze = Math.floor(base * (1.35 * d));
      const silver = Math.floor(base * (1.70 * d));
      const gold   = Math.floor(base * (2.05 * d));

      return { bronze, silver, gold };
    }

    // ===== Worlds (more vibrant + different) =====
    // NOTE: Speeds are now reasonable; hazards/patterns add difficulty.
    function mkLevels(cfg) {
      return DUR.map((seconds, i) => ({
        seconds,

        // speed (reasonable)
        baseScroll: (cfg.baseScroll0 + cfg.baseScrollStep * i),
        scrollRamp: (cfg.ramp0 + cfg.rampStep * i),

        // spawns (pressure)
        spawnStart: (cfg.spawnStart0 - cfg.spawnStep * i),
        spawnRamp:  (cfg.spawnRamp0 + cfg.spawnRampStep * i),
        spawnMin: Math.max(cfg.spawnMinFloor, cfg.spawnMin0 - cfg.spawnMinStep * i),

        // sizes
        size: [cfg.sizeMin0 - cfg.sizeMinStep*i, cfg.sizeMax0 - cfg.sizeMaxStep*i],

        // hazards per level (difficulty through mechanics, not speed)
        haz: cfg.hazByLevel?.[i] || {}
      }));
    }

    const WORLDS = [
      {
        id: 0,
        name: "Neon Bliss",
        subtitle: "Bright neon lanes • Learn the flow • Clean dodges win",
        bg: 0x0a0620,
        border: 0xff4dff,
        gridLine: 0x3a1a6a,
        player: 0x6ef3ff,
        fx: "neon",
        gridStyle: "neon",
        obstacleStyle: { palette: [0xff4d7d, 0x6ef3ff, 0xffd166], shapes: ["tri","hex","frame","rect"] },
        levels: mkLevels({
          baseScroll0: 76, baseScrollStep: 4.0,
          ramp0: 6.2, rampStep: 0.55,
          spawnStart0: 980, spawnStep: 95,
          spawnRamp0: 9.0, spawnRampStep: 0.8,
          spawnMin0: 520, spawnMinStep: 40,
          spawnMinFloor: 320,
          sizeMin0: 22, sizeMinStep: 0,
          sizeMax0: 34, sizeMaxStep: 1,
          hazByLevel: [
            { laneLock:false, blink:false },
            { laneLock:false, blink:false },
            { laneLock:true,  blink:false }, // introduce lane lock
            { laneLock:true,  blink:false },
            { laneLock:true,  blink:true }   // light blink on W1L5
          ]
        })
      },
      {
        id: 1,
        name: "Techno Abyss",
        subtitle: "Cold electric pressure • More overlap patterns • Stay precise",
        bg: 0x03101a,
        border: 0x7cffd2,
        gridLine: 0x0e3c48,
        player: 0xb7b7ff,
        fx: "pulse",
        gridStyle: "pulse",
        obstacleStyle: { palette: [0x7cffd2, 0xb7b7ff, 0xffffff, 0xffd166], shapes: ["bar","plus","rect","frame","hex"] },
        levels: mkLevels({
          // IMPORTANT: W2L1 < W1L5 (smooth transition)
          baseScroll0: 90, baseScrollStep: 4.2,
          ramp0: 6.8, rampStep: 0.60,
          spawnStart0: 930, spawnStep: 100,
          spawnRamp0: 9.6, spawnRampStep: 0.95,
          spawnMin0: 500, spawnMinStep: 42,
          spawnMinFloor: 300,
          sizeMin0: 21, sizeMinStep: 0,
          sizeMax0: 33, sizeMaxStep: 1,
          hazByLevel: [
            { laneLock:true, blink:false },
            { laneLock:true, blink:true },
            { laneLock:true, blink:true },
            { laneLock:true, blink:true },
            { laneLock:true, blink:true }
          ]
        })
      },
      {
        id: 2,
        name: "Astral Surge",
        subtitle: "Galaxy distortion • Visibility threats • Lasers awaken",
        bg: 0x05021a,
        border: 0x9cff57,
        gridLine: 0x2a1f66,
        player: 0xffb0ff,
        fx: "stars",
        gridStyle: "astral",
        obstacleStyle: { palette: [0xffb0ff, 0x9cff57, 0x6ef3ff, 0xff4d7d], shapes: ["hex","tri","bar","frame","plus"] },
        levels: mkLevels({
          baseScroll0: 104, baseScrollStep: 4.6,
          ramp0: 7.2, rampStep: 0.65,
          spawnStart0: 900, spawnStep: 105,
          spawnRamp0: 10.2, spawnRampStep: 1.05,
          spawnMin0: 480, spawnMinStep: 45,
          spawnMinFloor: 280,
          sizeMin0: 20, sizeMinStep: 0,
          sizeMax0: 32, sizeMaxStep: 1,
          hazByLevel: [
            { laneLock:true, blink:true, blackout:false, lasers:"warn" },
            { laneLock:true, blink:true, blackout:true,  lasers:"warn" },
            { laneLock:true, blink:true, blackout:true,  lasers:"active" },
            { laneLock:true, blink:true, blackout:true,  lasers:"active" },
            { laneLock:true, blink:true, blackout:true,  lasers:"active" }
          ]
        }),
        boss: {
          enabled: true,
          cycleSeconds: 6.0,
          warnSeconds: 1.25,
          activeSeconds: 1.10,
          thickness: 16,
          warnThickness: 6
        }
      }
    ];

    // ===== FX =====
    function buildBackdrop(scene, fxType, colorA, colorB) {
      const items = [];

      if (fxType === "neon") {
        const g = scene.add.graphics().setAlpha(0.14);
        // soft diagonal neon glow bands
        scene.events.on("update", (_, dtMs) => {
          const t = (scene._fxT = (scene._fxT || 0) + dtMs/1000);
          g.clear();
          g.fillStyle(colorA, 0.10);
          g.fillRect(-40, H*0.10 + 22*Math.sin(t*0.8), W+80, 120);
          g.fillStyle(0xff4d7d, 0.07);
          g.fillRect(-40, H*0.62 + 22*Math.sin(t*0.7+1.6), W+80, 120);
        });
        items.push(g);
      }

      if (fxType === "pulse") {
        const rings = [];
        for (let i=0;i<3;i++){
          const c = scene.add.circle(W/2, H/2, 120 + i*70, colorB, 0).setStrokeStyle(2, colorB, 0.10);
          rings.push(c);
        }
        scene.events.on("update", (_, dtMs) => {
          const t = (scene._fxT = (scene._fxT || 0) + dtMs/1000);
          rings.forEach((r, i) => {
            r.setScale(1.0 + 0.06*Math.sin(t*0.9 + i));
            r.setAlpha(0.10 + 0.05*Math.sin(t*0.7 + i*1.3));
          });
        });
        items.push(...rings);
      }

      if (fxType === "stars") {
        const stars = [];
        for (let i = 0; i < 70; i++) {
          const s = scene.add.rectangle(
            Phaser.Math.Between(0, W),
            Phaser.Math.Between(0, H),
            2, 2, colorA
          ).setAlpha(Phaser.Math.FloatBetween(0.06, 0.30));
          s._vy = Phaser.Math.FloatBetween(10, 52);
          stars.push(s);
        }
        scene.events.on("update", (_, dtMs) => {
          const dt = dtMs / 1000;
          for (const s of stars) {
            s.y += s._vy * dt;
            if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
          }
        });
        items.push(...stars);
      }

      return items;
    }

    // ===== Obstacle textures =====
    function ensureObstacleTextures(scene) {
      const makeTex = (key, drawFn) => {
        if (scene.textures.exists(key)) return;
        const g = scene.make.graphics({ x:0, y:0, add:false });
        g.clear();
        drawFn(g);
        g.generateTexture(key, 64, 64);
        g.destroy();
      };

      makeTex("obs_rect", (g) => {
        g.fillStyle(0xffffff, 1);
        g.fillRoundedRect(8, 8, 48, 48, 10);
      });
      makeTex("obs_frame", (g) => {
        g.lineStyle(6, 0xffffff, 1);
        g.strokeRoundedRect(10, 10, 44, 44, 10);
        g.lineStyle(2, 0xffffff, 0.7);
        g.strokeRoundedRect(16, 16, 32, 32, 8);
      });
      makeTex("obs_tri", (g) => {
        g.fillStyle(0xffffff, 1);
        g.beginPath();
        g.moveTo(32, 8);
        g.lineTo(56, 56);
        g.lineTo(8, 56);
        g.closePath();
        g.fillPath();
        g.lineStyle(2, 0xffffff, 0.35);
        g.strokePath();
      });
      makeTex("obs_hex", (g) => {
        g.fillStyle(0xffffff, 1);
        const pts = [
          {x:32,y:6},{x:54,y:18},{x:54,y:46},{x:32,y:58},{x:10,y:46},{x:10,y:18}
        ];
        g.beginPath();
        g.moveTo(pts[0].x, pts[0].y);
        for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
        g.closePath(); g.fillPath();
        g.lineStyle(2, 0xffffff, 0.35);
        g.strokePath();
      });
      makeTex("obs_bar", (g) => {
        g.fillStyle(0xffffff, 1);
        g.fillRoundedRect(6, 24, 52, 16, 8);
        g.lineStyle(2, 0xffffff, 0.35);
        g.strokeRoundedRect(6, 24, 52, 16, 8);
      });
      makeTex("obs_plus", (g) => {
        g.fillStyle(0xffffff, 1);
        g.fillRoundedRect(26, 10, 12, 44, 5);
        g.fillRoundedRect(10, 26, 44, 12, 5);
        g.lineStyle(2, 0xffffff, 0.35);
        g.strokeRoundedRect(26, 10, 12, 44, 5);
        g.strokeRoundedRect(10, 26, 44, 12, 5);
      });
    }

    const shapeToTex = {
      rect: "obs_rect",
      frame: "obs_frame",
      tri: "obs_tri",
      hex: "obs_hex",
      bar: "obs_bar",
      plus: "obs_plus"
    };

    // ===== Endless model: ramps to W3L5 then plateaus =====
    // We'll blend difficulty over time, but keep speed capped and readable.
    const ENDLESS = {
      // start = W1L1 equivalent
      baseScroll0: WORLDS[0].levels[0].baseScroll,
      ramp0: WORLDS[0].levels[0].scrollRamp,
      spawnStart0: WORLDS[0].levels[0].spawnStart,
      spawnRamp0: WORLDS[0].levels[0].spawnRamp,
      spawnMinFloor: 280,

      // reach W3L5 around 150s then plateau
      rampToMaxSec: 150,

      // Hazards schedule
      t_laneLock: 20,
      t_blink: 45,
      t_blackout: 70,
      t_laserWarn: 95,
      t_laserActive: 125
    };

    function lerpCfg(a,b,t){
      return a + (b-a)*t;
    }

    function getEndlessDifficulty(t){
      const t01 = clamp(t / ENDLESS.rampToMaxSec, 0, 1);

      const start = WORLDS[0].levels[0];
      const end   = WORLDS[2].levels[4]; // W3L5

      const baseScroll = lerpCfg(start.baseScroll, end.baseScroll, t01);
      const scrollRamp = lerpCfg(start.scrollRamp, end.scrollRamp, t01);

      const spawnStart = lerpCfg(start.spawnStart, end.spawnStart, t01);
      const spawnRamp  = lerpCfg(start.spawnRamp,  end.spawnRamp,  t01);
      const spawnMin   = lerpCfg(start.spawnMin,   end.spawnMin,   t01);

      // hazards ramp
      const haz = {
        laneLock: t >= ENDLESS.t_laneLock,
        blink:    t >= ENDLESS.t_blink,
        blackout: t >= ENDLESS.t_blackout,
        lasers:   (t >= ENDLESS.t_laserWarn) ? (t >= ENDLESS.t_laserActive ? "active" : "warn") : "off"
      };

      return { baseScroll, scrollRamp, spawnStart, spawnRamp, spawnMin, haz, t01 };
    }

    // ===== Blackout pulse =====
    const BLACKOUT = { period: 10.5, active: 0.75, alpha: 0.35 };

    // ===== Surge window (kept mild) =====
    const SURGE = { period: 10.0, active: 1.1, mult: 1.14 };

    // ===== Scenes =====
    class MenuScene extends Phaser.Scene {
      constructor() { super("Menu"); }
      create() {
        this.cameras.main.setBackgroundColor(0x070710);

        buildBackdrop(this, "neon", 0x6ef3ff, 0xff4d7d);

        const title = this.add.text(W/2, H*0.18, "GRIDRUN", {
          fontFamily: uiFont, fontSize: "54px", color: "#ffffff"
        }).setOrigin(0.5).setAlpha(0.98);

        makeButton(this, "PLAY", W/2, H*0.44, () => this.scene.start("ModeSelect"), "#6ef3ff");
        makeGhostButton(this, "LEADERBOARDS", W/2, H*0.56, () => this.scene.start("Leaderboards"))
          .setStyle({ backgroundColor:"rgba(255,176,255,0.22)" });
        makeGhostButton(this, "RESET SAVES", W/2, H*0.68, () => { resetAllSaves(); this.scene.restart(); })
          .setStyle({ backgroundColor:"rgba(255,209,102,0.22)" }).setAlpha(0.9);

        const p = loadProgress();
        this.add.text(W/2, H*0.86, `Campaign Total: ${campaignTotalScore(p)}`, {
          fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.75)"
        }).setOrigin(0.5);

        this.add.text(W/2, H*0.92, "Gameplay: grid-only screen during play. Pause is in HUD bar.", {
          fontFamily: uiFont, fontSize:"11px", color:"rgba(255,255,255,0.55)"
        }).setOrigin(0.5);

        this.t = 0;
        this.events.on("update", (_, dtMs) => {
          this.t += dtMs/1000;
          title.setAlpha(0.92 + 0.06*Math.sin(this.t*1.1));
        });
      }
    }

    class ModeSelectScene extends Phaser.Scene {
      constructor(){ super("ModeSelect"); }
      create(){
        this.cameras.main.setBackgroundColor(0x070710);
        addTitle(this, "PLAY", 0.16, 40);
        addSubtitle(this, "Choose a mode", 0.22);

        makeButton(this, "CAMPAIGN", W/2, H*0.44, () => this.scene.start("WorldMap"), "#6ef3ff");
        makeButton(this, "ENDLESS", W/2, H*0.54, () => this.scene.start("EndlessIntro"), "#7cffd2");
        makeGhostButton(this, "BACK", W/2, H*0.70, () => this.scene.start("Menu"));
      }
    }

    class LeaderboardsScene extends Phaser.Scene {
      constructor() { super("Leaderboards"); }
      create() {
        this.cameras.main.setBackgroundColor(0x070710);
        addTitle(this, "LEADERBOARDS", 0.14, 32);
        addSubtitle(this, "Local device scores (global later)", 0.20);

        const p = loadProgress();
        const lb = loadLeaderboards();

        const campaignNow = campaignTotalScore(p);
        const endlessBest = lb.endlessTop[0]?.score || 0;

        this.add.text(W/2, H*0.27, `Your Campaign Total: ${campaignNow}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
          .setOrigin(0.5).setAlpha(0.9);

        this.add.text(W/2, H*0.31, `Your Endless Best: ${endlessBest}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
          .setOrigin(0.5).setAlpha(0.85);

        const drawList = (title, arr, x, y) => {
          this.add.text(x, y, title, { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" }).setOrigin(0,0);
          let yy = y + 18;
          if (!arr.length) {
            this.add.text(x, yy, "— none yet —", { fontFamily: uiFont, fontSize:"12px", color:"rgba(255,255,255,0.55)" }).setOrigin(0,0);
            return;
          }
          arr.forEach((e, i) => {
            this.add.text(x, yy, `${i+1}. ${e.score}`, { fontFamily: uiFont, fontSize:"12px", color:"#ffffff" })
              .setOrigin(0,0).setAlpha(0.9);
            if (e.meta) {
              this.add.text(x+70, yy, e.meta, { fontFamily: uiFont, fontSize:"11px", color:"rgba(255,255,255,0.55)" })
                .setOrigin(0,0);
            }
            yy += 18;
          });
        };

        drawList("Campaign Total Top 10", lb.campaignTop, 34, H*0.38);
        drawList("Endless Top 10", lb.endlessTop, 240, H*0.38);

        makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
      }
    }

    class WorldMapScene extends Phaser.Scene {
      constructor() { super("WorldMap"); }
      create() {
        const p = loadProgress();
        this.cameras.main.setBackgroundColor(0x070710);

        addTitle(this, "CAMPAIGN", 0.14, 34);
        addSubtitle(this, "Replay unlocked levels • Beat levels to unlock next", 0.20);

        const total = campaignTotalScore(p);
        this.add.text(W/2, H*0.24, `Campaign Total: ${total}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
          .setOrigin(0.5).setAlpha(0.85);

        const marginX = 18;
        const colW = (W - marginX*2);
        let y = H*0.28;

        WORLDS.forEach((w, wi) => {
          const unlockedWorld = wi <= p.unlockedWorld;

          const sub = worldSubtotal(p, wi);
          this.add.text(marginX, y, `${wi+1}. ${w.name}`, {
            fontFamily: uiFont, fontSize: "16px",
            color: unlockedWorld ? "#ffffff" : "rgba(255,255,255,0.40)"
          }).setAlpha(0.95);

          this.add.text(W - marginX, y, `Subtotal: ${sub}`, {
            fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.65)"
          }).setOrigin(1,0).setAlpha(0.9);

          y += 26;

          const gap = 10;
          const btnW = (colW - gap*(LEVELS_PER_WORLD-1)) / LEVELS_PER_WORLD;
          for (let li = 0; li < LEVELS_PER_WORLD; li++) {
            const unlocked = isLevelUnlocked(p, wi, li);
            const bx = marginX + li * (btnW + gap);
            const by = y;

            const best = p.levelBest[levelId(wi, li)] || 0;
            const label = `${li+1}\n${best}`;

            const b = this.add.text(bx + btnW/2, by + 22, label, {
              fontFamily: uiFont,
              fontSize: "12px",
              align: "center",
              color: unlocked ? "#0a0a12" : "rgba(255,255,255,0.55)",
              backgroundColor: unlocked ? "#6ef3ff" : "rgba(255,255,255,0.08)",
              padding: { left: 0, right: 0, top: 8, bottom: 8 }
            }).setOrigin(0.5);

            b.setFixedSize(btnW, 44);
            if (unlocked) {
              b.setInteractive({ useHandCursor: true });
              b.on("pointerdown", () => {
                const p2 = loadProgress();
                p2.currentWorld = wi;
                p2.currentLevel = li;
                saveProgress(p2);
                this.scene.start("WorldIntro", { world: wi, level: li });
              });
            } else {
              b.setAlpha(0.6);
            }
          }

          y += 68;
        });

        makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("ModeSelect"));
      }
    }

    class WorldIntroScene extends Phaser.Scene {
      constructor() { super("WorldIntro"); }
      create(data) {
        const world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
        const level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);

        const w = WORLDS[world];
        const lv = w.levels[level];

        this.cameras.main.setBackgroundColor(w.bg);
        buildBackdrop(this, w.fx, w.player, w.border);

        addTitle(this, w.name, 0.18, 34);
        addSubtitle(this, w.subtitle, 0.24);

        const p = loadProgress();
        const best = p.levelBest[levelId(world, level)] || 0;

        const tiers = tierTargetsFor(world, level, lv.seconds);

        const hazList = [];
        if (lv.haz?.laneLock) hazList.push("Lane Lock");
        if (lv.haz?.blink) hazList.push("Blink Obstacles");
        if (lv.haz?.blackout) hazList.push("Blackout Pulse");
        if (lv.haz?.lasers && lv.haz.lasers !== "off") hazList.push(`Lasers: ${lv.haz.lasers}`);

        this.add.text(W/2, H*0.38,
          `Survive: ${lv.seconds}s\nBest: ${best}\n\nTier Targets:\nBronze ${tiers.bronze}\nSilver ${tiers.silver}\nGold ${tiers.gold}\n\nHazards:\n${hazList.length ? hazList.join(", ") : "None"}`,
          { fontFamily: uiFont, fontSize: "14px", color: "#ffffff", align: "center" }
        ).setOrigin(0.5).setAlpha(0.95);

        const p2 = loadProgress();
        p2.currentWorld = world;
        p2.currentLevel = level;
        saveProgress(p2);

        makeButton(this, "START", W/2, H*0.72, () => this.scene.start("Play", { mode:"campaign", world, level }), "#6ef3ff");
        makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.82, () => this.scene.start("WorldMap"));
        makeGhostButton(this, "MAIN MENU", W/2, H*0.90, () => this.scene.start("Menu"));
      }
    }

    class EndlessIntroScene extends Phaser.Scene {
      constructor() { super("EndlessIntro"); }
      create() {
        this.cameras.main.setBackgroundColor(0x070710);
        addTitle(this, "ENDLESS", 0.18, 36);
        addSubtitle(this, "Ramps from W1L1 → W3L5 difficulty, then plateaus", 0.25);

        const lb = loadLeaderboards();
        const best = lb.endlessTop[0]?.score || 0;

        this.add.text(W/2, H*0.38, `Best: ${best}`, {
          fontFamily: uiFont, fontSize:"18px", color:"#ffffff"
        }).setOrigin(0.5).setAlpha(0.9);

        this.add.text(W/2, H*0.46, `Bonuses: Clean streak • Precision • Dodge • Near-miss (optional)`, {
          fontFamily: uiFont, fontSize:"12px", color:"rgba(255,255,255,0.75)", align:"center"
        }).setOrigin(0.5);

        makeButton(this, "START ENDLESS", W/2, H*0.62, () => this.scene.start("Play", { mode:"endless" }), "#7cffd2");
        makeGhostButton(this, "BACK", W/2, H*0.76, () => this.scene.start("ModeSelect"));
        makeGhostButton(this, "MAIN MENU", W/2, H*0.86, () => this.scene.start("Menu"));
      }
    }

    // ===== Play Scene =====
    class PlayScene extends Phaser.Scene {
      constructor() {
        super("Play");

        this.mode = "campaign";
        this.world = 0;
        this.level = 0;

        this.wcfg = WORLDS[0];
        this.lcfg = WORLDS[0].levels[0];

        this.haz = {};

        this.t = 0;
        this.rawTime = 0;

        this.score = 0;
        this.paused = false;
        this.countdown = 0;
        this.canMove = false;

        // scoring breakdown
        this.survivalPts = 0;
        this.cleanPts = 0;
        this.precisionPts = 0;
        this.dodgePts = 0;
        this.nearPts = 0;
        this.clearBonusPts = 0;

        this.combo = 1;
        this.comboTimer = 0;
        this.maxCombo = 1;

        // difficulty
        this.scrollSpeed = 0;
        this.baseScroll = 0;
        this.spawnEvery = 0;
        this.spawnTimer = 0;

        this.surgeMult = 1;
        this.blackoutOn = false;

        // visuals
        this.gridGraphics = null;
        this.gridOffset = 0;
        this.decor = [];

        // objects
        this.obstacles = null;
        this.player = null;

        // touch
        this.touchTarget = null;
        this.touchDot = null;

        // HUD
        this.hudBg = null;
        this.hudRightBg = null;
        this.uiScore = null;
        this.uiTime = null;
        this.uiMode = null;
        this.uiBonus = null;
        this.uiCombo = null;
        this.pauseBtn = null;

        // Pause overlay
        this.pauseOverlay = null;

        // hazards
        this.lockedCols = new Set();
        this.laneWarn = null;
        this._laneTimer = 0;
        this._laneActive = false;

        // lasers (world3 / endless late)
        this.hLaser = null;
        this.hLaserWarn = null;
        this.vLaser = null;
        this.vLaserWarn = null;
        this.bossT = 0;
        this.hLaserMode = "off";
        this.vLaserMode = "off";

        this.flash = null;
        this.blackout = null;

        // blink
        this._blinkT = 0;
      }

      init(data) {
        this.mode = data?.mode || "campaign";

        if (this.mode === "campaign") {
          this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
          this.level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);
          this.wcfg = WORLDS[this.world];
          this.lcfg = this.wcfg.levels[this.level];
          this.haz = this.lcfg.haz || {};
        } else {
          this.world = 0;
          this.level = 0;
          this.wcfg = WORLDS[0];
          this.lcfg = WORLDS[0].levels[0];
          this.haz = { laneLock:false, blink:false, blackout:false, lasers:"off" };
        }
      }

      create() {
        ensureObstacleTextures(this);

        this.cameras.main.setBackgroundColor(this.wcfg.bg);
        buildBackdrop(this, this.wcfg.fx, this.wcfg.player, this.wcfg.border);

        // Gameplay grid-only + HUD (no menus)
        this.gridGraphics = this.add.graphics();
        this.gridOffset = 0;

        this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

        const startX = GRID_X + GRID_W / 2;
        const startY = GRID_Y + GRID_H * 0.72;

        this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
        this.physics.add.existing(this.player);
        this.player.body.setAllowGravity(false);

        this.physics.add.overlap(this.player, this.obstacles, () => this.endRun({ reason: "HIT" }));

        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys("W,A,S,D,ESC");

        this.flash = this.add.rectangle(W/2, H/2, W, H, 0xffffff).setAlpha(0).setDepth(300);
        this.blackout = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0).setDepth(250);

        this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0).setDepth(90);
        this.touchTarget = null;

        // Hazards
        this.laneWarn = this.add.graphics().setDepth(140).setAlpha(0);

        // Lasers (created but toggled by modes)
        this.setupLasers();

        // HUD (readable)
        this.buildHud();

        // input
        this.input.topOnly = true;
        this.uiNoTouchZone = { x: W-220, y: 0, w: 220, h: 120 };

        this.input.on("pointerdown", (p) => {
          if (this.paused) return;
          if (this.isInNoTouchZone(p.x, p.y)) return;
          this.touchTarget = { x: p.x, y: p.y };
          this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
        });
        this.input.on("pointermove", (p) => {
          if (!p.isDown || this.paused) return;
          if (this.isInNoTouchZone(p.x, p.y)) return;
          this.touchTarget = { x: p.x, y: p.y };
          this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
        });
        this.input.on("pointerup", () => {
          this.touchTarget = null;
          this.touchDot.setAlpha(0);
        });

        this.input.keyboard.on("keydown-ESC", () => this.togglePause(!this.paused));

        this.resetRunState();
        this.setupDecor();
        this.startCountdown(3);
      }

      buildHud(){
        // Top bar background
        const pad = 10;
        const barH = 74;

        this.hudBg = this.add.graphics().setDepth(1000);
        this.hudBg.fillStyle(0x000000, 0.55);
        this.hudBg.fillRoundedRect(pad, pad, W - pad*2, barH, 14);
        this.hudBg.lineStyle(2, 0xffffff, 0.10);
        this.hudBg.strokeRoundedRect(pad, pad, W - pad*2, barH, 14);

        // Left stack (mode + score)
        this.uiMode = this.add.text(pad+14, pad+10, "", {
          fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.78)"
        }).setDepth(1001);

        this.uiScore = this.add.text(pad+14, pad+30, "", {
          fontFamily: uiFont, fontSize: "18px", color: "#ffffff"
        }).setDepth(1001);

        // Middle time + tier target (campaign)
        this.uiTime = this.add.text(W/2, pad+26, "", {
          fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
        }).setOrigin(0.5).setDepth(1001);

        // Right mini stack (combo + bonuses)
        this.uiCombo = this.add.text(W-pad-14, pad+12, "", {
          fontFamily: uiFont, fontSize: "12px", color: "#ffffff"
        }).setOrigin(1,0).setDepth(1001);

        this.uiBonus = this.add.text(W-pad-14, pad+32, "", {
          fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.80)"
        }).setOrigin(1,0).setDepth(1001);

        // Pause button INSIDE HUD
        this.pauseBtn = this.add.text(W-pad-14, pad+52, "PAUSE", {
          fontFamily: uiFont, fontSize: "12px",
          color: "#0a0a12",
          backgroundColor: "rgba(110,243,255,0.92)",
          padding: { left: 10, right: 10, top: 6, bottom: 6 }
        }).setOrigin(1,0).setDepth(1002).setInteractive({ useHandCursor:true });

        // enlarge hit area
        const pb = this.pauseBtn.getBounds();
        this.pauseBtn.input.hitArea.setTo(pb.x-20, pb.y-10, pb.width+30, pb.height+20);

        this.pauseBtn.on("pointerdown", (p) => {
          p.event?.stopPropagation?.();
          this.togglePause(!this.paused);
        });
      }

      isInNoTouchZone(x,y){
        const z = this.uiNoTouchZone;
        return x >= z.x && x <= z.x+z.w && y >= z.y && y <= z.y+z.h;
      }

      resetRunState(){
        this.t = 0;
        this.rawTime = 0;
        this.score = 0;
        this.paused = false;
        this.canMove = false;

        this.survivalPts = 0;
        this.cleanPts = 0;
        this.precisionPts = 0;
        this.dodgePts = 0;
        this.nearPts = 0;
        this.clearBonusPts = 0;

        this.combo = 1;
        this.comboTimer = 0;
        this.maxCombo = 1;

        this.spawnTimer = 0;

        // base difficulty
        if (this.mode === "campaign") {
          this.baseScroll = this.lcfg.baseScroll;
          this.scrollSpeed = this.lcfg.baseScroll;
          this.spawnEvery = this.lcfg.spawnStart;
        } else {
          this.baseScroll = ENDLESS.baseScroll0;
          this.scrollSpeed = ENDLESS.baseScroll0;
          this.spawnEvery = ENDLESS.spawnStart0;
        }

        this.surgeMult = 1;
        this.blackoutOn = false;
        this.lockedCols.clear();
        this._laneTimer = 0;
        this._laneActive = false;

        if (this.obstacles) {
          this.obstacles.children.iterate((o)=>{ if(o) o.destroy(); });
        }
      }

      startCountdown(n){
        this.countdown = n;

        this.countText = this.add.text(W/2, H*0.42, "", {
          fontFamily: uiFont, fontSize:"54px", color:"#ffffff"
        }).setOrigin(0.5).setDepth(1200).setAlpha(0);

        this.countSub = this.add.text(W/2, H*0.50, "", {
          fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff"
        }).setOrigin(0.5).setDepth(1200).setAlpha(0);

        const show = (txt, subtxt) => {
          this.countText.setText(txt).setAlpha(1);
          this.countSub.setText(subtxt || "").setAlpha(1);
          this.countText.setScale(1.0);
          this.tweens.add({ targets: this.countText, scale: 1.10, yoyo: true, duration: 170, ease: "Sine.easeInOut" });
        };

        show(String(this.countdown), this.mode==="endless" ? "ENDLESS" : `${this.wcfg.name} • LEVEL ${this.level+1}`);

        this.time.addEvent({
          delay: 1000,
          repeat: n,
          callback: () => {
            this.countdown--;
            if (this.countdown > 0) {
              show(String(this.countdown), "");
            } else if (this.countdown === 0) {
              show("GO", "");
              this.flash.setAlpha(0.10);
              this.tweens.add({ targets: this.flash, alpha: 0, duration: 180, ease: "Linear" });
              this.time.addEvent({
                delay: 450,
                callback: () => {
                  this.countText.destroy();
                  this.countSub.destroy();
                  this.canMove = true;
                }
              });
            }
          }
        });
      }

      togglePause(on){
        this.paused = on;

        if (on) {
          this.pauseOverlay = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0.60).setDepth(1500);
          this.pauseText = this.add.text(W/2, H*0.44, "PAUSED", { fontFamily: uiFont, fontSize:"28px", color:"#ffffff" })
            .setOrigin(0.5).setDepth(1501);
          this.pauseSub = this.add.text(W/2, H*0.52, "Tap PAUSE again or tap center to resume", { fontFamily: uiFont, fontSize:"13px", color:"#b7b7ff" })
            .setOrigin(0.5).setDepth(1501).setAlpha(0.9);

          this.pauseOverlay.setInteractive();
          this.pauseOverlay.on("pointerdown", () => this.togglePause(false));
        } else {
          if (this.pauseOverlay) this.pauseOverlay.destroy();
          if (this.pauseText) this.pauseText.destroy();
          if (this.pauseSub) this.pauseSub.destroy();
          this.pauseOverlay = null;
        }
      }

      setupDecor() {
        for (const d of this.decor) d.destroy();
        this.decor = [];

        if (this.wcfg.gridStyle === "pulse") {
          for (let i = 0; i < 10; i++) {
            const r = this.add.rectangle(
              Phaser.Math.Between(0, W),
              Phaser.Math.Between(-H, H),
              Phaser.Math.Between(90, 170),
              6,
              0x7cffd2
            ).setAlpha(0.06);
            r._vy = Phaser.Math.FloatBetween(18, 55);
            this.decor.push(r);
          }
        }

        if (this.wcfg.gridStyle === "astral") {
          for (let i=0;i<18;i++){
            const b = this.add.rectangle(
              Phaser.Math.Between(0, W),
              Phaser.Math.Between(-H, H),
              Phaser.Math.Between(10, 26),
              Phaser.Math.Between(4, 12),
              0x9cff57
            ).setAlpha(Phaser.Math.FloatBetween(0.05, 0.10));
            b._vy = Phaser.Math.FloatBetween(35, 95);
            this.decor.push(b);
          }
        }
      }

      setupLasers() {
        const boss = WORLDS[2].boss;

        this.hLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.warnThickness, 0xffffff)
          .setAlpha(0).setDepth(200);
        this.hLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.thickness, 0xff4d7d)
          .setAlpha(0).setDepth(201);

        this.vLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.warnThickness, GRID_H, 0xffffff)
          .setAlpha(0).setDepth(200);
        this.vLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.thickness, GRID_H, 0xff4d7d)
          .setAlpha(0).setDepth(201);

        this.bossT = 0;

        // campaign: only world 3 uses lasers based on level hazards
        if (this.mode === "campaign") {
          const lz = this.haz?.lasers || "off";
          this.hLaserMode = (this.world === 2) ? lz : "off";
          this.vLaserMode = "off";
        } else {
          this.hLaserMode = "off";
          this.vLaserMode = "off";
        }
      }

      updateLaneLock(dt){
        // Lane lock = warn → lock for ~1.2s
        if (!this.haz?.laneLock) return;

        this._laneTimer += dt;

        // cadence scales by world/level (later = more frequent)
        const cadence = this.mode==="campaign"
          ? clamp(6.2 - this.world*0.8 - this.level*0.25, 3.8, 6.2)
          : clamp(6.0 - (this.t/60)*0.7, 3.4, 6.0);

        if (this._laneTimer < cadence) return;
        this._laneTimer = 0;

        const col = Phaser.Math.Between(0, GRID_COLS-1);

        this.lockedCols.clear();
        this.lockedCols.add(col);

        const x = GRID_X + col*TILE;

        // warn
        this.laneWarn.clear();
        this.laneWarn.fillStyle(0xffffff, 0.16);
        this.laneWarn.fillRect(x, GRID_Y, TILE, GRID_H);
        this.laneWarn.setAlpha(1);

        this.time.delayedCall(600, () => {
          // active lock
          this.laneWarn.clear();
          this.laneWarn.fillStyle(0xff4d7d, 0.18);
          this.laneWarn.fillRect(x, GRID_Y, TILE, GRID_H);
          this.laneWarn.setAlpha(1);

          this.time.delayedCall(1200, () => {
            this.lockedCols.clear();
            this.laneWarn.setAlpha(0);
          });
        });
      }

      updateLasers(dt){
        const boss = WORLDS[2].boss;
        this.bossT += dt;

        const cycle = boss.cycleSeconds;
        const t = this.bossT % cycle;

        const warnOn = t < boss.warnSeconds;
        const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

        const driftY = (this.bossT * 0.22) % 1;
        const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + driftY) % 1);
        this.hLaserWarn.setPosition(GRID_X + GRID_W/2, yPos);
        this.hLaser.setPosition(GRID_X + GRID_W/2, yPos);

        const driftX = (this.bossT * 0.19 + 0.37) % 1;
        const xPos = GRID_X + 20 + (GRID_W - 40) * ((t / cycle + driftX) % 1);
        this.vLaserWarn.setPosition(xPos, GRID_Y + GRID_H/2);
        this.vLaser.setPosition(xPos, GRID_Y + GRID_H/2);

        const applyBeam = (mode, warnRect, activeRect) => {
          if (mode === "off") { warnRect.setAlpha(0); activeRect.setAlpha(0); return; }
          if (mode === "warn") { warnRect.setAlpha(warnOn ? 0.30 : 0); activeRect.setAlpha(0); return; }
          warnRect.setAlpha(warnOn ? 0.30 : 0);
          activeRect.setAlpha(activeOn ? 0.80 : 0);
        };

        applyBeam(this.hLaserMode, this.hLaserWarn, this.hLaser);
        applyBeam(this.vLaserMode, this.vLaserWarn, this.vLaser);

        if (activeOn) {
          const pr = this.player.getBounds();
          if (this.hLaserMode === "active") {
            if (Phaser.Geom.Intersects.RectangleToRectangle(pr, this.hLaser.getBounds())) this.endRun({ reason: "LASER" });
          }
          if (this.vLaserMode === "active") {
            if (Phaser.Geom.Intersects.RectangleToRectangle(pr, this.vLaser.getBounds())) this.endRun({ reason: "LASER" });
          }
        }
      }

      update(_, deltaMs){
        if (this.paused) return;

        const dt = deltaMs/1000;
        this.rawTime += dt;

        // update decorative motion
        for (const b of this.decor) {
          if (!b?._vy) continue;
          b.y += b._vy * dt;
          if (b.y > H + 30) { b.y = -30; b.x = Phaser.Math.Between(0, W); }
        }

        if (!this.canMove) {
          this.drawGrid(0.0001);
          this.updateHud();
          return;
        }

        this.t += dt;

        // combo decay
        this.comboTimer += dt;
        if (this.comboTimer > COMBO_DECAY_SEC) this.combo = 1;

        // mild surge
        const phase = (this.t % SURGE.period);
        const inSurge = phase < SURGE.active;
        this.surgeMult = inSurge ? SURGE.mult : 1.0;

        // endless diff + hazards
        if (this.mode === "endless") {
          const ed = getEndlessDifficulty(this.t);
          this.baseScrollRaw = ed.baseScroll;
          this.scrollRampRaw = ed.scrollRamp;
          this.spawnStartRaw = ed.spawnStart;
          this.spawnRampRaw = ed.spawnRamp;
          this.spawnMinRaw = ed.spawnMin;

          this.haz = ed.haz;

          // visuals: shift toward astral as time grows
          const t01 = ed.t01;
          if (t01 > 0.65) this.wcfg = WORLDS[2];
          else if (t01 > 0.33) this.wcfg = WORLDS[1];
          else this.wcfg = WORLDS[0];

          // lasers in endless
          this.hLaserMode = this.haz.lasers || "off";
          this.vLaserMode = "off";
        }

        // blackout hazard
        if (this.haz?.blackout) {
          const bp = (this.t % BLACKOUT.period);
          this.blackoutOn = bp < BLACKOUT.active;
          this.blackout.setAlpha(this.blackoutOn ? BLACKOUT.alpha : 0);
        } else {
          this.blackoutOn = false;
          this.blackout.setAlpha(0);
        }

        // lane lock hazard
        this.updateLaneLock(dt);

        // Scoring: survival PPS
        const baseAdd = SCORE_PPS * dt;
        this.survivalPts += baseAdd;
        this.score += baseAdd;

        // Clean streak bonus: every CLEAN_TICK_SEC seconds alive (no hit occurs anyway)
        if (!this._cleanT) this._cleanT = 0;
        this._cleanT += dt;
        if (this._cleanT >= CLEAN_TICK_SEC) {
          this._cleanT -= CLEAN_TICK_SEC;
          const bonus = CLEAN_BONUS * this.combo;
          this.cleanPts += bonus;
          this.score += bonus;
        }

        // Precision bonus: reward being near tile centers (controlled play)
        const cx = GRID_X + Math.round((this.player.x - GRID_X) / TILE) * TILE;
        const cy = GRID_Y + Math.round((this.player.y - GRID_Y) / TILE) * TILE;
        const pd = Math.hypot(this.player.x - cx, this.player.y - cy);
        if (pd <= PRECISION_RADIUS) {
          const pAdd = PRECISION_PPS * dt;
          this.precisionPts += pAdd;
          this.score += pAdd;
        }

        // Campaign timing / completion
        let timeLeft = 0;
        if (this.mode === "campaign") {
          timeLeft = Math.max(0, this.lcfg.seconds - this.t);
          if (this.t >= this.lcfg.seconds) {
            this.clearBonusPts += LEVEL_CLEAR_BONUS;
            this.score += LEVEL_CLEAR_BONUS;
            this.levelComplete();
            return;
          }
        }

        // Speed calc (scaled down + capped + capped ramp duration)
        const seconds = (this.mode==="campaign") ? this.lcfg.seconds : 9999;
        const rampCapT = (this.mode==="campaign")
          ? Math.min(this.t, seconds * DIFF.rampCapFrac)
          : Math.min(this.t, ENDLESS.rampToMaxSec * 0.75);

        const baseScrollRaw = (this.mode==="campaign") ? this.lcfg.baseScroll : this.baseScrollRaw;
        const rampRaw = (this.mode==="campaign") ? this.lcfg.scrollRamp : this.scrollRampRaw;

        this.baseScroll =
          (baseScrollRaw * DIFF.scrollMult) +
          (rampCapT * rampRaw * DIFF.rampMult);

        this.baseScroll = Math.min(this.baseScroll, DIFF.maxScroll);
        this.scrollSpeed = this.baseScroll * this.surgeMult;

        // Spawn interval calc (keep pressure)
        if (this.mode === "campaign") {
          const targetSpawn = this.lcfg.spawnStart - this.t * this.lcfg.spawnRamp;
          this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);
        } else {
          const targetSpawn = this.spawnStartRaw - this.t * this.spawnRampRaw;
          this.spawnEvery = clamp(targetSpawn, this.spawnMinRaw, this.spawnStartRaw);
        }

        // Movement
        if (!IS_TOUCH) {
          let kvx = 0, kvy = 0;
          const left = this.cursors.left.isDown || this.keys.A.isDown;
          const right = this.cursors.right.isDown || this.keys.D.isDown;
          const up = this.cursors.up.isDown || this.keys.W.isDown;
          const down = this.cursors.down.isDown || this.keys.S.isDown;
          if (left) kvx -= 1;
          if (right) kvx += 1;
          if (up) kvy -= 1;
          if (down) kvy += 1;
          const mag = Math.hypot(kvx, kvy);
          if (mag > 1) { kvx /= mag; kvy /= mag; }
          this.player.body.setVelocity(kvx * PLAYER_SPEED, kvy * PLAYER_SPEED);
        } else {
          if (this.touchTarget) {
            const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
            const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

            const dx = tx - this.player.x;
            const dy = ty - this.player.y;
            const dist = Math.hypot(dx, dy);

            if (dist > FOLLOW_RADIUS) {
              const nx = this.player.x + dx * FOLLOW_LERP;
              const ny = this.player.y + dy * FOLLOW_LERP;

              const maxStep = PLAYER_SPEED * FOLLOW_MAX_SPEED_MULT * dt;
              const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);

              if (stepDist > maxStep) {
                const s = maxStep / stepDist;
                this.player.x = this.player.x + (nx - this.player.x) * s;
                this.player.y = this.player.y + (ny - this.player.y) * s;
              } else {
                this.player.x = nx;
                this.player.y = ny;
              }
              this.player.body.reset(this.player.x, this.player.y);
            } else {
              this.player.body.setVelocity(0, 0);
            }
          } else {
            this.player.body.setVelocity(0, 0);
          }
        }

        // clamp inside grid
        const pad = 14;
        const px = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
        const py = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
        if (px !== this.player.x || py !== this.player.y) {
          this.player.x = px; this.player.y = py;
          this.player.body.reset(px, py);
        }

        // Spawn obstacles
        this.spawnTimer += deltaMs;
        while (this.spawnTimer >= this.spawnEvery) {
          this.spawnTimer -= this.spawnEvery;
          this.spawnObstacle();
        }

        // Move obstacles + bonuses (dodge/near)
        this._blinkT += dt;

        this.obstacles.children.iterate((o) => {
          if (!o) return;

          o.y += this.scrollSpeed * dt;

          // blink hazard: flicker visibility but still collide
          if (this.haz?.blink) {
            const flick = 0.55 + 0.45*Math.sin(this._blinkT*6.5 + (o._seed||0));
            o.setAlpha(0.40 + 0.55 * flick);
          } else {
            o.setAlpha(0.95);
          }

          if (o.y > GRID_Y + GRID_H + 160) { o.destroy(); return; }
          this.checkDodge(o);
        });

        // lasers
        if ((this.mode==="campaign" && this.world===2) || (this.mode==="endless" && this.haz?.lasers!=="off")) {
          this.updateLasers(dt);
        } else {
          this.hLaserWarn.setAlpha(0); this.hLaser.setAlpha(0);
          this.vLaserWarn.setAlpha(0); this.vLaser.setAlpha(0);
        }

        this.drawGrid(dt);
        this.updateHud(timeLeft);
      }

      checkDodge(o){
        if (!o || o._dodgeAwarded) return;

        const dy = Math.abs(o.y - this.player.y);
        if (dy > 30) return;

        const dx = Math.abs(o.x - this.player.x);
        const dist = Math.hypot(dx, dy);

        // Dodge first (safer bonus)
        if (dist <= DODGE_DIST) {
          o._dodgeAwarded = true;

          this.comboTimer = 0;

          // if it's a true near-miss, award bigger + more combo
          if (dist <= NEAR_DIST) {
            this.combo = Math.min(COMBO_MAX, this.combo + COMBO_STEP_NEAR);
            const award = NEAR_POINTS * this.combo;
            this.nearPts += award;
            this.score += award;
          } else {
            this.combo = Math.min(COMBO_MAX, this.combo + COMBO_STEP_DODGE);
            const award = DODGE_POINTS * this.combo;
            this.dodgePts += award;
            this.score += award;
          }

          this.maxCombo = Math.max(this.maxCombo, this.combo);
        }
      }

      drawGrid(dt){
        this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
        const g = this.gridGraphics;
        g.clear();

        // border
        g.lineStyle(2, this.wcfg.border, 0.92);
        g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

        // styles
        const style = this.wcfg.gridStyle;

        if (style === "neon") {
          g.lineStyle(1, this.wcfg.gridLine, 0.95);
          for (let c = 0; c <= GRID_COLS; c++) {
            const x = GRID_X + c * TILE;
            g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
          }
          for (let r = -1; r <= GRID_ROWS + 1; r++) {
            const y = GRID_Y + r * TILE + this.gridOffset - TILE;
            g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
          }
          // glow dots
          g.fillStyle(this.wcfg.player, 0.12);
          for (let c = 0; c <= GRID_COLS; c++) {
            for (let r = 0; r <= GRID_ROWS; r++) {
              if ((c + r) % 3 !== 0) continue;
              g.fillCircle(GRID_X + c*TILE, GRID_Y + r*TILE, 2.4);
            }
          }
        }

        if (style === "pulse") {
          g.lineStyle(2, this.wcfg.gridLine, 0.85);
          for (let c = 0; c <= GRID_COLS; c++) {
            const x = GRID_X + c * TILE;
            g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
          }
          for (let r = -1; r <= GRID_ROWS + 1; r++) {
            const y = GRID_Y + r * TILE + this.gridOffset - TILE;
            g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
          }
          // subtle diagonal hatch
          g.lineStyle(1, 0xffffff, 0.05);
          for (let x = GRID_X - GRID_H; x < GRID_X + GRID_W + GRID_H; x += 18) {
            g.beginPath();
            g.moveTo(x, GRID_Y);
            g.lineTo(x + GRID_H, GRID_Y + GRID_H);
            g.strokePath();
          }
        }

        if (style === "astral") {
          const flick = 0.78 + Math.sin(this.t * 6) * 0.10;
          g.lineStyle(1, this.wcfg.gridLine, flick);

          for (let c = 0; c <= GRID_COLS; c++) {
            const x = GRID_X + c * TILE;
            let y0 = GRID_Y;
            while (y0 < GRID_Y + GRID_H) {
              const seg = Phaser.Math.Between(18, 64);
              const gap = Phaser.Math.Between(10, 40);
              if (Math.random() > 0.22) {
                g.beginPath();
                g.moveTo(x, y0);
                g.lineTo(x, Math.min(GRID_Y + GRID_H, y0 + seg));
                g.strokePath();
              }
              y0 += seg + gap;
            }
          }

          for (let r = -1; r <= GRID_ROWS + 1; r++) {
            const y = GRID_Y + r * TILE + this.gridOffset - TILE;
            let x0 = GRID_X;
            while (x0 < GRID_X + GRID_W) {
              const seg = Phaser.Math.Between(20, 70);
              const gap = Phaser.Math.Between(12, 44);
              if (Math.random() > 0.25) {
                g.beginPath();
                g.moveTo(x0, y);
                g.lineTo(Math.min(GRID_X + GRID_W, x0 + seg), y);
                g.strokePath();
              }
              x0 += seg + gap;
            }
          }
        }
      }

      spawnObstacle(){
        // respect lane locks
        let col = Phaser.Math.Between(0, GRID_COLS - 1);
        if (this.lockedCols.has(col)) col = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;

        const x = GRID_X + col * TILE + TILE / 2;
        const y = GRID_Y - 70;

        const style = this.wcfg.obstacleStyle;
        const shapes = style.shapes;
        const shape = shapes[Phaser.Math.Between(0, shapes.length - 1)];
        const tex = shapeToTex[shape] || "obs_rect";
        const palette = style.palette;
        const color = palette[Phaser.Math.Between(0, palette.length - 1)];

        let smin = 20, smax = 32;

        if (this.mode === "campaign") {
          const [a,b] = this.lcfg.size;
          smin = a; smax = b;
        } else {
          // endless: slightly tighter over time, but not extreme
          smin = clamp(22 - Math.floor(this.t/140), 18, 22);
          smax = clamp(34 - Math.floor(this.t/160), 24, 34);
        }

        let w = Phaser.Math.Between(smin, smax);
        let h = Phaser.Math.Between(smin, smax);

        if (shape === "bar") { w = Phaser.Math.Between(smax+8, smax+24); h = Phaser.Math.Between(14, 22); }
        if (shape === "tri") { w = Phaser.Math.Between(smin, smax+4); h = Phaser.Math.Between(smin, smax+8); }
        if (shape === "frame") { w = Phaser.Math.Between(smin+2, smax+10); h = Phaser.Math.Between(smin+2, smax+10); }
        if (shape === "plus") { w = Phaser.Math.Between(smin, smax+10); h = Phaser.Math.Between(smin, smax+10); }

        const s = this.add.image(x, y, tex);
        s.setTint(color);
        s.setAlpha(0.95);
        s.displayWidth = w;
        s.displayHeight = h;
        s._seed = Math.random()*10;

        this.physics.add.existing(s);
        s.body.setAllowGravity(false);
        s.body.setImmovable(true);
        s.body.setSize(w * 0.88, h * 0.88, true);
        s._dodgeAwarded = false;

        this.obstacles.add(s);

        // Controlled overlap spawns:
        // Still present (pressure), but toned down in W1 so it isn't unfair.
        let chance = 0.07;
        if (this.mode === "campaign") {
          chance = clamp(0.06 + this.world*0.03 + (this.level>=2?0.05:0.0) + (this.t*0.0013), 0.06, 0.18);
          if (this.world === 0) chance *= 0.88;
        } else {
          chance = clamp(0.06 + (this.t*0.0012), 0.06, 0.16);
        }

        if (Math.random() < chance && this.t > 6) {
          let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
          if (this.lockedCols.has(col2)) col2 = (col2+1) % GRID_COLS;
          if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;

          const x2 = GRID_X + col2 * TILE + TILE / 2;
          const shape2 = shapes[Phaser.Math.Between(0, shapes.length - 1)];
          const tex2 = shapeToTex[shape2] || "obs_rect";
          const color2 = palette[Phaser.Math.Between(0, palette.length - 1)];

          const s2 = this.add.image(x2, y - Phaser.Math.Between(26, 92), tex2);
          s2.setTint(color2);
          s2.setAlpha(0.92);
          s2.displayWidth = Math.max(16, w * 0.78);
          s2.displayHeight = Math.max(16, h * 0.78);
          s2._seed = Math.random()*10;

          this.physics.add.existing(s2);
          s2.body.setAllowGravity(false);
          s2.body.setImmovable(true);
          s2.body.setSize(s2.displayWidth * 0.88, s2.displayHeight * 0.88, true);
          s2._dodgeAwarded = false;

          this.obstacles.add(s2);
        }
      }

      updateHud(timeLeft){
        const scoreI = Math.floor(this.score);

        const modeLabel = this.mode === "campaign"
          ? `Campaign • ${this.wcfg.name} • L${this.level+1}`
          : `Endless • ${this.wcfg.name}`;

        this.uiMode.setText(modeLabel);

        const tLabel = this.mode === "campaign"
          ? `Time: ${Math.ceil(timeLeft)}s`
          : `Time: ${formatTime(this.t)}`;

        // Tier targets shown in campaign for clarity
        let tierLine = "";
        if (this.mode === "campaign") {
          const tiers = tierTargetsFor(this.world, this.level, this.lcfg.seconds);
          tierLine = ` • Tiers: ${tiers.bronze}/${tiers.silver}/${tiers.gold}`;
        }

        const surgeLabel = (this.surgeMult > 1.01) ? " • SURGE" : "";
        const blackoutLabel = (this.blackoutOn) ? " • BLACKOUT" : "";
        const hazardLabel =
          (this.haz?.laneLock ? " • LANE" : "") +
          (this.haz?.blink ? " • BLINK" : "") +
          (this.haz?.lasers && this.haz.lasers !== "off" ? " • LASER" : "");

        this.uiScore.setText(`Score: ${scoreI}${surgeLabel}${blackoutLabel}`);

        this.uiTime.setText(`${tLabel}${tierLine}`);

        const cm = Math.min(COMBO_MAX, this.combo);
        this.uiCombo.setText(cm > 1.01 ? `Combo x${cm.toFixed(2)}${hazardLabel}` : `${hazardLabel}`.trim());

        // bonus summary (players can see paths to tier)
        const b1 = `Clean ${Math.floor(this.cleanPts)}`;
        const b2 = `Prec ${Math.floor(this.precisionPts)}`;
        const b3 = `Dodge ${Math.floor(this.dodgePts)}`;
        const b4 = `Near ${Math.floor(this.nearPts)}`;
        this.uiBonus.setText(`${b1} • ${b2} • ${b3} • ${b4}`);
      }

      getBreakdown(){
        return {
          survival: Math.floor(this.survivalPts),
          clean: Math.floor(this.cleanPts),
          precision: Math.floor(this.precisionPts),
          dodge: Math.floor(this.dodgePts),
          near: Math.floor(this.nearPts),
          clear: Math.floor(this.clearBonusPts),
          maxCombo: Number(this.maxCombo.toFixed(2))
        };
      }

      levelComplete(){
        const p = loadProgress();
        const id = levelId(this.world, this.level);
        const thisScore = Math.floor(this.score);
        const prevBest = p.levelBest[id] || 0;

        let pbLevel = false;
        if (thisScore > prevBest) { p.levelBest[id] = thisScore; pbLevel = true; }

        // unlock next
        let nextWorld = this.world;
        let nextLevel = this.level + 1;

        if (nextLevel >= LEVELS_PER_WORLD) { nextLevel = 0; nextWorld = this.world + 1; }

        if (nextWorld > p.unlockedWorld) {
          p.unlockedWorld = Math.min(WORLDS_COUNT-1, nextWorld);
          p.unlockedLevel = 0;
        } else if (nextWorld === p.unlockedWorld) {
          p.unlockedLevel = Math.max(p.unlockedLevel, nextLevel);
        }

        if (nextWorld >= WORLDS.length) {
          p.currentWorld = WORLDS.length - 1;
          p.currentLevel = LEVELS_PER_WORLD - 1;
        } else {
          p.currentWorld = nextWorld;
          p.currentLevel = nextLevel;
        }

        saveProgress(p);

        const total = campaignTotalScore(p);
        const lb = loadLeaderboards();
        lb.campaignTop = maybeInsertTop(lb.campaignTop, { score: total, meta: "Total" });
        saveLeaderboards(lb);

        this.scene.start("Results", {
          mode: "campaign",
          world: this.world,
          level: this.level,
          score: thisScore,
          prevBest,
          pb: pbLevel,
          total,
          breakdown: this.getBreakdown(),
          reason: "CLEAR"
        });
      }

      endRun({reason}){
        const thisScore = Math.floor(this.score);

        this.flash.setAlpha(0.10);
        this.tweens.add({ targets: this.flash, alpha: 0, duration: 170, ease: "Linear" });

        if (this.mode === "endless") {
          const lb = loadLeaderboards();
          const prevBest = lb.endlessTop[0]?.score || 0;
          const pb = thisScore > prevBest;

          lb.endlessTop = maybeInsertTop(lb.endlessTop, { score: thisScore, meta: formatTime(this.t) });
          saveLeaderboards(lb);

          this.scene.start("Results", {
            mode: "endless",
            score: thisScore,
            prevBest,
            pb,
            total: null,
            breakdown: this.getBreakdown(),
            reason
          });
          return;
        }

        const p = loadProgress();
        const id = levelId(this.world, this.level);
        const prevBest = p.levelBest[id] || 0;
        const total = campaignTotalScore(p);

        this.scene.start("Results", {
          mode: "campaign",
          world: this.world,
          level: this.level,
          score: thisScore,
          prevBest,
          pb: false,
          total,
          breakdown: this.getBreakdown(),
          reason
        });
      }
    }

    class ResultsScene extends Phaser.Scene {
      constructor() { super("Results"); }
      create(data) {
        this.cameras.main.setBackgroundColor(0x070710);

        const mode = data?.mode || "campaign";
        const score = data?.score || 0;
        const prevBest = data?.prevBest || 0;
        const pb = !!data?.pb;
        const total = data?.total;
        const reason = data?.reason || "";

        const breakdown = data?.breakdown || { survival:0, clean:0, precision:0, dodge:0, near:0, clear:0, maxCombo:1 };

        addTitle(this, mode === "endless" ? "ENDLESS RESULT" : "LEVEL RESULT", 0.16, 30);

        const subtitle =
          mode === "endless"
            ? `Reason: ${reason}`
            : `${WORLDS[data.world].name} • Level ${data.level+1} • ${reason==="CLEAR"?"CLEARED":"FAILED"}`;

        addSubtitle(this, subtitle, 0.22);

        this.add.text(W/2, H*0.34, `Score: ${score}`, {
          fontFamily: uiFont, fontSize:"24px", color:"#ffffff"
        }).setOrigin(0.5).setAlpha(0.95);

        this.add.text(W/2, H*0.40, `Best: ${Math.max(prevBest, (pb?score:prevBest))}${pb ? "  •  NEW PB!" : ""}`, {
          fontFamily: uiFont, fontSize:"14px", color: pb ? "#6ef3ff" : "#b7b7ff"
        }).setOrigin(0.5).setAlpha(0.95);

        const lines = [
          `Survival: ${breakdown.survival}`,
          `Clean: ${breakdown.clean}`,
          `Precision: ${breakdown.precision}`,
          `Dodge: ${breakdown.dodge}`,
          `Near-miss: ${breakdown.near}`,
          `Clear Bonus: ${breakdown.clear}`,
          `Max Combo: x${breakdown.maxCombo}`
        ];
        this.add.text(W/2, H*0.56, lines.join("\n"), {
          fontFamily: uiFont, fontSize:"13px", color:"rgba(255,255,255,0.85)", align:"center"
        }).setOrigin(0.5);

        if (mode === "campaign") {
          const lv = WORLDS[data.world].levels[data.level];
          const tiers = tierTargetsFor(data.world, data.level, lv.seconds);

          let tier = "Bronze";
          if (score >= tiers.gold) tier = "Gold";
          else if (score >= tiers.silver) tier = "Silver";
          else if (score >= tiers.bronze) tier = "Bronze";
          else tier = "Try Again";

          this.add.text(W/2, H*0.74, `Tier: ${tier} • Targets ${tiers.bronze}/${tiers.silver}/${tiers.gold}`, {
            fontFamily: uiFont, fontSize:"14px", color:"#ffffff", align:"center"
          }).setOrigin(0.5).setAlpha(0.9);

          this.add.text(W/2, H*0.80, `Campaign Total: ${total}`, {
            fontFamily: uiFont, fontSize:"13px", color:"#ffffff"
          }).setOrigin(0.5).setAlpha(0.85);

          makeButton(this, "RETRY", W/2, H*0.86, () => this.scene.start("Play", { mode:"campaign", world:data.world, level:data.level }), "#6ef3ff");
          makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.93, () => this.scene.start("WorldMap"));
        } else {
          makeButton(this, "RETRY ENDLESS", W/2, H*0.82, () => this.scene.start("Play", { mode:"endless" }), "#7cffd2");
          makeGhostButton(this, "BACK", W/2, H*0.90, () => this.scene.start("ModeSelect"));
        }

        makeGhostButton(this, "MAIN MENU", W/2, H*0.97, () => this.scene.start("Menu")).setScale(0.92);
      }
    }

    new Phaser.Game({
      type: Phaser.AUTO,
      width: W,
      height: H,
      physics: { default: "arcade", arcade: { debug: false } },
      scene: [
        MenuScene,
        ModeSelectScene,
        LeaderboardsScene,
        WorldMapScene,
        WorldIntroScene,
        EndlessIntroScene,
        PlayScene,
        ResultsScene
      ],
    });

  }, 50);
});
</script>

</body>
</html>