<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN</title>
  <style>
    html, body { margin:0; padding:0; background:#0a0a12; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
    .hint{
      position:fixed; left:12px; bottom:10px;
      font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:rgba(255,255,255,.75);
      background:rgba(0,0,0,0.35);
      padding:8px 10px; border-radius:10px;
      user-select:none; z-index:10;
    }
  </style>
</head>
<body>
  <div class="hint">PC: WASD/Arrows • Mobile: drag thumb • Toggle: Direct Follow (top-right)</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    window.addEventListener("load", () => {
      const wait = setInterval(() => {
        if (typeof window.Phaser === "undefined") return;
        clearInterval(wait);

        const W = 420, H = 760;
        const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

        // ======== GRID ========
        const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
        const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
        const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

        // Movement
        const PLAYER_SPEED = 320;

        // ✅ Mobile analog tuning (more responsive)
        const ANALOG_MAX_DIST = 60;      // smaller = faster response
        const ANALOG_DEADZONE = 3;       // smaller = more sensitive
        const ANALOG_BOOST = 1.65;       // baseline punch
        const ANALOG_MAX_EXTRA = 1.05;   // extra boost ceiling from time ramp

        // Direct-follow mode (snap/lerp to finger)
        const FOLLOW_RADIUS = 10;        // player stops when within this many px of target
        const FOLLOW_LERP = 0.28;        // higher = more snappy (0.22–0.40 good range)
        const FOLLOW_MAX_SPEED_MULT = 2.2; // cap follow speed vs PLAYER_SPEED

        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

        // ======== SAVE / PROGRESS ========
        const LEVELS_PER_WORLD = 5;
        const SAVE_KEY = "gridrun_progress_v2";

        function loadProgress() {
          try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
            const p = JSON.parse(raw);
            return {
              unlockedWorld: Number.isFinite(p.unlockedWorld) ? p.unlockedWorld : 0,
              unlockedLevel: Number.isFinite(p.unlockedLevel) ? p.unlockedLevel : 0,
              currentWorld: Number.isFinite(p.currentWorld) ? p.currentWorld : 0,
              currentLevel: Number.isFinite(p.currentLevel) ? p.currentLevel : 0
            };
          } catch {
            return { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
          }
        }
        function saveProgress(p) { localStorage.setItem(SAVE_KEY, JSON.stringify(p)); }
        function resetProgress() { localStorage.removeItem(SAVE_KEY); }

        function isLevelUnlocked(p, world, level) {
          if (world < p.unlockedWorld) return true;
          if (world > p.unlockedWorld) return false;
          return level <= p.unlockedLevel;
        }

        // Persist input mode (mobile feel preference)
        const INPUT_KEY = "gridrun_input_mode_v1"; // "analog" | "follow"
        function loadInputMode() {
          const v = localStorage.getItem(INPUT_KEY);
          return (v === "follow" || v === "analog") ? v : "analog";
        }
        function saveInputMode(mode) {
          localStorage.setItem(INPUT_KEY, mode);
        }

        // ======== UI HELPERS ========
        function addTitle(scene, text, yFrac = 0.22, size = 40) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: `${size}px`, color: "#ffffff",
          }).setOrigin(0.5).setAlpha(0.96);
        }
        function addSubtitle(scene, text, yFrac = 0.28) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff",
          }).setOrigin(0.5).setAlpha(0.9);
        }
        function makeButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "18px",
            color: "#0a0a12",
            backgroundColor: "#6ef3ff",
            padding: { left: 18, right: 18, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.92));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }
        function makeGhostButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "16px",
            color: "#ffffff",
            backgroundColor: "rgba(255,255,255,0.10)",
            padding: { left: 16, right: 16, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.85));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }

        // ======== WORLDS + REAL LEVEL DESIGN ========
        const WORLDS = [
          {
            id: 0,
            name: "Neon Alley",
            subtitle: "Warmup. Find your flow.",
            bg: 0x0a0a12,
            border: 0x2a2a55,
            gridLine: 0x20204a,
            player: 0x6ef3ff,
            backFx: "scanlines",
            levels: [
              { seconds: 35, baseScroll: 105, scrollRamp: 14, spawnStart: 980, spawnRamp: 10, spawnMin: 430, shape:"square", size:[22,34], colors:[0xff4d7d,0xff6aa2] },
              { seconds: 40, baseScroll: 112, scrollRamp: 16, spawnStart: 930, spawnRamp: 11, spawnMin: 410, shape:"square", size:[22,34], colors:[0xff4d7d,0xff7bd0] },
              { seconds: 45, baseScroll: 118, scrollRamp: 18, spawnStart: 900, spawnRamp: 12, spawnMin: 390, shape:"tall",   size:[20,32], colors:[0xff4d7d,0xff6aa2] },
              { seconds: 48, baseScroll: 125, scrollRamp: 20, spawnStart: 870, spawnRamp: 13, spawnMin: 370, shape:"wide",   size:[20,32], colors:[0xff4d7d,0xff7bd0] },
              { seconds: 50, baseScroll: 132, scrollRamp: 22, spawnStart: 850, spawnRamp: 14, spawnMin: 360, shape:"mix",    size:[20,34], colors:[0xff4d7d,0xff6aa2,0xff7bd0] },
            ]
          },
          {
            id: 1,
            name: "Overclock District",
            subtitle: "Neon rain. Faster drops.",
            bg: 0x060814,
            border: 0x3a4a88,
            gridLine: 0x243056,
            player: 0x7cffd2,
            backFx: "rain",
            levels: [
              { seconds: 40, baseScroll: 130, scrollRamp: 22, spawnStart: 840, spawnRamp: 13, spawnMin: 340, shape:"tall", size:[18,30], colors:[0xff6aa2,0xff4d7d] },
              { seconds: 45, baseScroll: 140, scrollRamp: 24, spawnStart: 820, spawnRamp: 14, spawnMin: 330, shape:"wide", size:[18,30], colors:[0xff6aa2,0xff7bd0] },
              { seconds: 50, baseScroll: 148, scrollRamp: 26, spawnStart: 790, spawnRamp: 15, spawnMin: 320, shape:"mix",  size:[18,32], colors:[0xff6aa2,0xff4d7d,0xff7bd0] },
              { seconds: 52, baseScroll: 155, scrollRamp: 28, spawnStart: 770, spawnRamp: 16, spawnMin: 310, shape:"square",size:[18,32], colors:[0xff6aa2,0xff4d7d] },
              { seconds: 55, baseScroll: 162, scrollRamp: 30, spawnStart: 750, spawnRamp: 17, spawnMin: 300, shape:"mix",  size:[18,34], colors:[0xff6aa2,0xff4d7d,0xffb0ff] },
            ]
          },
          {
            id: 2,
            name: "Blackout Sector",
            subtitle: "Dark grid. Laser sweeps.",
            bg: 0x03040b,
            border: 0x4b4bb0,
            gridLine: 0x1e1f3f,
            player: 0x9aa7ff,
            backFx: "stars",
            levels: [
              { seconds: 45, baseScroll: 150, scrollRamp: 26, spawnStart: 760, spawnRamp: 16, spawnMin: 300, shape:"wide", size:[18,30], colors:[0xff4d7d,0xff6aa2] },
              { seconds: 50, baseScroll: 158, scrollRamp: 28, spawnStart: 740, spawnRamp: 17, spawnMin: 290, shape:"tall", size:[18,30], colors:[0xff4d7d,0xff7bd0] },
              { seconds: 55, baseScroll: 166, scrollRamp: 30, spawnStart: 720, spawnRamp: 18, spawnMin: 280, shape:"mix",  size:[18,32], colors:[0xff4d7d,0xff6aa2,0xff7bd0] },
              { seconds: 58, baseScroll: 174, scrollRamp: 32, spawnStart: 700, spawnRamp: 19, spawnMin: 270, shape:"square",size:[18,32], colors:[0xff4d7d,0xffb0ff] },
              { seconds: 60, baseScroll: 182, scrollRamp: 34, spawnStart: 680, spawnRamp: 20, spawnMin: 260, shape:"mix",  size:[18,34], colors:[0xff4d7d,0xff6aa2,0xffb0ff] },
            ],
            boss: {
              enabled: true,
              cycleSeconds: 6.0,
              warnSeconds: 1.25,
              activeSeconds: 1.1,
              thickness: 16,
              warnThickness: 6
            }
          }
        ];

        // ======== BACKGROUND FX ========
        function buildBackdrop(scene, fxType, colorA, colorB) {
          const items = [];

          if (fxType === "scanlines") {
            const g = scene.add.graphics();
            g.setAlpha(0.25);
            g.lineStyle(1, colorB, 1);
            for (let y = 0; y < H; y += 8) {
              g.beginPath(); g.moveTo(0, y); g.lineTo(W, y); g.strokePath();
            }
            items.push(g);
          }

          if (fxType === "rain") {
            const drops = [];
            for (let i = 0; i < 40; i++) {
              const r = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(-H, H),
                2,
                Phaser.Math.Between(18, 44),
                colorB
              ).setAlpha(0.18);
              r._vy = Phaser.Math.FloatBetween(220, 420);
              drops.push(r);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const d of drops) {
                d.y += d._vy * dt;
                if (d.y > H + 60) { d.y = Phaser.Math.Between(-120, -20); d.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...drops);
          }

          if (fxType === "stars") {
            const stars = [];
            for (let i = 0; i < 60; i++) {
              const s = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(0, H),
                2, 2, colorA
              ).setAlpha(Phaser.Math.FloatBetween(0.08, 0.35));
              s._vy = Phaser.Math.FloatBetween(12, 42);
              stars.push(s);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const s of stars) {
                s.y += s._vy * dt;
                if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...stars);
          }

          return items;
        }

        // ======== SCENES ========
        class MenuScene extends Phaser.Scene {
          constructor() { super("Menu"); }
          create() {
            this.cameras.main.setBackgroundColor(0x0a0a12);
            addTitle(this, "GRIDRUN", 0.22, 46);
            addSubtitle(this, "Worlds • Levels • Skill-only arcade run", 0.285);

            const p = loadProgress();
            const hasProgress = (p.unlockedWorld > 0) || (p.unlockedLevel > 0);

            makeButton(this, "PLAY (NEW RUN)", W/2, H*0.46, () => {
              const fresh = { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
              saveProgress(fresh);
              this.scene.start("WorldMap");
            });

            const cont = makeGhostButton(this, hasProgress ? "CONTINUE" : "CONTINUE (LOCKED)", W/2, H*0.56, () => {
              if (!hasProgress) return;
              const p2 = loadProgress();
              this.scene.start("WorldIntro", { world: p2.currentWorld, level: p2.currentLevel });
            });
            cont.setAlpha(hasProgress ? 1 : 0.45);

            makeGhostButton(this, "WORLD MAP / LEVEL SELECT", W/2, H*0.66, () => this.scene.start("WorldMap"));

            makeGhostButton(this, "RESET SAVE", W/2, H*0.78, () => {
              resetProgress();
              this.scene.restart();
            }).setAlpha(0.75);

            this.add.text(W/2, H*0.88, "No login needed: progress saves locally on your device.", {
              fontFamily: uiFont, fontSize: "12px", color: "#ffffff", align: "center"
            }).setOrigin(0.5).setAlpha(0.55);
          }
        }

        class WorldMapScene extends Phaser.Scene {
          constructor() { super("WorldMap"); }
          create() {
            const p = loadProgress();
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "WORLD MAP", 0.14, 34);
            addSubtitle(this, "Select an unlocked level • Replay anytime", 0.20);

            const marginX = 18;
            const colW = (W - marginX*2);
            let y = H*0.26;

            WORLDS.forEach((w, wi) => {
              const unlockedWorld = wi <= p.unlockedWorld;

              this.add.text(marginX, y, `${wi+1}. ${w.name}`, {
                fontFamily: uiFont,
                fontSize: "16px",
                color: unlockedWorld ? "#ffffff" : "rgba(255,255,255,0.40)"
              }).setAlpha(0.95);

              y += 26;

              const gap = 10;
              const btnW = (colW - gap*(LEVELS_PER_WORLD-1)) / LEVELS_PER_WORLD;
              for (let li = 0; li < LEVELS_PER_WORLD; li++) {
                const unlocked = isLevelUnlocked(p, wi, li);
                const bx = marginX + li * (btnW + gap);
                const by = y;

                const b = this.add.text(bx + btnW/2, by + 18, `${li+1}`, {
                  fontFamily: uiFont,
                  fontSize: "16px",
                  color: unlocked ? "#0a0a12" : "rgba(255,255,255,0.55)",
                  backgroundColor: unlocked ? "#6ef3ff" : "rgba(255,255,255,0.08)",
                  padding: { left: 0, right: 0, top: 8, bottom: 8 }
                }).setOrigin(0.5);

                b.setFixedSize(btnW, 36);
                if (unlocked) {
                  b.setInteractive({ useHandCursor: true });
                  b.on("pointerdown", () => {
                    const p2 = loadProgress();
                    p2.currentWorld = wi;
                    p2.currentLevel = li;
                    saveProgress(p2);
                    this.scene.start("WorldIntro", { world: wi, level: li });
                  });
                } else {
                  b.setAlpha(0.6);
                }
              }

              y += 58;
            });

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldIntroScene extends Phaser.Scene {
          constructor() { super("WorldIntro"); }
          create(data) {
            const world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            const level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);

            const w = WORLDS[world];
            const lv = w.levels[level];

            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.backFx, w.player, w.border);

            addTitle(this, w.name, 0.22, 36);
            addSubtitle(this, w.subtitle, 0.285);

            this.add.text(W/2, H*0.40,
              `Level ${level + 1}/${LEVELS_PER_WORLD}\nTime: ${lv.seconds}s`,
              { fontFamily: uiFont, fontSize: "16px", color: "#ffffff", align: "center" }
            ).setOrigin(0.5).setAlpha(0.92);

            // Save current position
            const p = loadProgress();
            p.currentWorld = world;
            p.currentLevel = level;
            saveProgress(p);

            makeButton(this, "START", W/2, H*0.60, () => this.scene.start("Play", { world, level }));
            makeGhostButton(this, "WORLD MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.79, () => this.scene.start("Menu"));
          }
        }

        class PlayScene extends Phaser.Scene {
          constructor() {
            super("Play");

            this.world = 0;
            this.level = 0;
            this.wcfg = WORLDS[0];
            this.lcfg = WORLDS[0].levels[0];

            this.elapsed = 0;
            this.score = 0;
            this.levelTime = 0;

            this.scrollSpeed = 0;
            this.spawnEvery = 0;
            this.spawnTimer = 0;

            this.gridGraphics = null;
            this.gridOffset = 0;
            this.backdropItems = [];

            this.obstacles = null;
            this.player = null;

            this.touchTarget = null;
            this.touchDot = null;

            // input mode toggle
            this.inputMode = "analog"; // "analog" | "follow"
            this.modeBtn = null;

            // boss
            this.laser = null;
            this.laserWarn = null;
            this.bossT = 0;
          }

          init(data) {
            this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            this.level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);
            this.wcfg = WORLDS[this.world];
            this.lcfg = this.wcfg.levels[this.level];
          }

          create() {
            this.cameras.main.setBackgroundColor(this.wcfg.bg);

            this.backdropItems = buildBackdrop(this, this.wcfg.backFx, this.wcfg.player, this.wcfg.border);

            this.gridGraphics = this.add.graphics();
            this.gridOffset = 0;

            this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

            const startX = GRID_X + GRID_W / 2;
            const startY = GRID_Y + GRID_H * 0.72;
            this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
            this.physics.add.existing(this.player);
            this.player.body.setAllowGravity(false);

            this.physics.add.overlap(this.player, this.obstacles, () => this.gameOver());

            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys("W,A,S,D");

            // Thumb dot + input
            this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0);
            this.touchTarget = null;

            this.input.on("pointerdown", (p) => {
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointermove", (p) => {
              if (!p.isDown) return;
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointerup", () => {
              this.touchTarget = null;
              this.touchDot.setAlpha(0);
            });

            // HUD
            this.uiTop = this.add.text(14, 10, "", { fontFamily: uiFont, fontSize: "14px", color: "#ffffff" }).setAlpha(0.95);
            this.uiTime = this.add.text(14, 30, "", { fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff" }).setAlpha(0.95);

            // Input mode button (top-right)
            this.inputMode = loadInputMode();
            this.modeBtn = this.add.text(W - 14, 12, "", {
              fontFamily: uiFont,
              fontSize: "12px",
              color: "#ffffff",
              backgroundColor: "rgba(255,255,255,0.10)",
              padding: { left: 10, right: 10, top: 6, bottom: 6 }
            }).setOrigin(1, 0).setInteractive({ useHandCursor: true });

            this.modeBtn.on("pointerdown", () => {
              this.inputMode = (this.inputMode === "analog") ? "follow" : "analog";
              saveInputMode(this.inputMode);
              this.refreshModeBtn();
            });

            this.refreshModeBtn();

            // run state
            this.elapsed = 0;
            this.score = 0;
            this.levelTime = 0;

            this.scrollSpeed = this.lcfg.baseScroll;
            this.spawnEvery = this.lcfg.spawnStart;
            this.spawnTimer = 0;

            this.setupBoss();
            this.updateHud();
          }

          refreshModeBtn() {
            const label = (this.inputMode === "follow") ? "Direct Follow: ON" : "Direct Follow: OFF";
            this.modeBtn.setText(label);
            this.modeBtn.setAlpha(this.inputMode === "follow" ? 0.95 : 0.75);
          }

          setupBoss() {
            this.bossT = 0;
            if (this.laser) this.laser.destroy();
            if (this.laserWarn) this.laserWarn.destroy();

            const boss = this.wcfg.boss;
            if (!boss || !boss.enabled) return;

            this.laserWarn = this.add.rectangle(
              GRID_X + GRID_W/2, GRID_Y + GRID_H/2,
              GRID_W, boss.warnThickness,
              0xffffff
            ).setAlpha(0).setDepth(5);

            this.laser = this.add.rectangle(
              GRID_X + GRID_W/2, GRID_Y + GRID_H/2,
              GRID_W, boss.thickness,
              0xff4d7d
            ).setAlpha(0).setDepth(6);
          }

          update(_, deltaMs) {
            const dt = deltaMs / 1000;
            this.elapsed += dt;
            this.levelTime += dt;

            if (this.levelTime >= this.lcfg.seconds) {
              this.levelComplete();
              return;
            }

            this.scrollSpeed = this.lcfg.baseScroll + this.elapsed * this.lcfg.scrollRamp;
            const targetSpawn = this.lcfg.spawnStart - this.elapsed * this.lcfg.spawnRamp;
            this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);

            this.score += dt * 10;
            this.updateHud();

            // ===== Movement =====
            let vx = 0, vy = 0;

            // Keyboard still works always
            const left = this.cursors.left.isDown || this.keys.A.isDown;
            const right = this.cursors.right.isDown || this.keys.D.isDown;
            const up = this.cursors.up.isDown || this.keys.W.isDown;
            const down = this.cursors.down.isDown || this.keys.S.isDown;

            if (left) vx -= 1;
            if (right) vx += 1;
            if (up) vy -= 1;
            if (down) vy += 1;

            // Mobile / touch behavior:
            // - analog: velocity direction + speed scaling
            // - follow: position lerp toward finger (fast & responsive)
            if (this.touchTarget) {
              if (this.inputMode === "follow") {
                // Direct follow (lerp toward target)
                const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
                const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

                const dx = tx - this.player.x;
                const dy = ty - this.player.y;
                const dist = Math.hypot(dx, dy);

                if (dist > FOLLOW_RADIUS) {
                  // lerp position
                  const nx = this.player.x + dx * FOLLOW_LERP;
                  const ny = this.player.y + dy * FOLLOW_LERP;

                  // cap max instantaneous velocity so it remains fair
                  const maxStep = PLAYER_SPEED * FOLLOW_MAX_SPEED_MULT * dt;
                  const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);
                  if (stepDist > maxStep) {
                    const s = maxStep / stepDist;
                    this.player.x = this.player.x + (nx - this.player.x) * s;
                    this.player.y = this.player.y + (ny - this.player.y) * s;
                  } else {
                    this.player.x = nx;
                    this.player.y = ny;
                  }

                  // reset body to avoid physics drift
                  this.player.body.reset(this.player.x, this.player.y);
                } else {
                  this.player.body.setVelocity(0, 0);
                }
              } else {
                // Analog steering + boosted speed based on thumb distance
                const dx = this.touchTarget.x - this.player.x;
                const dy = this.touchTarget.y - this.player.y;

                const ax = Math.abs(dx) > ANALOG_DEADZONE ? dx : 0;
                const ay = Math.abs(dy) > ANALOG_DEADZONE ? dy : 0;

                const dynamicBoost = ANALOG_BOOST + (this.elapsed * 0.02);
                const boost = Phaser.Math.Clamp(dynamicBoost, ANALOG_BOOST, ANALOG_BOOST + ANALOG_MAX_EXTRA);

                vx += Phaser.Math.Clamp((ax / ANALOG_MAX_DIST) * boost, -1, 1);
                vy += Phaser.Math.Clamp((ay / ANALOG_MAX_DIST) * boost, -1, 1);

                // normalize
                const mag = Math.hypot(vx, vy);
                if (mag > 1) { vx /= mag; vy /= mag; }

                // speed scales with distance (drag far = faster)
                let speed = PLAYER_SPEED;
                const dist = Math.hypot(dx, dy);
                const t = Phaser.Math.Clamp(dist / 120, 0, 1);
                speed = PLAYER_SPEED * (1 + 1.15 * t); // stronger than before

                this.player.body.setVelocity(vx * speed, vy * speed);
              }
            } else {
              // No touch: keyboard only
              const mag = Math.hypot(vx, vy);
              if (mag > 1) { vx /= mag; vy /= mag; }
              this.player.body.setVelocity(vx * PLAYER_SPEED, vy * PLAYER_SPEED);
            }

            // Clamp to grid (always)
            const pad = 14;
            const nx = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
            const ny = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
            if (nx !== this.player.x || ny !== this.player.y) {
              this.player.x = nx; this.player.y = ny;
              this.player.body.reset(nx, ny);
            }

            // spawn obstacles
            this.spawnTimer += deltaMs;
            while (this.spawnTimer >= this.spawnEvery) {
              this.spawnTimer -= this.spawnEvery;
              this.spawnObstacle();
            }

            // move obstacles
            this.obstacles.children.iterate((o) => {
              if (!o) return;
              o.y += this.scrollSpeed * dt;
              if (o.y > GRID_Y + GRID_H + 120) o.destroy();
            });

            // boss
            this.updateBoss(dt);

            // grid
            this.drawGrid(dt);
          }

          updateHud() {
            const timeLeft = Math.max(0, Math.ceil(this.lcfg.seconds - this.levelTime));
            this.uiTop.setText(`${this.wcfg.name} • Level ${this.level+1}/${LEVELS_PER_WORLD} • Score: ${Math.floor(this.score)}`);
            this.uiTime.setText(`Time Left: ${timeLeft}s`);
          }

          drawGrid(dt) {
            this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
            const g = this.gridGraphics;
            g.clear();

            g.lineStyle(2, this.wcfg.border, 0.92);
            g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

            g.lineStyle(1, this.wcfg.gridLine, 0.9);

            for (let c = 0; c <= GRID_COLS; c++) {
              const x = GRID_X + c * TILE;
              g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
            }
            for (let r = -1; r <= GRID_ROWS + 1; r++) {
              const y = GRID_Y + r * TILE + this.gridOffset - TILE;
              g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
            }
          }

          spawnObstacle() {
            const col = Phaser.Math.Between(0, GRID_COLS - 1);
            const x = GRID_X + col * TILE + TILE / 2;
            const y = GRID_Y - 60;

            const [smin, smax] = this.lcfg.size;
            const color = this.lcfg.colors[Phaser.Math.Between(0, this.lcfg.colors.length - 1)];

            let w = Phaser.Math.Between(smin, smax);
            let h = Phaser.Math.Between(smin, smax);

            const shape = this.lcfg.shape;
            if (shape === "tall") { w = Phaser.Math.Between(smin, smax-2); h = Phaser.Math.Between(smax, smax+18); }
            else if (shape === "wide") { w = Phaser.Math.Between(smax, smax+22); h = Phaser.Math.Between(smin, smax-2); }
            else if (shape === "mix") {
              const r = Phaser.Math.Between(0,2);
              if (r === 0) { w = Phaser.Math.Between(smin, smax-2); h = Phaser.Math.Between(smax, smax+18); }
              if (r === 1) { w = Phaser.Math.Between(smax, smax+22); h = Phaser.Math.Between(smin, smax-2); }
            }

            const rect = this.add.rectangle(x, y, w, h, color).setAlpha(0.95);
            this.physics.add.existing(rect);
            rect.body.setAllowGravity(false);
            rect.body.setImmovable(true);
            this.obstacles.add(rect);

            const chance = Phaser.Math.Clamp(0.08 + (this.elapsed * 0.004), 0.08, 0.26);
            if (Math.random() < chance && this.levelTime > 6) {
              let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
              if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;
              const x2 = GRID_X + col2 * TILE + TILE / 2;
              const color2 = this.lcfg.colors[Phaser.Math.Between(0, this.lcfg.colors.length - 1)];
              const r2 = this.add.rectangle(x2, y - Phaser.Math.Between(20, 70), w * 0.9, h * 0.9, color2).setAlpha(0.9);
              this.physics.add.existing(r2);
              r2.body.setAllowGravity(false);
              r2.body.setImmovable(true);
              this.obstacles.add(r2);
            }
          }

          updateBoss(dt) {
            const boss = this.wcfg.boss;
            if (!boss || !boss.enabled || !this.laser || !this.laserWarn) return;

            this.bossT += dt;
            const cycle = boss.cycleSeconds;
            const t = this.bossT % cycle;

            const sweep = (this.bossT * 0.22) % 1;
            const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + sweep) % 1);

            this.laserWarn.setPosition(GRID_X + GRID_W/2, yPos);
            this.laser.setPosition(GRID_X + GRID_W/2, yPos);

            const warnOn = t < boss.warnSeconds;
            const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

            this.laserWarn.setAlpha(warnOn ? 0.35 : 0);
            this.laser.setAlpha(activeOn ? 0.85 : 0);

            if (activeOn) {
              const pr = this.player.getBounds();
              const lr = this.laser.getBounds();
              const inGrid =
                pr.left >= GRID_X - 2 && pr.right <= GRID_X + GRID_W + 2 &&
                pr.top >= GRID_Y - 2 && pr.bottom <= GRID_Y + GRID_H + 2;

              if (inGrid && Phaser.Geom.Intersects.RectangleToRectangle(pr, lr)) {
                this.gameOver();
              }
            }
          }

          levelComplete() {
            const p = loadProgress();

            let nextWorld = this.world;
            let nextLevel = this.level + 1;
            let worldClear = false;

            if (nextLevel >= LEVELS_PER_WORLD) {
              worldClear = true;
              nextLevel = 0;
              nextWorld = this.world + 1;
            }

            if (worldClear) {
              p.unlockedWorld = Math.max(p.unlockedWorld, this.world + 1);
              p.unlockedLevel = 0;
            } else {
              if (p.unlockedWorld < this.world) p.unlockedWorld = this.world;
              if (p.unlockedWorld === this.world) p.unlockedLevel = Math.max(p.unlockedLevel, this.level + 1);
            }

            if (nextWorld >= WORLDS.length) {
              p.currentWorld = WORLDS.length - 1;
              p.currentLevel = LEVELS_PER_WORLD - 1;
            } else {
              p.currentWorld = nextWorld;
              p.currentLevel = nextLevel;
            }
            saveProgress(p);

            if (nextWorld >= WORLDS.length) {
              this.scene.start("CampaignComplete", { score: Math.floor(this.score) });
            } else if (worldClear) {
              this.scene.start("WorldComplete", { world: this.world, score: Math.floor(this.score) });
            } else {
              this.scene.start("LevelComplete", { world: this.world, level: this.level, score: Math.floor(this.score) });
            }
          }

          gameOver() {
            this.scene.start("GameOver", {
              world: this.world,
              level: this.level,
              score: Math.floor(this.score),
              timeLeft: Math.max(0, Math.ceil(this.lcfg.seconds - this.levelTime))
            });
          }
        }

        class LevelCompleteScene extends Phaser.Scene {
          constructor() { super("LevelComplete"); }
          create(data) {
            const world = data?.world ?? 0;
            const level = data?.level ?? 0;
            const score = data?.score ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.backFx, w.player, w.border);

            addTitle(this, "LEVEL CLEAR", 0.30, 34);
            this.add.text(W/2, H*0.40, `${w.name} • Level ${level + 1}/${LEVELS_PER_WORLD}`, {
              fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#ffffff"
            }).setOrigin(0.5);

            makeButton(this, "NEXT", W/2, H*0.60, () => {
              const p = loadProgress();
              this.scene.start("WorldIntro", { world: p.currentWorld, level: p.currentLevel });
            });

            makeGhostButton(this, "WORLD MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.79, () => this.scene.start("Menu"));
          }
        }

        class WorldCompleteScene extends Phaser.Scene {
          constructor() { super("WorldComplete"); }
          create(data) {
            const world = data?.world ?? 0;
            const score = data?.score ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.backFx, w.player, w.border);

            addTitle(this, "WORLD CLEAR", 0.30, 34);
            this.add.text(W/2, H*0.40, `${w.name} completed`, {
              fontFamily: uiFont, fontSize: "16px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#b7b7ff"
            }).setOrigin(0.5);

            makeButton(this, "NEXT WORLD", W/2, H*0.62, () => {
              const p = loadProgress();
              this.scene.start("WorldIntro", { world: p.currentWorld, level: p.currentLevel });
            });

            makeGhostButton(this, "WORLD MAP", W/2, H*0.72, () => this.scene.start("WorldMap"));
          }
        }

        class CampaignCompleteScene extends Phaser.Scene {
          constructor() { super("CampaignComplete"); }
          create(data) {
            this.cameras.main.setBackgroundColor(0x020208);

            addTitle(this, "CAMPAIGN CLEAR", 0.30, 32);
            this.add.text(W/2, H*0.42, "You cleared all worlds.", {
              fontFamily: uiFont, fontSize: "16px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.50, `Final Score: ${data?.score ?? 0}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#b7b7ff"
            }).setOrigin(0.5);

            makeButton(this, "PLAY AGAIN", W/2, H*0.64, () => {
              const fresh = { unlockedWorld: 0, unlockedLevel: 0, currentWorld: 0, currentLevel: 0 };
              saveProgress(fresh);
              this.scene.start("WorldMap");
            });

            makeGhostButton(this, "MAIN MENU", W/2, H*0.74, () => this.scene.start("Menu"));
          }
        }

        class GameOverScene extends Phaser.Scene {
          constructor() { super("GameOver"); }
          create(data) {
            const world = data?.world ?? 0;
            const level = data?.level ?? 0;
            const score = data?.score ?? 0;
            const timeLeft = data?.timeLeft ?? 0;

            const w = WORLDS[clamp(world, 0, WORLDS.length-1)];
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "RUN ENDED", 0.33, 34);
            this.add.text(W/2, H*0.42, `${w.name} • Level ${level + 1}/${LEVELS_PER_WORLD}`, {
              fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.48, `Score: ${score}`, {
              fontFamily: uiFont, fontSize: "18px", color: "#ffffff"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.54, `Time left: ${timeLeft}s`, {
              fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff"
            }).setOrigin(0.5).setAlpha(0.85);

            makeButton(this, "RETRY LEVEL", W/2, H*0.66, () => this.scene.start("Play", { world, level }));
            makeGhostButton(this, "WORLD MAP", W/2, H*0.76, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.84, () => this.scene.start("Menu"));
          }
        }

        // ======== GAME INIT ========
        new Phaser.Game({
          type: Phaser.AUTO,
          width: W,
          height: H,
          physics: { default: "arcade", arcade: { debug: false } },
          scene: [
            MenuScene,
            WorldMapScene,
            WorldIntroScene,
            PlayScene,
            LevelCompleteScene,
            WorldCompleteScene,
            CampaignCompleteScene,
            GameOverScene
          ],
        });

      }, 50);
    });
  </script>
</body>
</html>

