<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>TXC GRIDRUN</title>
  <style>
    html, body { margin:0; padding:0; background:#070710; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
  </style>
</head>
<body>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    window.addEventListener("load", () => {
      const wait = setInterval(() => {
        if (typeof window.Phaser === "undefined") return;
        clearInterval(wait);

        const W = 420, H = 760;
        const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

        // ===== GRID =====
        const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
        const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
        const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

        // ===== Movement =====
        const PLAYER_SPEED = 320;
        const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

        // Mobile DIRECT FOLLOW tuning (no Settings UI)
        const FOLLOW_RADIUS = 7;
        const FOLLOW_LERP = 0.40;
        const FOLLOW_MAX_SPEED_MULT = 3.0;

        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const lerp = (a,b,t) => a + (b-a)*t;

        // ===== Storage =====
        const SAVE_KEY = "gridrun_progress_v6";
        const LEADER_KEY = "gridrun_leaderboards_v2";

        const LEVELS_PER_WORLD = 5;
        const WORLDS_COUNT = 3;
        const TOTAL_LEVELS = WORLDS_COUNT * LEVELS_PER_WORLD;

        function levelId(world, level) { return world * LEVELS_PER_WORLD + level; }

        function loadProgress() {
          try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) {
              return {
                unlockedWorld: 0, unlockedLevel: 0,
                currentWorld: 0, currentLevel: 0,
                levelBest: Array(TOTAL_LEVELS).fill(0)
              };
            }
            const p = JSON.parse(raw);
            const levelBest = Array.isArray(p.levelBest) ? p.levelBest.map(x => Math.max(0, Math.floor(x||0))) : Array(TOTAL_LEVELS).fill(0);
            while (levelBest.length < TOTAL_LEVELS) levelBest.push(0);
            return {
              unlockedWorld: Number.isFinite(p.unlockedWorld) ? clamp(p.unlockedWorld, 0, WORLDS_COUNT-1) : 0,
              unlockedLevel: Number.isFinite(p.unlockedLevel) ? clamp(p.unlockedLevel, 0, LEVELS_PER_WORLD-1) : 0,
              currentWorld: Number.isFinite(p.currentWorld) ? clamp(p.currentWorld, 0, WORLDS_COUNT-1) : 0,
              currentLevel: Number.isFinite(p.currentLevel) ? clamp(p.currentLevel, 0, LEVELS_PER_WORLD-1) : 0,
              levelBest
            };
          } catch {
            return { unlockedWorld:0, unlockedLevel:0, currentWorld:0, currentLevel:0, levelBest: Array(TOTAL_LEVELS).fill(0) };
          }
        }
        function saveProgress(p) { localStorage.setItem(SAVE_KEY, JSON.stringify(p)); }
        function resetAllSaves() {
          localStorage.removeItem(SAVE_KEY);
          localStorage.removeItem(LEADER_KEY);
        }

        function campaignTotalScore(p) { return p.levelBest.reduce((a,b)=>a+b, 0); }
        function worldSubtotal(p, world) {
          const start = world * LEVELS_PER_WORLD;
          let sum = 0;
          for (let i=0;i<LEVELS_PER_WORLD;i++) sum += (p.levelBest[start+i]||0);
          return sum;
        }
        function isLevelUnlocked(p, world, level) {
          if (world < p.unlockedWorld) return true;
          if (world > p.unlockedWorld) return false;
          return level <= p.unlockedLevel;
        }

        // ===== Leaderboards (local) =====
        function loadLeaderboards() {
          try {
            const raw = localStorage.getItem(LEADER_KEY);
            if (!raw) return { campaignTop: [], endlessTop: [] };
            const lb = JSON.parse(raw);
            const normalize = (arr) => (Array.isArray(arr) ? arr : [])
              .map(x => ({ score: Math.max(0, Math.floor(x?.score||0)), meta: x?.meta || "" }))
              .sort((a,b)=>b.score-a.score)
              .slice(0,10);
            return { campaignTop: normalize(lb.campaignTop), endlessTop: normalize(lb.endlessTop) };
          } catch {
            return { campaignTop: [], endlessTop: [] };
          }
        }
        function saveLeaderboards(lb) { localStorage.setItem(LEADER_KEY, JSON.stringify(lb)); }
        function maybeInsertTop(list, entry) {
          const next = [...list, entry].sort((a,b)=>b.score-a.score).slice(0,10);
          return next;
        }

        // ===== UI helpers =====
        function addTitle(scene, text, yFrac = 0.22, size = 40) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: `${size}px`, color: "#ffffff",
          }).setOrigin(0.5).setAlpha(0.98);
        }
        function addSubtitle(scene, text, yFrac = 0.28) {
          return scene.add.text(W/2, H*yFrac, text, {
            fontFamily: uiFont, fontSize: "14px", color: "#b7b7ff",
          }).setOrigin(0.5).setAlpha(0.92);
        }
        function makeButton(scene, label, x, y, onClick, accent="#6ef3ff") {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "18px",
            color: "#0a0a12",
            backgroundColor: accent,
            padding: { left: 18, right: 18, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.92));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }
        function makeGhostButton(scene, label, x, y, onClick) {
          const btn = scene.add.text(x, y, label, {
            fontFamily: uiFont,
            fontSize: "16px",
            color: "#ffffff",
            backgroundColor: "rgba(255,255,255,0.10)",
            padding: { left: 16, right: 16, top: 10, bottom: 10 },
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });

          btn.on("pointerdown", onClick);
          btn.on("pointerover", () => btn.setAlpha(0.85));
          btn.on("pointerout", () => btn.setAlpha(1));
          return btn;
        }

        // ===== Level times =====
        const DUR = [20, 25, 30, 38, 45];

        function mkLevels(cfg) {
          return DUR.map((seconds, i) => ({
            seconds,
            baseScroll: cfg.baseScroll0 + cfg.baseScrollStep * i,
            scrollRamp: cfg.ramp0 + cfg.rampStep * i,

            spawnStart: cfg.spawnStart0 - cfg.spawnStep * i,
            spawnRamp: cfg.spawnRamp0 + cfg.spawnRampStep * i,
            spawnMin: Math.max(cfg.spawnMinFloor, cfg.spawnMin0 - cfg.spawnMinStep * i),

            size: [cfg.sizeMin0 - cfg.sizeMinStep*i, cfg.sizeMax0 - cfg.sizeMaxStep*i]
          }));
        }

        // ===== Worlds =====
        const WORLDS = [
          {
            id: 0,
            name: "Cyber Circuit",
            subtitle: "Neon lanes. Clean reads. Warm up.",
            bg: 0x070812,
            border: 0x2a2a55,
            gridLine: 0x20204a,
            player: 0x6ef3ff,
            fx: "scanlines",
            gridStyle: "circuit",
            obstacleStyle: { palette: [0xff4d7d, 0xff6aa2, 0xff7bd0], shapes: ["tri","hex","frame","rect"] },
            levels: mkLevels({
              baseScroll0: 80, baseScrollStep: 18,
              ramp0: 8.0, rampStep: 3.0,
              spawnStart0: 1020, spawnStep: 105,
              spawnRamp0: 10, spawnRampStep: 3,
              spawnMin0: 520, spawnMinStep: 55,
              spawnMinFloor: 300,
              sizeMin0: 22, sizeMinStep: 1,
              sizeMax0: 34, sizeMaxStep: 1
            })
          },
          {
            id: 1,
            name: "Industrial Overclock",
            subtitle: "Heavy plating. Hazard stripes. Faster drops.",
            bg: 0x050611,
            border: 0x3a4a88,
            gridLine: 0x243056,
            player: 0x7cffd2,
            fx: "rain",
            gridStyle: "industrial",
            obstacleStyle: { palette: [0xffd166, 0xff4d7d, 0x7cffd2], shapes: ["bar","plus","rect","frame"] },
            levels: mkLevels({
              baseScroll0: 92, baseScrollStep: 20,
              ramp0: 9.0, rampStep: 3.3,
              spawnStart0: 980, spawnStep: 115,
              spawnRamp0: 11, spawnRampStep: 3.4,
              spawnMin0: 500, spawnMinStep: 60,
              spawnMinFloor: 285,
              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            })
          },
          {
            id: 2,
            name: "Blackout Glitch",
            subtitle: "Broken grid. Flicker. Laser sweeps.",
            bg: 0x02030a,
            border: 0x4b4bb0,
            gridLine: 0x1e1f3f,
            player: 0x9aa7ff,
            fx: "stars",
            gridStyle: "glitch",
            obstacleStyle: { palette: [0xff4d7d, 0xffb0ff, 0x9aa7ff], shapes: ["hex","tri","bar","frame"] },
            levels: mkLevels({
              baseScroll0: 98, baseScrollStep: 22,
              ramp0: 9.6, rampStep: 3.6,
              spawnStart0: 940, spawnStep: 120,
              spawnRamp0: 12, spawnRampStep: 3.6,
              spawnMin0: 480, spawnMinStep: 62,
              spawnMinFloor: 270,
              sizeMin0: 21, sizeMinStep: 1,
              sizeMax0: 33, sizeMaxStep: 1
            }),
            boss: {
              enabled: true,
              cycleSeconds: 5.7,
              warnSeconds: 1.20,
              activeSeconds: 1.12,
              thickness: 16,
              warnThickness: 6
            }
          }
        ];

        // ===== FX =====
        function buildBackdrop(scene, fxType, colorA, colorB) {
          const items = [];
          if (fxType === "scanlines") {
            const g = scene.add.graphics();
            g.setAlpha(0.20);
            g.lineStyle(1, colorB, 1);
            for (let y = 0; y < H; y += 8) {
              g.beginPath(); g.moveTo(0, y); g.lineTo(W, y); g.strokePath();
            }
            items.push(g);
          }
          if (fxType === "rain") {
            const drops = [];
            for (let i = 0; i < 42; i++) {
              const r = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(-H, H),
                2,
                Phaser.Math.Between(18, 48),
                colorB
              ).setAlpha(0.14);
              r._vy = Phaser.Math.FloatBetween(240, 460);
              drops.push(r);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const d of drops) {
                d.y += d._vy * dt;
                if (d.y > H + 60) { d.y = Phaser.Math.Between(-120, -20); d.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...drops);
          }
          if (fxType === "stars") {
            const stars = [];
            for (let i = 0; i < 62; i++) {
              const s = scene.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(0, H),
                2, 2, colorA
              ).setAlpha(Phaser.Math.FloatBetween(0.06, 0.28));
              s._vy = Phaser.Math.FloatBetween(12, 52);
              stars.push(s);
            }
            scene.events.on("update", (_, dtMs) => {
              const dt = dtMs / 1000;
              for (const s of stars) {
                s.y += s._vy * dt;
                if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
              }
            });
            items.push(...stars);
          }
          return items;
        }

        // ===== Obstacle textures =====
        function ensureObstacleTextures(scene) {
          const makeTex = (key, drawFn) => {
            if (scene.textures.exists(key)) return;
            const g = scene.make.graphics({ x:0, y:0, add:false });
            g.clear();
            drawFn(g);
            g.generateTexture(key, 64, 64);
            g.destroy();
          };

          makeTex("obs_rect", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(8, 8, 48, 48, 10);
          });
          makeTex("obs_frame", (g) => {
            g.lineStyle(6, 0xffffff, 1);
            g.strokeRoundedRect(10, 10, 44, 44, 10);
            g.lineStyle(2, 0xffffff, 0.7);
            g.strokeRoundedRect(16, 16, 32, 32, 8);
          });
          makeTex("obs_tri", (g) => {
            g.fillStyle(0xffffff, 1);
            g.beginPath();
            g.moveTo(32, 8);
            g.lineTo(56, 56);
            g.lineTo(8, 56);
            g.closePath();
            g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });
          makeTex("obs_hex", (g) => {
            g.fillStyle(0xffffff, 1);
            const pts = [
              {x:32,y:6},{x:54,y:18},{x:54,y:46},{x:32,y:58},{x:10,y:46},{x:10,y:18}
            ];
            g.beginPath();
            g.moveTo(pts[0].x, pts[0].y);
            for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
            g.closePath(); g.fillPath();
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokePath();
          });
          makeTex("obs_bar", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(6, 24, 52, 16, 8);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(6, 24, 52, 16, 8);
          });
          makeTex("obs_plus", (g) => {
            g.fillStyle(0xffffff, 1);
            g.fillRoundedRect(26, 10, 12, 44, 5);
            g.fillRoundedRect(10, 26, 44, 12, 5);
            g.lineStyle(2, 0xffffff, 0.35);
            g.strokeRoundedRect(26, 10, 12, 44, 5);
            g.strokeRoundedRect(10, 26, 44, 12, 5);
          });
        }

        const shapeToTex = {
          rect: "obs_rect",
          frame: "obs_frame",
          tri: "obs_tri",
          hex: "obs_hex",
          bar: "obs_bar",
          plus: "obs_plus"
        };

        // ===== Scoring (shared rules; separate leaderboards) =====
        const SCORE_PPS = 12;

        const NEAR_DIST = 30;
        const NEAR_POINTS = 20;
        const COMBO_DECAY_SEC = 1.35;
        const COMBO_STEP = 0.12;
        const COMBO_MAX = 3.25;

        const LEVEL_CLEAR_BONUS = 160;

        function formatTime(sec) {
          const m = Math.floor(sec / 60);
          const s = Math.floor(sec % 60);
          return m > 0 ? `${m}:${String(s).padStart(2,"0")}` : `${s}s`;
        }

        // ===== Endless blending (start effects at 30s) =====
        // Starts at World 1 Level 1 difficulty (not easier).
        const ENDLESS = {
          baseScroll0: WORLDS[0].levels[0].baseScroll,
          ramp0: WORLDS[0].levels[0].scrollRamp,
          spawnStart0: WORLDS[0].levels[0].spawnStart,
          spawnRamp0: WORLDS[0].levels[0].spawnRamp,
          spawnMinFloor: 230,

          // growth
          scrollRampGrowth: 0.012,
          scrollBaseGrowth: 0.025,
          spawnTighten: 0.26,
          spawnRampGrowth: 0.012,

          // effects ramp (earlier)
          t_industrial: 30,
          t_glitch: 55,
          t_blackout: 65,
          t_laserWarnOnly: 80,
          t_laserActive: 110,
          t_verticalLaser: 140
        };

        function getEndlessBlend(t) {
          const w1 = 1;
          const w2 = clamp((t - ENDLESS.t_industrial) / 55, 0, 1);
          const w3 = clamp((t - ENDLESS.t_glitch) / 65, 0, 1);
          const total = w1 + w2 + w3;

          return {
            a1: w1/total, a2: w2/total, a3: w3/total,
            blackout: t >= ENDLESS.t_blackout,
            laserWarn: t >= ENDLESS.t_laserWarnOnly,
            laserActive: t >= ENDLESS.t_laserActive,
            verticalLaser: t >= ENDLESS.t_verticalLaser
          };
        }

        function mixColor(c1, c2, t) {
          const r1 = (c1>>16)&255, g1 = (c1>>8)&255, b1 = c1&255;
          const r2 = (c2>>16)&255, g2 = (c2>>8)&255, b2 = c2&255;
          const r = Math.floor(lerp(r1,r2,t));
          const g = Math.floor(lerp(g1,g2,t));
          const b = Math.floor(lerp(b1,b2,t));
          return (r<<16)|(g<<8)|b;
        }

        // ===== Surge speed window modifier =====
        const SURGE = {
          period: 9.0,
          active: 1.2,
          mult: 1.22
        };

        // ===== Blackout pulse modifier =====
        const BLACKOUT = {
          period: 10.5,
          active: 0.65,
          alpha: 0.35
        };

        // ===== Scenes =====
        class MenuScene extends Phaser.Scene {
          constructor() { super("Menu"); }
          create() {
            // More appealing menu: animated neon backdrop + particles + frame
            this.cameras.main.setBackgroundColor(0x05050f);

            const bg = this.add.graphics();
            const frame = this.add.graphics();

            // particles
            const dots = [];
            for (let i=0;i<36;i++){
              const d = this.add.circle(
                Phaser.Math.Between(0,W),
                Phaser.Math.Between(0,H),
                Phaser.Math.Between(1,3),
                0x6ef3ff
              ).setAlpha(Phaser.Math.FloatBetween(0.08, 0.22));
              d._vx = Phaser.Math.FloatBetween(-12, 12);
              d._vy = Phaser.Math.FloatBetween(18, 62);
              dots.push(d);
            }

            // glow bars
            const bars = [];
            for (let i=0;i<6;i++){
              const r = this.add.rectangle(
                Phaser.Math.Between(30, W-30),
                Phaser.Math.Between(0, H),
                Phaser.Math.Between(80, 170),
                8,
                0xff4d7d
              ).setAlpha(0.06);
              r._vy = Phaser.Math.FloatBetween(20, 70);
              bars.push(r);
            }

            // scanlines
            const scan = this.add.graphics().setAlpha(0.13);
            scan.lineStyle(1, 0x2a2a55, 1);
            for (let y=0;y<H;y+=10){
              scan.beginPath(); scan.moveTo(0,y); scan.lineTo(W,y); scan.strokePath();
            }

            // Title block
            const title = this.add.text(W/2, H*0.18, "GRIDRUN", {
              fontFamily: uiFont,
              fontSize: "52px",
              color: "#ffffff"
            }).setOrigin(0.5).setAlpha(0.98);

            // (removed the line you asked to remove)

            // Buttons
            const accent = "#6ef3ff";
            makeButton(this, "CAMPAIGN", W/2, H*0.44, () => this.scene.start("WorldMap"), accent);
            makeButton(this, "ENDLESS", W/2, H*0.54, () => this.scene.start("EndlessIntro"), "#7cffd2");

            // Add color to Leaderboards + Reset Saves (keep ghost style but with color)
            const lbBtn = makeGhostButton(this, "LEADERBOARDS", W/2, H*0.64, () => this.scene.start("Leaderboards"));
            lbBtn.setStyle({ backgroundColor: "rgba(255,176,255,0.22)" });

            const rsBtn = makeGhostButton(this, "RESET SAVES", W/2, H*0.76, () => { resetAllSaves(); this.scene.restart(); });
            rsBtn.setStyle({ backgroundColor: "rgba(255,209,102,0.22)" });
            rsBtn.setAlpha(0.85);

            const p = loadProgress();
            this.totalText = this.add.text(W/2, H*0.86, `Campaign Total: ${campaignTotalScore(p)}`, {
              fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.75)"
            }).setOrigin(0.5);

            this.add.text(W/2, H*0.92, "Mobile: drag anywhere on the grid to move. Tap PAUSE to pause.", {
              fontFamily: uiFont, fontSize:"11px", color:"rgba(255,255,255,0.55)"
            }).setOrigin(0.5);

            this.t = 0;
            this.events.on("update", (_, dtMs) => {
              const dt = dtMs/1000;
              this.t += dt;

              // gradient-ish background
              bg.clear();
              const a = 0.10 + 0.05*Math.sin(this.t*0.7);
              bg.fillStyle(0x6ef3ff, a);
              bg.fillRect(-40, H*0.12 + 30*Math.sin(this.t*0.9), W+80, 120);
              bg.fillStyle(0xff4d7d, 0.06 + 0.04*Math.sin(this.t*0.6+1.4));
              bg.fillRect(-40, H*0.62 + 30*Math.sin(this.t*0.8+2.1), W+80, 120);

              // frame
              frame.clear();
              frame.lineStyle(2, 0x2a2a55, 0.9);
              frame.strokeRoundedRect(18, 18, W-36, H-36, 18);
              frame.lineStyle(1, 0x6ef3ff, 0.25);
              frame.strokeRoundedRect(26, 26, W-52, H-52, 16);

              // animate dots
              for (const d of dots) {
                d.x += d._vx * dt;
                d.y += d._vy * dt;
                if (d.y > H+10) { d.y = -10; d.x = Phaser.Math.Between(0,W); }
                if (d.x < -10) d.x = W+10;
                if (d.x > W+10) d.x = -10;
              }

              for (const r of bars) {
                r.y += r._vy * dt;
                if (r.y > H+30) { r.y = -30; r.x = Phaser.Math.Between(30,W-30); }
              }

              // subtle title pulse
              title.setAlpha(0.92 + 0.06*Math.sin(this.t*1.1));
            });
          }
        }

        class LeaderboardsScene extends Phaser.Scene {
          constructor() { super("Leaderboards"); }
          create() {
            this.cameras.main.setBackgroundColor(0x070710);
            addTitle(this, "LEADERBOARDS", 0.14, 32);
            addSubtitle(this, "Local device scores (global later)", 0.20);

            const p = loadProgress();
            const lb = loadLeaderboards();

            const campaignNow = campaignTotalScore(p);
            const endlessBest = lb.endlessTop[0]?.score || 0;

            this.add.text(W/2, H*0.27, `Your Campaign Total: ${campaignNow}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.9);

            this.add.text(W/2, H*0.31, `Your Endless Best: ${endlessBest}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.85);

            const drawList = (title, arr, x, y) => {
              this.add.text(x, y, title, { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" }).setOrigin(0,0);
              let yy = y + 18;
              if (!arr.length) {
                this.add.text(x, yy, "— none yet —", { fontFamily: uiFont, fontSize:"12px", color:"rgba(255,255,255,0.55)" }).setOrigin(0,0);
                return;
              }
              arr.forEach((e, i) => {
                this.add.text(x, yy, `${i+1}. ${e.score}`, { fontFamily: uiFont, fontSize:"12px", color:"#ffffff" })
                  .setOrigin(0,0).setAlpha(0.9);
                if (e.meta) {
                  this.add.text(x+70, yy, e.meta, { fontFamily: uiFont, fontSize:"11px", color:"rgba(255,255,255,0.55)" })
                    .setOrigin(0,0);
                }
                yy += 18;
              });
            };

            drawList("Campaign Total Top 10", lb.campaignTop, 34, H*0.38);
            drawList("Endless Top 10", lb.endlessTop, 240, H*0.38);

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldMapScene extends Phaser.Scene {
          constructor() { super("WorldMap"); }
          create() {
            const p = loadProgress();
            this.cameras.main.setBackgroundColor(0x070710);

            addTitle(this, "CAMPAIGN", 0.14, 34);
            addSubtitle(this, "Replay unlocked levels • Total = sum of level bests", 0.20);

            const total = campaignTotalScore(p);
            this.add.text(W/2, H*0.24, `Campaign Total: ${total}`, { fontFamily: uiFont, fontSize:"14px", color:"#ffffff" })
              .setOrigin(0.5).setAlpha(0.85);

            const marginX = 18;
            const colW = (W - marginX*2);
            let y = H*0.28;

            WORLDS.forEach((w, wi) => {
              const unlockedWorld = wi <= p.unlockedWorld;

              const sub = worldSubtotal(p, wi);
              this.add.text(marginX, y, `${wi+1}. ${w.name}`, {
                fontFamily: uiFont, fontSize: "16px",
                color: unlockedWorld ? "#ffffff" : "rgba(255,255,255,0.40)"
              }).setAlpha(0.95);

              this.add.text(W - marginX, y, `Subtotal: ${sub}`, {
                fontFamily: uiFont, fontSize: "12px", color: "rgba(255,255,255,0.65)"
              }).setOrigin(1,0).setAlpha(0.9);

              y += 26;

              const gap = 10;
              const btnW = (colW - gap*(LEVELS_PER_WORLD-1)) / LEVELS_PER_WORLD;
              for (let li = 0; li < LEVELS_PER_WORLD; li++) {
                const unlocked = isLevelUnlocked(p, wi, li);
                const bx = marginX + li * (btnW + gap);
                const by = y;

                const best = p.levelBest[levelId(wi, li)] || 0;
                const label = `${li+1}\n${best}`;

                const b = this.add.text(bx + btnW/2, by + 22, label, {
                  fontFamily: uiFont,
                  fontSize: "12px",
                  align: "center",
                  color: unlocked ? "#0a0a12" : "rgba(255,255,255,0.55)",
                  backgroundColor: unlocked ? "#6ef3ff" : "rgba(255,255,255,0.08)",
                  padding: { left: 0, right: 0, top: 8, bottom: 8 }
                }).setOrigin(0.5);

                b.setFixedSize(btnW, 44);
                if (unlocked) {
                  b.setInteractive({ useHandCursor: true });
                  b.on("pointerdown", () => {
                    const p2 = loadProgress();
                    p2.currentWorld = wi;
                    p2.currentLevel = li;
                    saveProgress(p2);
                    this.scene.start("WorldIntro", { world: wi, level: li });
                  });
                } else {
                  b.setAlpha(0.6);
                }
              }

              y += 68;
            });

            makeGhostButton(this, "BACK", W/2, H*0.92, () => this.scene.start("Menu"));
          }
        }

        class WorldIntroScene extends Phaser.Scene {
          constructor() { super("WorldIntro"); }
          create(data) {
            const world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            const level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);

            const w = WORLDS[world];
            const lv = w.levels[level];

            this.cameras.main.setBackgroundColor(w.bg);
            buildBackdrop(this, w.fx, w.player, w.border);

            addTitle(this, w.name, 0.20, 34);
            addSubtitle(this, w.subtitle, 0.26);

            const p = loadProgress();
            const best = p.levelBest[levelId(world, level)] || 0;

            this.add.text(W/2, H*0.40,
              `Level ${level + 1}/${LEVELS_PER_WORLD} • ${lv.seconds}s\nBest: ${best}`,
              { fontFamily: uiFont, fontSize: "16px", color: "#ffffff", align: "center" }
            ).setOrigin(0.5).setAlpha(0.92);

            const p2 = loadProgress();
            p2.currentWorld = world;
            p2.currentLevel = level;
            saveProgress(p2);

            makeButton(this, "START", W/2, H*0.58, () => this.scene.start("Play", { mode:"campaign", world, level }), "#6ef3ff");
            makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.70, () => this.scene.start("WorldMap"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.80, () => this.scene.start("Menu"));
          }
        }

        class EndlessIntroScene extends Phaser.Scene {
          constructor() { super("EndlessIntro"); }
          create() {
            this.cameras.main.setBackgroundColor(0x050512);
            addTitle(this, "ENDLESS", 0.20, 36);
            addSubtitle(this, "Starts at World 1 Level 1 difficulty • Changes begin early • Vertical lasers added later", 0.27);

            const lb = loadLeaderboards();
            const best = lb.endlessTop[0]?.score || 0;

            this.add.text(W/2, H*0.40, `Best: ${best}`, {
              fontFamily: uiFont, fontSize:"18px", color:"#ffffff"
            }).setOrigin(0.5).setAlpha(0.9);

            makeButton(this, "START ENDLESS", W/2, H*0.58, () => this.scene.start("Play", { mode:"endless" }), "#7cffd2");
            makeGhostButton(this, "LEADERBOARDS", W/2, H*0.70, () => this.scene.start("Leaderboards"));
            makeGhostButton(this, "MAIN MENU", W/2, H*0.80, () => this.scene.start("Menu"));
          }
        }

        // ===== Play Scene =====
        class PlayScene extends Phaser.Scene {
          constructor() {
            super("Play");
            this.mode = "campaign";
            this.world = 0;
            this.level = 0;

            this.wcfg = WORLDS[0];
            this.lcfg = WORLDS[0].levels[0];

            this.t = 0;
            this.rawTime = 0;
            this.score = 0;
            this.paused = false;

            this.countdown = 0;
            this.canMove = false;

            this.survivalPts = 0;
            this.nearPts = 0;
            this.clearBonusPts = 0;
            this.combo = 1;
            this.comboTimer = 0;
            this.maxCombo = 1;

            this.scrollSpeed = 0;
            this.baseScroll = 0;
            this.spawnEvery = 0;
            this.spawnTimer = 0;

            this.surgeMult = 1;

            this.blackoutOn = false;

            this.gridGraphics = null;
            this.gridOffset = 0;

            this.obstacles = null;
            this.player = null;

            this.touchTarget = null;
            this.touchDot = null;

            this.pauseBtn = null;
            this.pauseOverlay = null;

            this.hLaser = null;
            this.hLaserWarn = null;
            this.vLaser = null;
            this.vLaserWarn = null;

            this.bossT = 0;
            this.hLaserMode = "off";
            this.vLaserMode = "off";

            this.flash = null;
            this.blackout = null;

            this.decor = [];
          }

          init(data) {
            this.mode = data?.mode || "campaign";
            if (this.mode === "campaign") {
              this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
              this.level = clamp(data?.level ?? 0, 0, LEVELS_PER_WORLD - 1);
              this.wcfg = WORLDS[this.world];
              this.lcfg = this.wcfg.levels[this.level];
            } else {
              this.world = 0;
              this.level = 0;
              this.wcfg = WORLDS[0];
              this.lcfg = WORLDS[0].levels[0];
            }
          }

          create() {
            ensureObstacleTextures(this);

            this.cameras.main.setBackgroundColor(this.wcfg.bg);
            buildBackdrop(this, this.wcfg.fx, this.wcfg.player, this.wcfg.border);

            this.gridGraphics = this.add.graphics();
            this.gridOffset = 0;

            this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

            const startX = GRID_X + GRID_W / 2;
            const startY = GRID_Y + GRID_H * 0.72;

            this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
            this.physics.add.existing(this.player);
            this.player.body.setAllowGravity(false);

            this.physics.add.overlap(this.player, this.obstacles, () => this.endRun({ reason: "OBSTACLE" }));

            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys("W,A,S,D,ESC");

            this.flash = this.add.rectangle(W/2, H/2, W, H, 0xffffff).setAlpha(0).setDepth(200);
            this.blackout = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0).setDepth(180);

            this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0).setDepth(50);
            this.touchTarget = null;

            this.uiTop = this.add.text(14, 10, "", { fontFamily: uiFont, fontSize: "14px", color: "#ffffff" }).setAlpha(0.95).setDepth(60);
            this.uiSub = this.add.text(14, 30, "", { fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff" }).setAlpha(0.95).setDepth(60);
            this.uiCombo = this.add.text(W-14, 10, "", { fontFamily: uiFont, fontSize: "12px", color: "#ffffff" })
              .setOrigin(1,0).setAlpha(0.85).setDepth(60);

            // PAUSE button: fixed (topOnly + large hit rect + pointerdown priority)
            this.pauseBtn = this.add.text(W-14, 30, "PAUSE", {
              fontFamily: uiFont, fontSize: "12px",
              color: "#ffffff", backgroundColor: "rgba(255,255,255,0.16)",
              padding: { left: 10, right: 10, top: 6, bottom: 6 }
            }).setOrigin(1,0).setDepth(9999).setInteractive({ useHandCursor:true });

            this.input.topOnly = true;

            const pb = this.pauseBtn.getBounds();
            this.pauseBtn.input.hitArea.setTo(pb.x-24, pb.y-16, pb.width+38, pb.height+28);

            this.pauseBtn.on("pointerdown", (p) => {
              p.event?.stopPropagation?.();
              this.togglePause(!this.paused);
            });

            this.countText = this.add.text(W/2, H*0.42, "", {
              fontFamily: uiFont, fontSize:"54px", color:"#ffffff"
            }).setOrigin(0.5).setDepth(160).setAlpha(0);

            this.countSub = this.add.text(W/2, H*0.50, "", {
              fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff"
            }).setOrigin(0.5).setDepth(160).setAlpha(0);

            // Global pointer handlers: pause area gets ignored (never steals pause taps)
            this.uiNoTouchZone = { x: W-200, y: 0, w: 200, h: 100 };

            this.input.on("pointerdown", (p) => {
              if (this.paused) { this.togglePause(false); return; }
              if (this.isInNoTouchZone(p.x, p.y)) return;
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointermove", (p) => {
              if (!p.isDown || this.paused) return;
              if (this.isInNoTouchZone(p.x, p.y)) return;
              this.touchTarget = { x: p.x, y: p.y };
              this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
            });
            this.input.on("pointerup", () => {
              this.touchTarget = null;
              this.touchDot.setAlpha(0);
            });

            this.input.keyboard.on("keydown-ESC", () => this.togglePause(!this.paused));

            this.resetRunState();
            this.setupDecor();
            this.setupLasers();
            this.startCountdown(3);
          }

          isInNoTouchZone(x,y){
            const z = this.uiNoTouchZone;
            return x >= z.x && x <= z.x+z.w && y >= z.y && y <= z.y+z.h;
          }

          resetRunState(){
            this.t = 0;
            this.rawTime = 0;
            this.score = 0;
            this.paused = false;
            this.canMove = false;

            this.survivalPts = 0;
            this.nearPts = 0;
            this.clearBonusPts = 0;
            this.combo = 1;
            this.comboTimer = 0;
            this.maxCombo = 1;

            this.spawnTimer = 0;

            if (this.mode === "campaign") {
              this.baseScroll = this.lcfg.baseScroll;
              this.scrollSpeed = this.lcfg.baseScroll;
              this.spawnEvery = this.lcfg.spawnStart;
            } else {
              this.baseScroll = ENDLESS.baseScroll0;
              this.scrollSpeed = ENDLESS.baseScroll0;
              this.spawnEvery = ENDLESS.spawnStart0;
            }

            this.surgeMult = 1;
            this.blackoutOn = false;

            if (this.obstacles) {
              this.obstacles.children.iterate((o)=>{ if(o) o.destroy(); });
            }
          }

          startCountdown(n){
            this.countdown = n;
            this.countText.setAlpha(1);
            this.countSub.setAlpha(1);

            const show = (txt, subtxt) => {
              this.countText.setText(txt);
              this.countSub.setText(subtxt || "");
              this.countText.setScale(1.0);
              this.tweens.add({ targets: this.countText, scale: 1.10, yoyo: true, duration: 180, ease: "Sine.easeInOut" });
            };

            show(String(this.countdown), this.mode==="endless" ? "ENDLESS" : `${this.wcfg.name} • LEVEL ${this.level+1}`);

            this.time.addEvent({
              delay: 1000,
              repeat: n,
              callback: () => {
                this.countdown--;
                if (this.countdown > 0) {
                  show(String(this.countdown), "");
                } else if (this.countdown === 0) {
                  show("GO", "");
                  this.flash.setAlpha(0.10);
                  this.tweens.add({ targets: this.flash, alpha: 0, duration: 180, ease: "Linear" });
                  this.time.addEvent({
                    delay: 450,
                    callback: () => {
                      this.countText.setAlpha(0);
                      this.countSub.setAlpha(0);
                      this.canMove = true;
                    }
                  });
                }
              }
            });
          }

          togglePause(on){
            this.paused = on;

            if (on) {
              this.pauseOverlay = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0.55).setDepth(140);
              this.pauseText = this.add.text(W/2, H*0.44, "PAUSED", { fontFamily: uiFont, fontSize:"28px", color:"#ffffff" })
                .setOrigin(0.5).setDepth(141);
              this.pauseSub = this.add.text(W/2, H*0.52, "Tap anywhere to resume", { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" })
                .setOrigin(0.5).setDepth(141).setAlpha(0.9);
              this.pauseOverlay.setInteractive();
              this.pauseOverlay.on("pointerdown", () => this.togglePause(false));
            } else {
              if (this.pauseOverlay) this.pauseOverlay.destroy();
              if (this.pauseText) this.pauseText.destroy();
              if (this.pauseSub) this.pauseSub.destroy();
              this.pauseOverlay = null;
            }
          }

          setupDecor() {
            for (const d of this.decor) d.destroy();
            this.decor = [];

            if (this.wcfg.gridStyle === "industrial") {
              for (let i = 0; i < 8; i++) {
                const r = this.add.rectangle(GRID_X - 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                const r2 = this.add.rectangle(GRID_X + GRID_W + 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
                this.decor.push(r, r2);
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              for (let i=0;i<16;i++){
                const b = this.add.rectangle(
                  Phaser.Math.Between(0, W),
                  Phaser.Math.Between(-H, H),
                  Phaser.Math.Between(10, 26),
                  Phaser.Math.Between(4, 12),
                  0x9aa7ff
                ).setAlpha(Phaser.Math.FloatBetween(0.05, 0.12));
                b._vy = Phaser.Math.FloatBetween(40, 110);
                this.decor.push(b);
              }
            }
          }

          setupLasers() {
            const boss = WORLDS[2].boss;

            this.hLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.warnThickness, 0xffffff)
              .setAlpha(0).setDepth(90);
            this.hLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.thickness, 0xff4d7d)
              .setAlpha(0).setDepth(91);

            this.vLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.warnThickness, GRID_H, 0xffffff)
              .setAlpha(0).setDepth(90);
            this.vLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.thickness, GRID_H, 0xff4d7d)
              .setAlpha(0).setDepth(91);

            this.bossT = 0;

            if (this.mode === "campaign") {
              this.hLaserMode = (this.world === 2) ? "active" : "off";
              this.vLaserMode = "off";
            } else {
              this.hLaserMode = "off";
              this.vLaserMode = "off";
            }
          }

          applyEndlessBlend(blend){
            const w1 = WORLDS[0], w2 = WORLDS[1], w3 = WORLDS[2];

            const bg12 = mixColor(w1.bg, w2.bg, blend.a2);
            const bg = mixColor(bg12, w3.bg, blend.a3);
            const border12 = mixColor(w1.border, w2.border, blend.a2);
            const border = mixColor(border12, w3.border, blend.a3);
            const grid12 = mixColor(w1.gridLine, w2.gridLine, blend.a2);
            const grid = mixColor(grid12, w3.gridLine, blend.a3);
            const player12 = mixColor(w1.player, w2.player, blend.a2);
            const player = mixColor(player12, w3.player, blend.a3);

            let gridStyle = "circuit";
            if (blend.a3 > 0.38) gridStyle = "glitch";
            else if (blend.a2 > 0.42) gridStyle = "industrial";

            const shapes = [
              ...w1.obstacleStyle.shapes,
              ...(blend.a2 > 0.18 ? w2.obstacleStyle.shapes : []),
              ...(blend.a3 > 0.18 ? w3.obstacleStyle.shapes : [])
            ];

            this.wcfg = {
              id: 99,
              name: "Endless",
              subtitle: "",
              bg, border, gridLine: grid, player,
              fx: (gridStyle==="glitch") ? "stars" : (gridStyle==="industrial" ? "rain" : "scanlines"),
              gridStyle,
              obstacleStyle: {
                palette: [...w1.obstacleStyle.palette, ...w2.obstacleStyle.palette, ...w3.obstacleStyle.palette],
                shapes
              }
            };

            this.player.fillColor = player;
            this.touchDot.fillColor = player;

            if (!this._lastGridStyle) this._lastGridStyle = this.wcfg.gridStyle;
            if (this._lastGridStyle !== this.wcfg.gridStyle) {
              this._lastGridStyle = this.wcfg.gridStyle;
              this.setupDecor();
            }

            this.blackoutEnabled = !!blend.blackout;

            this.hLaserMode = blend.laserWarn ? (blend.laserActive ? "active" : "warn") : "off";
            this.vLaserMode = blend.verticalLaser ? (blend.laserActive ? "active" : "warn") : "off";
          }

          update(_, deltaMs){
            if (this.paused) return;

            const dt = deltaMs/1000;
            this.rawTime += dt;

            if (!this.canMove) {
              this.drawGrid(0.0001);
              this.updateHud();
              return;
            }

            this.t += dt;

            this.comboTimer += dt;
            if (this.comboTimer > COMBO_DECAY_SEC) this.combo = 1;

            const phase = (this.t % SURGE.period);
            const inSurge = phase < SURGE.active;
            this.surgeMult = inSurge ? SURGE.mult : 1.0;

            if (this.mode === "endless" && this.blackoutEnabled) {
              const bp = (this.t % BLACKOUT.period);
              this.blackoutOn = bp < BLACKOUT.active;
              this.blackout.setAlpha(this.blackoutOn ? BLACKOUT.alpha : 0);
            } else {
              this.blackout.setAlpha(0);
            }

            let timeLeft = 0;

            if (this.mode === "campaign") {
              timeLeft = Math.max(0, this.lcfg.seconds - this.t);

              if (this.t >= this.lcfg.seconds) {
                this.clearBonusPts += LEVEL_CLEAR_BONUS;
                this.score += LEVEL_CLEAR_BONUS;
                this.levelComplete();
                return;
              }

              this.baseScroll = this.lcfg.baseScroll + this.t * this.lcfg.scrollRamp;
              this.scrollSpeed = this.baseScroll * this.surgeMult;

              const targetSpawn = this.lcfg.spawnStart - this.t * this.lcfg.spawnRamp;
              this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);

            } else {
              const blend = getEndlessBlend(this.t);
              this.applyEndlessBlend(blend);

              const base = ENDLESS.baseScroll0 + (this.t * ENDLESS.scrollBaseGrowth);
              const ramp = ENDLESS.ramp0 + this.t * ENDLESS.scrollRampGrowth;
              this.baseScroll = base + this.t * ramp;
              this.scrollSpeed = this.baseScroll * this.surgeMult;

              const spawnStart = ENDLESS.spawnStart0 - this.t * (ENDLESS.spawnTighten);
              const spawnRamp = ENDLESS.spawnRamp0 + this.t * ENDLESS.spawnRampGrowth;
              const targetSpawn = spawnStart - this.t * spawnRamp;
              this.spawnEvery = clamp(targetSpawn, ENDLESS.spawnMinFloor, ENDLESS.spawnStart0);
            }

            const add = SCORE_PPS * dt;
            this.survivalPts += add;
            this.score += add;

            if (!IS_TOUCH) {
              let kvx = 0, kvy = 0;
              const left = this.cursors.left.isDown || this.keys.A.isDown;
              const right = this.cursors.right.isDown || this.keys.D.isDown;
              const up = this.cursors.up.isDown || this.keys.W.isDown;
              const down = this.cursors.down.isDown || this.keys.S.isDown;
              if (left) kvx -= 1;
              if (right) kvx += 1;
              if (up) kvy -= 1;
              if (down) kvy += 1;
              const mag = Math.hypot(kvx, kvy);
              if (mag > 1) { kvx /= mag; kvy /= mag; }
              this.player.body.setVelocity(kvx * PLAYER_SPEED, kvy * PLAYER_SPEED);
            } else {
              if (this.touchTarget) {
                const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
                const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

                const dx = tx - this.player.x;
                const dy = ty - this.player.y;
                const dist = Math.hypot(dx, dy);

                if (dist > FOLLOW_RADIUS) {
                  const nx = this.player.x + dx * FOLLOW_LERP;
                  const ny = this.player.y + dy * FOLLOW_LERP;

                  const maxStep = PLAYER_SPEED * FOLLOW_MAX_SPEED_MULT * dt;
                  const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);

                  if (stepDist > maxStep) {
                    const s = maxStep / stepDist;
                    this.player.x = this.player.x + (nx - this.player.x) * s;
                    this.player.y = this.player.y + (ny - this.player.y) * s;
                  } else {
                    this.player.x = nx;
                    this.player.y = ny;
                  }

                  this.player.body.reset(this.player.x, this.player.y);
                } else {
                  this.player.body.setVelocity(0, 0);
                }
              } else {
                this.player.body.setVelocity(0, 0);
              }
            }

            const pad = 14;
            const px = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
            const py = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
            if (px !== this.player.x || py !== this.player.y) {
              this.player.x = px; this.player.y = py;
              this.player.body.reset(px, py);
            }

            if (this.wcfg.gridStyle === "glitch") {
              for (const b of this.decor) {
                b.y += b._vy * dt;
                if (b.y > H + 20) { b.y = -20; b.x = Phaser.Math.Between(0, W); }
              }
              if (Math.random() < 0.012) {
                this.flash.setAlpha(0.04);
                this.tweens.add({ targets: this.flash, alpha: 0, duration: 120, ease: "Linear" });
              }
            }

            this.spawnTimer += deltaMs;
            while (this.spawnTimer >= this.spawnEvery) {
              this.spawnTimer -= this.spawnEvery;
              this.spawnObstacle();
            }

            this.obstacles.children.iterate((o) => {
              if (!o) return;
              o.y += this.scrollSpeed * dt;
              if (o.y > GRID_Y + GRID_H + 140) { o.destroy(); return; }
              this.checkNearMiss(o);
            });

            this.updateLasers(dt);

            this.drawGrid(dt);
            this.updateHud(timeLeft);
          }

          updateHud(timeLeft){
            const modeLabel = this.mode === "campaign"
              ? `Campaign • ${this.wcfg.name} L${this.level+1}`
              : "Endless";

            const tLabel = this.mode === "campaign"
              ? `Time: ${Math.ceil(timeLeft)}s`
              : `Time: ${formatTime(this.t)}`;

            const surgeLabel = (this.surgeMult > 1.01) ? " • SURGE" : "";
            const blackoutLabel = (this.blackoutOn) ? " • BLACKOUT" : "";

            this.uiTop.setText(`${modeLabel} • Score: ${Math.floor(this.score)}${surgeLabel}${blackoutLabel}`);
            this.uiSub.setText(`${tLabel} • Near: ${Math.floor(this.nearPts)} • PPS: ${SCORE_PPS}`);

            const cm = Math.min(COMBO_MAX, this.combo);
            this.uiCombo.setText(cm > 1.01 ? `x${cm.toFixed(2)}` : "");
          }

          drawGrid(dt){
            this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
            const g = this.gridGraphics;
            g.clear();

            g.lineStyle(2, this.wcfg.border, 0.92);
            g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

            if (this.wcfg.gridStyle === "circuit") {
              g.lineStyle(1, this.wcfg.gridLine, 0.95);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.fillStyle(this.wcfg.player, 0.12);
              for (let c = 0; c <= GRID_COLS; c++) {
                for (let r = 0; r <= GRID_ROWS; r++) {
                  if ((c + r) % 3 !== 0) continue;
                  g.fillCircle(GRID_X + c*TILE, GRID_Y + r*TILE, 2.2);
                }
              }
            }

            if (this.wcfg.gridStyle === "industrial") {
              g.lineStyle(2, this.wcfg.gridLine, 0.9);
              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
              }
              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
              }
              g.lineStyle(1, 0xffd166, 0.07);
              for (let x = GRID_X - GRID_H; x < GRID_X + GRID_W + GRID_H; x += 18) {
                g.beginPath();
                g.moveTo(x, GRID_Y);
                g.lineTo(x + GRID_H, GRID_Y + GRID_H);
                g.strokePath();
              }
            }

            if (this.wcfg.gridStyle === "glitch") {
              const flick = 0.75 + Math.sin(this.t * 8) * 0.10;
              g.lineStyle(1, this.wcfg.gridLine, flick);

              for (let c = 0; c <= GRID_COLS; c++) {
                const x = GRID_X + c * TILE;
                let y0 = GRID_Y;
                while (y0 < GRID_Y + GRID_H) {
                  const seg = Phaser.Math.Between(18, 64);
                  const gap = Phaser.Math.Between(10, 40);
                  if (Math.random() > 0.22) {
                    g.beginPath();
                    g.moveTo(x, y0);
                    g.lineTo(x, Math.min(GRID_Y + GRID_H, y0 + seg));
                    g.strokePath();
                  }
                  y0 += seg + gap;
                }
              }

              for (let r = -1; r <= GRID_ROWS + 1; r++) {
                const y = GRID_Y + r * TILE + this.gridOffset - TILE;
                let x0 = GRID_X;
                while (x0 < GRID_X + GRID_W) {
                  const seg = Phaser.Math.Between(20, 70);
                  const gap = Phaser.Math.Between(12, 44);
                  if (Math.random() > 0.25) {
                    g.beginPath();
                    g.moveTo(x0, y);
                    g.lineTo(Math.min(GRID_X + GRID_W, x0 + seg), y);
                    g.strokePath();
                  }
                  x0 += seg + gap;
                }
              }
            }
          }

          spawnObstacle(){
            const col = Phaser.Math.Between(0, GRID_COLS - 1);
            const x = GRID_X + col * TILE + TILE / 2;
            const y = GRID_Y - 70;

            const style = this.wcfg.obstacleStyle;
            const shapes = style.shapes;
            const shape = shapes[Phaser.Math.Between(0, shapes.length - 1)];
            const tex = shapeToTex[shape] || "obs_rect";
            const palette = style.palette;
            const color = palette[Phaser.Math.Between(0, palette.length - 1)];

            let smin = 20, smax = 32;
            if (this.mode === "campaign") {
              const [a,b] = this.lcfg.size;
              smin = a; smax = b;
            } else {
              smin = clamp(22 - Math.floor(this.t/120), 16, 22);
              smax = clamp(34 - Math.floor(this.t/140), 22, 34);
            }

            let w = Phaser.Math.Between(smin, smax);
            let h = Phaser.Math.Between(smin, smax);

            if (shape === "bar") { w = Phaser.Math.Between(smax+8, smax+26); h = Phaser.Math.Between(14, 22); }
            if (shape === "tri") { w = Phaser.Math.Between(smin, smax+4); h = Phaser.Math.Between(smin, smax+8); }
            if (shape === "frame") { w = Phaser.Math.Between(smin+2, smax+10); h = Phaser.Math.Between(smin+2, smax+10); }
            if (shape === "plus") { w = Phaser.Math.Between(smin, smax+10); h = Phaser.Math.Between(smin, smax+10); }

            const s = this.add.image(x, y, tex);
            s.setTint(color);
            s.setAlpha(0.95);
            s.displayWidth = w;
            s.displayHeight = h;

            this.physics.add.existing(s);
            s.body.setAllowGravity(false);
            s.body.setImmovable(true);
            s.body.setSize(w * 0.88, h * 0.88, true);
            s._nearAwarded = false;
            this.obstacles.add(s);

            let chance = 0.06;
            if (this.mode === "campaign") {
              const worldBonus = this.world * 0.02;
              const later = this.level >= 2 ? 1 : 0;
              chance = Phaser.Math.Clamp(0.05 + later*0.06 + worldBonus + (this.t * 0.0022), 0.05, 0.24);
            } else {
              chance = Phaser.Math.Clamp(0.06 + (this.t * 0.0016), 0.06, 0.22);
            }

            if (Math.random() < chance && this.t > 5) {
              let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
              if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;
              const x2 = GRID_X + col2 * TILE + TILE / 2;

              const shape2 = shapes[Phaser.Math.Between(0, shapes.length - 1)];
              const tex2 = shapeToTex[shape2] || "obs_rect";
              const color2 = palette[Phaser.Math.Between(0, palette.length - 1)];

              const s2 = this.add.image(x2, y - Phaser.Math.Between(22, 90), tex2);
              s2.setTint(color2);
              s2.setAlpha(0.9);
              s2.displayWidth = Math.max(14, w * 0.78);
              s2.displayHeight = Math.max(14, h * 0.78);

              this.physics.add.existing(s2);
              s2.body.setAllowGravity(false);
              s2.body.setImmovable(true);
              s2.body.setSize(s2.displayWidth * 0.88, s2.displayHeight * 0.88, true);
              s2._nearAwarded = false;

              this.obstacles.add(s2);
            }
          }

          checkNearMiss(o){
            if (!o || o._nearAwarded) return;
            const dy = Math.abs(o.y - this.player.y);
            if (dy > 28) return;
            const dx = Math.abs(o.x - this.player.x);
            const dist = Math.hypot(dx, dy);
            if (dist <= NEAR_DIST) {
              o._nearAwarded = true;

              this.comboTimer = 0;
              this.combo = Math.min(COMBO_MAX, this.combo + COMBO_STEP);
              this.maxCombo = Math.max(this.maxCombo, this.combo);

              const award = NEAR_POINTS * this.combo;
              this.nearPts += award;
              this.score += award;
            }
          }

          updateLasers(dt){
            const boss = WORLDS[2].boss;
            this.bossT += dt;

            const cycle = boss.cycleSeconds;
            const t = this.bossT % cycle;

            const warnOn = t < boss.warnSeconds;
            const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

            const driftY = (this.bossT * 0.22) % 1;
            const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + driftY) % 1);
            this.hLaserWarn.setPosition(GRID_X + GRID_W/2, yPos);
            this.hLaser.setPosition(GRID_X + GRID_W/2, yPos);

            const driftX = (this.bossT * 0.19 + 0.37) % 1;
            const xPos = GRID_X + 20 + (GRID_W - 40) * ((t / cycle + driftX) % 1);
            this.vLaserWarn.setPosition(xPos, GRID_Y + GRID_H/2);
            this.vLaser.setPosition(xPos, GRID_Y + GRID_H/2);

            const applyBeam = (mode, warnRect, activeRect) => {
              if (mode === "off") { warnRect.setAlpha(0); activeRect.setAlpha(0); return; }
              if (mode === "warn") { warnRect.setAlpha(warnOn ? 0.30 : 0); activeRect.setAlpha(0); return; }
              warnRect.setAlpha(warnOn ? 0.30 : 0);
              activeRect.setAlpha(activeOn ? 0.85 : 0);
            };

            applyBeam(this.hLaserMode, this.hLaserWarn, this.hLaser);
            applyBeam(this.vLaserMode, this.vLaserWarn, this.vLaser);

            if (activeOn) {
              const pr = this.player.getBounds();

              if (this.hLaserMode === "active") {
                const lr = this.hLaser.getBounds();
                if (Phaser.Geom.Intersects.RectangleToRectangle(pr, lr)) this.endRun({ reason: "H-LASER" });
              }
              if (this.vLaserMode === "active") {
                const vr = this.vLaser.getBounds();
                if (Phaser.Geom.Intersects.RectangleToRectangle(pr, vr)) this.endRun({ reason: "V-LASER" });
              }
            }
          }

          levelComplete(){
            const p = loadProgress();
            const id = levelId(this.world, this.level);
            const thisScore = Math.floor(this.score);
            const prevBest = p.levelBest[id] || 0;

            let pbLevel = false;
            if (thisScore > prevBest) { p.levelBest[id] = thisScore; pbLevel = true; }

            let nextWorld = this.world;
            let nextLevel = this.level + 1;

            if (nextLevel >= LEVELS_PER_WORLD) { nextLevel = 0; nextWorld = this.world + 1; }

            if (nextWorld > p.unlockedWorld) {
              p.unlockedWorld = Math.min(WORLDS_COUNT-1, nextWorld);
              p.unlockedLevel = 0;
            } else if (nextWorld === p.unlockedWorld) {
              p.unlockedLevel = Math.max(p.unlockedLevel, nextLevel);
            }

            if (nextWorld >= WORLDS.length) {
              p.currentWorld = WORLDS.length - 1;
              p.currentLevel = LEVELS_PER_WORLD - 1;
            } else {
              p.currentWorld = nextWorld;
              p.currentLevel = nextLevel;
            }

            saveProgress(p);

            const total = campaignTotalScore(p);
            const lb = loadLeaderboards();
            lb.campaignTop = maybeInsertTop(lb.campaignTop, { score: total, meta: "Total" });
            saveLeaderboards(lb);

            this.scene.start("Results", {
              mode: "campaign",
              world: this.world,
              level: this.level,
              score: thisScore,
              prevBest,
              pb: pbLevel,
              total,
              breakdown: this.getBreakdown(),
              reason: "CLEAR"
            });
          }

          getBreakdown(){
            return {
              survival: Math.floor(this.survivalPts),
              near: Math.floor(this.nearPts),
              clear: Math.floor(this.clearBonusPts),
              maxCombo: Number(this.maxCombo.toFixed(2))
            };
          }

          endRun({reason}){
            const thisScore = Math.floor(this.score);

            this.flash.setAlpha(0.10);
            this.tweens.add({ targets: this.flash, alpha: 0, duration: 170, ease: "Linear" });

            if (this.mode === "endless") {
              const lb = loadLeaderboards();
              const prevBest = lb.endlessTop[0]?.score || 0;
              const pb = thisScore > prevBest;

              lb.endlessTop = maybeInsertTop(lb.endlessTop, { score: thisScore, meta: formatTime(this.t) });
              saveLeaderboards(lb);

              this.scene.start("Results", {
                mode: "endless",
                score: thisScore,
                prevBest,
                pb,
                total: null,
                breakdown: this.getBreakdown(),
                reason
              });
              return;
            }

            const p = loadProgress();
            const id = levelId(this.world, this.level);
            const prevBest = p.levelBest[id] || 0;
            const total = campaignTotalScore(p);

            this.scene.start("Results", {
              mode: "campaign",
              world: this.world,
              level: this.level,
              score: thisScore,
              prevBest,
              pb: false,
              total,
              breakdown: this.getBreakdown(),
              reason
            });
          }
        }

        class ResultsScene extends Phaser.Scene {
          constructor() { super("Results"); }
          create(data) {
            this.cameras.main.setBackgroundColor(0x070710);

            const mode = data?.mode || "campaign";
            const score = data?.score || 0;
            const prevBest = data?.prevBest || 0;
            const pb = !!data?.pb;
            const total = data?.total;
            const reason = data?.reason || "";

            const breakdown = data?.breakdown || { survival:0, near:0, clear:0, maxCombo:1 };

            addTitle(this, mode === "endless" ? "ENDLESS RESULT" : "LEVEL RESULT", 0.16, 30);

            const subtitle =
              mode === "endless"
                ? `Reason: ${reason}`
                : `${WORLDS[data.world].name} • Level ${data.level+1} • ${reason==="CLEAR"?"CLEARED":"FAILED"}`;

            addSubtitle(this, subtitle, 0.22);

            this.add.text(W/2, H*0.34, `Score: ${score}`, {
              fontFamily: uiFont, fontSize:"24px", color:"#ffffff"
            }).setOrigin(0.5).setAlpha(0.95);

            this.add.text(W/2, H*0.40, `Best: ${Math.max(prevBest, (pb?score:prevBest))}${pb ? "  •  NEW PB!" : ""}`, {
              fontFamily: uiFont, fontSize:"14px", color: pb ? "#6ef3ff" : "#b7b7ff"
            }).setOrigin(0.5).setAlpha(0.95);

            const lines = [
              `Survival: ${breakdown.survival}`,
              `Near-miss: ${breakdown.near}`,
              `Clear Bonus: ${breakdown.clear}`,
              `Max Combo: x${breakdown.maxCombo}`
            ];
            this.add.text(W/2, H*0.52, lines.join("\n"), {
              fontFamily: uiFont, fontSize:"14px", color:"rgba(255,255,255,0.85)", align:"center"
            }).setOrigin(0.5);

            if (mode === "campaign") {
              this.add.text(W/2, H*0.66, `Campaign Total: ${total}`, {
                fontFamily: uiFont, fontSize:"14px", color:"#ffffff"
              }).setOrigin(0.5).setAlpha(0.85);

              makeButton(this, "RETRY", W/2, H*0.76, () => this.scene.start("Play", { mode:"campaign", world:data.world, level:data.level }), "#6ef3ff");
              makeGhostButton(this, "CAMPAIGN MAP", W/2, H*0.85, () => this.scene.start("WorldMap"));
            } else {
              makeButton(this, "RETRY ENDLESS", W/2, H*0.76, () => this.scene.start("Play", { mode:"endless" }), "#7cffd2");
              makeGhostButton(this, "LEADERBOARDS", W/2, H*0.85, () => this.scene.start("Leaderboards"));
            }

            makeGhostButton(this, "MAIN MENU", W/2, H*0.93, () => this.scene.start("Menu"));
          }
        }

        new Phaser.Game({
          type: Phaser.AUTO,
          width: W,
          height: H,
          physics: { default: "arcade", arcade: { debug: false } },
          scene: [
            MenuScene,
            LeaderboardsScene,
            WorldMapScene,
            WorldIntroScene,
            EndlessIntroScene,
            PlayScene,
            ResultsScene
          ],
        });

      }, 50);
    });
  </script>
</body>
</html>