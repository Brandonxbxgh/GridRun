<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GRIDRUN</title>
  <style>
    /* Reset and General Styling */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Verdana', sans-serif;
      background: linear-gradient(135deg, #1a1c30, #292942, #1a1c30);
      animation: backgroundMove 10s infinite alternate;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }

    /* Background Animation */
    @keyframes backgroundMove {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    canvas {
      background: #000;
      border: 3px solid #fff;
      display: block;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Canvas will be dynamically added here -->
  </div>

  <script>
    // Gameplay variables
    let canvas, ctx;
    let player, obstacles, gameState, gridSize, gridCellSize;
    let touchPosition = null; // Tracks the current touch position
    
    // Start Grid Gameplay
    function startGridGameplay() {
      initializeCanvas();
      initializeGameObjects();

      // Add touch listeners for movement
      canvas.addEventListener("touchstart", updateTouchPosition);
      canvas.addEventListener("touchmove", updateTouchPosition);
      canvas.addEventListener("touchend", clearTouchPosition);

      gameLoop();
    }

    // Initialize the canvas (responsive to device size)
    function initializeCanvas() {
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");

      // Portrait layout (taller than wide)
      gridSize = { cols: 7, rows: 12 }; // 7x12 grid for mobile
      const aspectRatio = gridSize.cols / gridSize.rows;
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      // Dynamically set canvas dimensions
      canvas.width = Math.min(screenWidth, screenHeight * aspectRatio); // Width adapts to fit the height
      canvas.height = canvas.width / aspectRatio;

      document.body.appendChild(canvas);
      gridCellSize = canvas.width / gridSize.cols; // Size of each grid cell
    }

    // Initialize player and obstacle data
    function initializeGameObjects() {
      const startX = Math.floor(gridSize.cols / 2);
      const startY = gridSize.rows - 2; // Start near the bottom-center of the grid
      player = {
        x: startX,
        y: startY,
        size: gridCellSize * 0.9, // Slightly smaller than a grid cell
        color: "#0f0",
        speed: 4, // Player movement speed
      };
      obstacles = []; // Spawned obstacles
      spawnObstacles();
      gameState = { running: true, score: 0 };
    }

    // Touch control: update player target position
    function updateTouchPosition(event) {
      const rect = canvas.getBoundingClientRect();
      const touch = event.touches[0]; // Get the first touch point
      touchPosition = {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top,
      };
      event.preventDefault(); // Prevent unwanted scroll/zoom
    }

    function clearTouchPosition() {
      touchPosition = null; // Stop following movement
    }

    // Move the player toward the touch position
    function movePlayer() {
      if (!touchPosition) return; // No touch events are active, do nothing

      const targetX = Math.floor(touchPosition.x / gridCellSize);
      const targetY = Math.floor(touchPosition.y / gridCellSize);

      const deltaX = targetX - player.x;
      const deltaY = targetY - player.y;

      // Smooth movement towards the target
      player.x += Math.sign(deltaX) * Math.min(Math.abs(deltaX), player.speed / gridCellSize);
      player.y += Math.sign(deltaY) * Math.min(Math.abs(deltaY), player.speed / gridCellSize);
    }

    // Game Loop
    function gameLoop() {
      if (!gameState.running) return;

      updateGame();
      renderGame();

      requestAnimationFrame(gameLoop);
    }

    // Update Game State
    function updateGame() {
      movePlayer();
      checkCollisions();
    }

    // Render Game
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the grid
      ctx.strokeStyle = "#444";
      for (let i = 0; i < gridSize.cols; i++) {
        for (let j = 0; j < gridSize.rows; j++) {
          ctx.strokeRect(i * gridCellSize, j * gridCellSize, gridCellSize, gridCellSize);
        }
      }

      // Draw the player
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(
        (player.x + 0.5) * gridCellSize,
        (player.y + 0.5) * gridCellSize,
        player.size / 2,
        0,
        2 * Math.PI
      );
      ctx.fill();

      // Draw obstacles
      ctx.fillStyle = "red";
      for (const obs of obstacles) {
        ctx.fillRect(
          obs.x * gridCellSize,
          obs.y * gridCellSize,
          gridCellSize,
          gridCellSize
        );
      }
    }

    // Spawn obstacles randomly
    function spawnObstacles() {
      for (let i = 0; i < 3; i++) {
        const randomX = Math.floor(Math.random() * gridSize.cols);
        const randomY = Math.floor(Math.random() * (gridSize.rows / 2)); // Spawn in top half of the grid

        obstacles.push({ x: randomX, y: randomY });
      }
    }

    // Check for collisions
    function checkCollisions() {
      for (const obs of obstacles) {
        if (Math.abs(obs.x - player.x) < 1 && Math.abs(obs.y - player.y) < 1) {
          endGame();
        }
      }
    }

    // End game logic
    function endGame() {
      gameState.running = false;

      // Display game over screen
      alert(`Game Over! Final Score: ${gameState.score}`);
      document.body.innerHTML = ""; // Clear the screen
      location.reload(); // Reload the game
    }

    // Start the game
    startGridGameplay();
  </script>
</body>
</html>