<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>TXC GRIDRUN</title>
  <style>
    :root{
      --bg0:#070812;
      --bg1:#0b0f25;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --line:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);

      --accent:#6ee7ff;
      --accent2:#b7ff6e;
      --warn:#ff6ee7;
      --danger:#ff4d4d;

      --btn:#141a38;
      --btnH:#1b2350;

      --lb:#2a1a55;
      --lbH:#3a2580;
      --reset:#5a1f1f;
      --resetH:#7a2b2b;

      --shadow: 0 14px 45px rgba(0,0,0,.45);
      --radius: 18px;
    }

    *{box-sizing:border-box;}
    html,body{height:100%; margin:0; color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background: radial-gradient(1200px 800px at 20% 15%, #1a1e4a 0%, var(--bg0) 55%, #02030a 100%);}
    button{font:inherit; color:inherit; -webkit-tap-highlight-color: transparent;}
    a{color:inherit}

    /* subtle animated grid background */
    .bg-grid{
      position:fixed; inset:0; pointer-events:none; opacity:.18;
      background:
        linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
      background-size: 40px 40px;
      mask-image: radial-gradient(closest-side at 50% 45%, rgba(0,0,0,1), rgba(0,0,0,.25) 60%, rgba(0,0,0,0) 100%);
      animation: drift 14s linear infinite;
    }
    @keyframes drift{
      from{ transform: translate3d(0,0,0); }
      to{ transform: translate3d(-40px,-40px,0); }
    }

    .app{
      min-height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    .frame{
      width:min(740px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .topbar{
      padding:14px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-size:18px;
    }
    .glyph{
      width:34px; height:34px; border-radius:12px;
      background: conic-gradient(from 110deg, var(--accent), var(--warn), var(--accent2), var(--accent));
      box-shadow: 0 10px 30px rgba(110,231,255,.22);
      border:1px solid rgba(255,255,255,.14);
      flex:0 0 auto;
    }
    /* removed subtitle under GRIDRUN per request */

    .hud{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:flex-end;
      align-items:center;
      font-size:12.5px;
      color:rgba(255,255,255,.85);
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      display:flex; gap:8px; align-items:center;
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:800;}
    .pill .dot{width:8px; height:8px; border-radius:999px; background: var(--accent); box-shadow: 0 0 18px rgba(110,231,255,.35);}

    .content{
      padding:14px;
    }

    .screen{display:none;}
    .screen.active{display:block;}

    .card{
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:14px;
    }

    .titleRow{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .titleRow h2{
      margin:0;
      font-size:14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .titleRow .sub{
      font-size:12.5px;
      color:rgba(255,255,255,.65);
    }

    .btn{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, var(--btn), rgba(255,255,255,.02));
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
      display:flex; align-items:center; justify-content:space-between;
      touch-action: manipulation;
      user-select:none;
    }
    .btn:hover{background: linear-gradient(180deg, var(--btnH), rgba(255,255,255,.02));}
    .btn:active{transform: translateY(1px) scale(.998);}
    .btn:disabled{opacity:.45; cursor:not-allowed;}
    .hint{font-size:12px; color:var(--muted); letter-spacing:.06em;}

    .btn.lb{ background: linear-gradient(180deg, var(--lb), rgba(255,255,255,.02)); }
    .btn.lb:hover{ background: linear-gradient(180deg, var(--lbH), rgba(255,255,255,.02)); }
    .btn.reset{ background: linear-gradient(180deg, var(--reset), rgba(255,255,255,.02)); }
    .btn.reset:hover{ background: linear-gradient(180deg, var(--resetH), rgba(255,255,255,.02)); }

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    @media (max-width:560px){ .grid2{grid-template-columns:1fr;} }

    .stack{display:flex; flex-direction:column; gap:10px;}

    .note{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.35;
      margin-top:10px;
    }

    /* Game canvas */
    .gameWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }
    canvas{
      width:100%;
      max-width: 540px;
      aspect-ratio: 9/16;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(6,7,16,1), rgba(2,3,10,1));
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
      touch-action: none;
    }

    .gameActions{
      width:100%;
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .iconBtn{
      padding:10px 14px;
      border-radius:12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      cursor:pointer;
      transition:.15s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .iconBtn:hover{background: rgba(255,255,255,.09);}
    .iconBtn:active{transform: translateY(1px);}

    /* Modal overlay */
    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
      z-index:50;
    }
    .overlay.show{display:flex;}
    .modal{
      width:min(520px, 100%);
      background: rgba(10,12,26,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding:14px;
      box-shadow: var(--shadow);
    }
    .modal h3{margin:0 0 10px; font-size:14px; letter-spacing:.08em; text-transform:uppercase; color:rgba(255,255,255,.86);}
    .modal p{margin:0 0 10px; color:rgba(255,255,255,.76); font-size:13px; line-height:1.35;}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap;}
    .modal .row .btn{width:auto; flex:1 1 160px;}

    /* Leaderboard */
    .leaderboard{
      margin-top:10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
    }
    .lbHead{
      display:flex; justify-content:space-between; gap:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.10);
      font-size:12px; letter-spacing:.08em; text-transform:uppercase;
      color:rgba(255,255,255,.80);
    }
    .lbList{max-height: 320px; overflow:auto; background: rgba(0,0,0,.18);}
    .lbRow{
      display:grid;
      grid-template-columns: 42px 1fr 120px;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
      color:rgba(255,255,255,.84);
      align-items:center;
    }
    .lbRow:last-child{border-bottom:none;}
    .rank{
      width:28px; height:28px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      font-weight:800;
      color:rgba(255,255,255,.86);
    }
    .name{color:rgba(255,255,255,.86); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .score{font-variant-numeric: tabular-nums; text-align:right; font-weight:900; color:rgba(255,255,255,.92);}

  </style>
</head>

<body>
  <div class="bg-grid"></div>
  <div class="app">
    <div class="frame">
      <div class="topbar">
        <div class="brand">
          <div class="glyph"></div>
          <div>GRIDRUN</div>
        </div>

        <div class="hud">
          <div class="pill"><span class="dot"></span><span>Mode: <b id="statMode">Menu</b></span></div>
          <div class="pill"><span>Score: <b id="statScore">0</b></span></div>
          <div class="pill"><span>Time: <b id="statTime">0.0</b>s</span></div>
          <div class="pill"><span>Speed: <b id="statSpeed">1.00</b>x</span></div>
        </div>
      </div>

      <div class="content">

        <!-- MAIN MENU -->
        <div class="screen active" id="screenMain">
          <div class="card">
            <div class="titleRow">
              <h2>Main Menu</h2>
              <!-- subtitle removed per request -->
              <div class="sub">Fast • Skill-based • Off-chain gameplay</div>
            </div>

            <div class="stack">
              <button class="btn" id="btnCampaign">
                <span><b>Campaign</b></span>
                <span class="hint">worlds & levels</span>
              </button>

              <button class="btn" id="btnEndless">
                <span><b>Endless</b></span>
                <span class="hint">starts at W1-L1 difficulty</span>
              </button>

              <button class="btn lb" id="btnLeaderboards">
                <span><b>Leaderboards</b></span>
                <span class="hint">campaign / endless</span>
              </button>

              <div class="grid2">
                <button class="btn reset" id="btnResetSave">
                  <span><b>Reset Save</b></span>
                  <span class="hint">local only</span>
                </button>

                <button class="btn" id="btnExit">
                  <span><b>Exit</b></span>
                  <span class="hint">close tab</span>
                </button>
              </div>
            </div>

            <div class="note">
              Effects begin at <b>30 seconds</b> and stack earlier (glitch → scanlines → vertical lasers → invert).
              <br/>Campaign allows replay of any beaten level. Endless uses the same scoring, tracked separately.
            </div>
          </div>
        </div>

        <!-- CAMPAIGN SELECT -->
        <div class="screen" id="screenCampaign">
          <div class="card">
            <div class="titleRow">
              <h2>Campaign</h2>
              <div class="sub" id="campaignProgressText">—</div>
            </div>

            <div class="stack" id="campaignWorlds"></div>

            <div class="grid2" style="margin-top:10px;">
              <button class="btn" id="btnBackFromCampaign"><span><b>Back</b></span><span class="hint">menu</span></button>
              <button class="btn" id="btnStartCampaign" disabled><span><b>Start</b></span><span class="hint">select level</span></button>
            </div>

            <div class="note" id="campaignSelectedNote" style="display:none;"></div>
          </div>
        </div>

        <!-- ENDLESS CONFIRM -->
        <div class="screen" id="screenEndless">
          <div class="card">
            <div class="titleRow">
              <h2>Endless</h2>
              <div class="sub">Infinite run • ramping difficulty</div>
            </div>

            <div class="note">
              Endless starts at <b>World 1 – Level 1</b> difficulty (not easier) and ramps up continuously.
              <br/>Same scoring as Campaign, but a separate leaderboard.
            </div>

            <div class="grid2" style="margin-top:10px;">
              <button class="btn" id="btnBackFromEndless"><span><b>Back</b></span><span class="hint">menu</span></button>
              <button class="btn" id="btnStartEndless"><span><b>Start</b></span><span class="hint">run</span></button>
            </div>
          </div>
        </div>

        <!-- LEADERBOARDS -->
        <div class="screen" id="screenLeaderboards">
          <div class="card">
            <div class="titleRow">
              <h2>Leaderboards</h2>
              <div class="sub">separate boards • same scoring</div>
            </div>

            <div class="grid2">
              <button class="btn lb" id="lbShowCampaign"><span><b>Campaign</b></span><span class="hint">top scores</span></button>
              <button class="btn lb" id="lbShowEndless"><span><b>Endless</b></span><span class="hint">top scores</span></button>
            </div>

            <div class="leaderboard">
              <div class="lbHead">
                <span id="lbTitle">Campaign</span>
                <span id="lbCount">Top 10</span>
              </div>
              <div class="lbList" id="lbList"></div>
            </div>

            <div class="grid2" style="margin-top:10px;">
              <button class="btn" id="btnBackFromLB"><span><b>Back</b></span><span class="hint">menu</span></button>
              <button class="btn reset" id="btnClearLB"><span><b>Clear Boards</b></span><span class="hint">local</span></button>
            </div>

            <div class="note">
              Note: global leaderboards come later (backend). These are local for now.
            </div>
          </div>
        </div>

        <!-- GAME -->
        <div class="screen" id="screenGame">
          <div class="card">
            <div class="titleRow">
              <h2>Run</h2>
              <div class="sub" id="runLabel">—</div>
            </div>

            <div class="gameWrap">
              <canvas id="game" width="720" height="1280"></canvas>

              <div class="gameActions">
                <button class="iconBtn" id="btnPause" aria-label="Pause">Pause</button>
                <button class="iconBtn" id="btnRestart" aria-label="Restart">Restart</button>
                <button class="iconBtn" id="btnMenu" aria-label="Menu">Menu</button>
              </div>

              <!-- bottom control text removed per request -->
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- MODAL -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <h3 id="modalTitle">Paused</h3>
      <p id="modalText">Game paused.</p>
      <div class="row">
        <button class="btn" id="btnResume"><span><b>Resume</b></span></button>
        <button class="btn" id="btnModalRestart"><span><b>Restart</b></span></button>
        <button class="btn" id="btnToMenu"><span><b>Main Menu</b></span></button>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // SAVE / LEADERBOARDS
  // =========================
  const KEY_SAVE = "gridrun_save_v2";
  const KEY_LB_CAMPAIGN = "gridrun_lb_campaign_v2";
  const KEY_LB_ENDLESS = "gridrun_lb_endless_v2";

  // Worlds + levels restored (not "8 straight levels")
  // Adjust counts/names freely later.
  const WORLDS = [
    { id: 1, name: "World 1: Neon Alley", levels: 5 },
    { id: 2, name: "World 2: Signal Ruins", levels: 5 },
    { id: 3, name: "World 3: Rift Sector", levels: 5 },
    { id: 4, name: "World 4: Overclock District", levels: 5 }
  ];

  const totalLevels = WORLDS.reduce((a,w) => a + w.levels, 0);

  const defaultSave = () => ({
    campaign: {
      unlockedIndex: 1,        // 1..totalLevels (linear unlock)
      bestByIndex: {}          // index -> bestScore
    }
  });

  function loadSave(){
    try{
      const raw = localStorage.getItem(KEY_SAVE);
      if(!raw) return defaultSave();
      const obj = JSON.parse(raw);
      if(!obj || !obj.campaign) return defaultSave();
      if(typeof obj.campaign.unlockedIndex !== "number") obj.campaign.unlockedIndex = 1;
      if(!obj.campaign.bestByIndex || typeof obj.campaign.bestByIndex !== "object") obj.campaign.bestByIndex = {};
      obj.campaign.unlockedIndex = clampInt(obj.campaign.unlockedIndex, 1, totalLevels);
      return obj;
    }catch(_){ return defaultSave(); }
  }
  function saveSave(s){ localStorage.setItem(KEY_SAVE, JSON.stringify(s)); }

  function loadLB(key){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveLB(key, arr){ localStorage.setItem(key, JSON.stringify(arr)); }

  function addLeaderboardScore(mode, score, meta){
    const key = (mode === "campaign") ? KEY_LB_CAMPAIGN : KEY_LB_ENDLESS;
    const list = loadLB(key);

    const entry = {
      name: "Runner",
      score: Math.floor(score),
      ts: Date.now(),
      detail: meta || {}
    };

    list.push(entry);
    list.sort((a,b) => b.score - a.score || a.ts - b.ts);
    const trimmed = list.slice(0, 10);
    saveLB(key, trimmed);
    return trimmed;
  }

  // =========================
  // DOM
  // =========================
  const $ = (id) => document.getElementById(id);

  const screens = {
    main: $("screenMain"),
    campaign: $("screenCampaign"),
    endless: $("screenEndless"),
    lb: $("screenLeaderboards"),
    game: $("screenGame")
  };

  const statMode = $("statMode");
  const statScore = $("statScore");
  const statTime = $("statTime");
  const statSpeed = $("statSpeed");

  const runLabel = $("runLabel");

  const overlay = $("overlay");
  const modalTitle = $("modalTitle");
  const modalText = $("modalText");

  const campaignWorldsEl = $("campaignWorlds");
  const campaignProgressText = $("campaignProgressText");
  const campaignSelectedNote = $("campaignSelectedNote");
  const btnStartCampaign = $("btnStartCampaign");

  const lbListEl = $("lbList");
  const lbTitle = $("lbTitle");
  const lbCount = $("lbCount");

  let save = loadSave();

  function showScreen(name){
    Object.values(screens).forEach(s => s.classList.remove("active"));
    screens[name].classList.add("active");
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[c]));
  }

  // =========================
  // Campaign selection UI
  // =========================
  let selectedIndex = null; // linear level index across worlds

  function linearToWorldLevel(index){
    let acc = 0;
    for(const w of WORLDS){
      if(index <= acc + w.levels){
        return { worldId: w.id, worldName: w.name, level: index - acc, index };
      }
      acc += w.levels;
    }
    return { worldId: WORLDS[0].id, worldName: WORLDS[0].name, level: 1, index: 1 };
  }

  function worldLevelToLinear(worldId, level){
    let acc = 0;
    for(const w of WORLDS){
      if(w.id === worldId) return acc + level;
      acc += w.levels;
    }
    return 1;
  }

  function renderCampaignMenu(){
    const unlocked = clampInt(save.campaign.unlockedIndex, 1, totalLevels);
    campaignProgressText.textContent = `Unlocked: ${unlocked}/${totalLevels}`;

    selectedIndex = null;
    btnStartCampaign.disabled = true;
    campaignSelectedNote.style.display = "none";

    campaignWorldsEl.innerHTML = "";

    let runningIndex = 0;
    for(const w of WORLDS){
      const block = document.createElement("div");
      block.className = "card";
      block.style.marginBottom = "10px";

      const header = document.createElement("div");
      header.className = "titleRow";
      header.innerHTML = `<h2 style="margin:0;font-size:13px;letter-spacing:.08em;text-transform:uppercase;color:rgba(255,255,255,.86)">${escapeHtml(w.name)}</h2>
                          <div class="sub">Levels: ${w.levels}</div>`;
      block.appendChild(header);

      const grid = document.createElement("div");
      grid.className = "grid2";

      for(let lvl=1; lvl<=w.levels; lvl++){
        runningIndex += 1;
        const idx = runningIndex;

        const locked = idx > unlocked;
        const best = save.campaign.bestByIndex[String(idx)] || 0;

        const b = document.createElement("button");
        b.className = "btn";
        b.disabled = locked;
        b.innerHTML = `<span><b>Level ${lvl}</b> <span style="color:rgba(255,255,255,.65);font-weight:700;">• Best ${best}</span></span>
                       <span class="hint">${locked ? "locked" : "select"}</span>`;
        b.addEventListener("click", () => {
          selectedIndex = idx;
          btnStartCampaign.disabled = false;

          const wl = linearToWorldLevel(selectedIndex);
          campaignSelectedNote.style.display = "block";
          campaignSelectedNote.innerHTML =
            `<b>Selected:</b> ${escapeHtml(wl.worldName)} • Level ${wl.level}
             <br/>Effects start at <b>30s</b>. Vertical lasers included.`;
        }, {passive:true});

        grid.appendChild(b);
      }

      block.appendChild(grid);
      campaignWorldsEl.appendChild(block);
    }
  }

  // =========================
  // Leaderboards UI
  // =========================
  let currentLBMode = "campaign";
  function renderLeaderboards(mode){
    currentLBMode = mode;
    const key = (mode === "campaign") ? KEY_LB_CAMPAIGN : KEY_LB_ENDLESS;
    const list = loadLB(key);

    lbTitle.textContent = (mode === "campaign") ? "Campaign" : "Endless";
    lbCount.textContent = "Top 10";

    lbListEl.innerHTML = "";
    const shown = list.length ? list : Array.from({length:10}, () => ({name:"—", score:0, ts:0}));
    shown.slice(0,10).forEach((e, idx) => {
      const row = document.createElement("div");
      row.className = "lbRow";
      row.innerHTML = `
        <div class="rank">${idx+1}</div>
        <div class="name">${escapeHtml(e.name || "Runner")}</div>
        <div class="score">${Number(e.score||0).toLocaleString()}</div>
      `;
      lbListEl.appendChild(row);
    });
  }

  // =========================
  // Button wiring (tabs / screens)
  // =========================
  $("btnCampaign").addEventListener("click", () => { renderCampaignMenu(); showScreen("campaign"); }, {passive:true});
  $("btnEndless").addEventListener("click", () => { showScreen("endless"); }, {passive:true});
  $("btnLeaderboards").addEventListener("click", () => { renderLeaderboards("campaign"); showScreen("lb"); }, {passive:true});

  $("btnBackFromCampaign").addEventListener("click", () => showScreen("main"), {passive:true});
  $("btnBackFromEndless").addEventListener("click", () => showScreen("main"), {passive:true});
  $("btnBackFromLB").addEventListener("click", () => showScreen("main"), {passive:true});

  $("lbShowCampaign").addEventListener("click", () => renderLeaderboards("campaign"), {passive:true});
  $("lbShowEndless").addEventListener("click", () => renderLeaderboards("endless"), {passive:true});

  $("btnClearLB").addEventListener("click", () => {
    if(confirm("Clear local leaderboards (Campaign + Endless)?")){
      saveLB(KEY_LB_CAMPAIGN, []);
      saveLB(KEY_LB_ENDLESS, []);
      renderLeaderboards(currentLBMode);
    }
  }, {passive:true});

  $("btnResetSave").addEventListener("click", () => {
    if(confirm("Reset local save progress + best scores?")){
      save = defaultSave();
      saveSave(save);
      alert("Save reset.");
      renderCampaignMenu();
    }
  }, {passive:true});

  $("btnExit").addEventListener("click", () => { window.close(); }, {passive:true});

  // Start buttons
  $("btnStartCampaign").addEventListener("click", () => {
    if(!selectedIndex) return;
    const wl = linearToWorldLevel(selectedIndex);
    startCampaign(wl.worldId, wl.level, wl.index, wl.worldName);
  }, {passive:true});

  $("btnStartEndless").addEventListener("click", () => {
    startEndless();
  }, {passive:true});

  // =========================
  // GAME CORE
  // =========================
  const canvas = $("game");
  const ctx = canvas.getContext("2d", { alpha: true });

  // pointer controls (drag left/right)
  let inputX = 0.5;
  let dragging = false;

  canvas.addEventListener("pointerdown", (e) => {
    dragging = true;
    inputX = getPointerX(e);
    canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointermove", (e) => {
    if(!dragging) return;
    inputX = getPointerX(e);
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointerup", (e) => {
    dragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
  }, {passive:false});

  function getPointerX(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    return clamp(x, 0, 1);
  }

  // Robust mobile pause: pointerdown + preventDefault + stopPropagation
  function bindTap(btn, fn){
    btn.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      fn();
    }, {passive:false});
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, {passive:false});
  }

  const btnPause = $("btnPause");
  const btnRestart = $("btnRestart");
  const btnMenu = $("btnMenu");

  const btnResume = $("btnResume");
  const btnModalRestart = $("btnModalRestart");
  const btnToMenu = $("btnToMenu");

  bindTap(btnPause, () => { if(state.screen === "game") togglePause(); });
  bindTap(btnRestart, () => { if(state.screen === "game") restartRun(); });
  bindTap(btnMenu, () => { goToMenu(); });

  bindTap(btnResume, () => setPaused(false,false));
  bindTap(btnModalRestart, () => restartRun());
  bindTap(btnToMenu, () => goToMenu());

  // auto-pause on background (mobile safety)
  document.addEventListener("visibilitychange", () => {
    if(document.hidden && state.screen === "game" && !state.paused){
      setPaused(true,true);
    }
  }, {passive:true});
  window.addEventListener("blur", () => {
    if(state.screen === "game" && !state.paused){
      setPaused(true,true);
    }
  }, {passive:true});

  // State
  const state = {
    screen: "menu",         // menu | game
    mode: "endless",        // campaign | endless
    worldId: 1,
    worldName: WORLDS[0].name,
    level: 1,
    index: 1,               // linear level index
    paused: false,
    autoPaused: false,
    running: false,

    t: 0,
    score: 0,

    baseSpeed: 1.0,
    hazardRate: 1.0,

    player: { x: 0.5, y: 0.86, r: 18, inv: 0 },

    hazards: [],
    particles: [],

    effects: {
      glitch: false,
      shake: 0,
      scanlines: false,
      invert: false,
      lasers: false,
    },

    spawnAcc: 0,
    laserAcc: 0,
    glitchAcc: 0,
  };

  // Hazards
  function makeBlock(){
    const laneW = 1/7;
    const lane = Math.floor(rand(0, 7));
    const w = laneW * rand(1.4, 2.2);
    const x = (lane * laneW) + rand(0, laneW) - w/2;
    return {
      kind: "block",
      x: clamp(x, 0.02, 0.98 - w),
      y: -0.12,
      w, h: rand(0.04, 0.07),
      vx: rand(-0.10, 0.10) * pick([-1,1]),
      vy: rand(0.45, 0.72),
    };
  }

  function makeLaserVertical(){
    const x = rand(0.12, 0.88);
    const w = rand(0.03, 0.06);
    return {
      kind: "vlaser",
      x: x - w/2, w,
      phase: "warn",
      t: 0,
      warnTime: 0.65,
      fireTime: 0.55,
      fadeTime: 0.35
    };
  }

  // Utils
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function clampInt(v,a,b){ return Math.max(a, Math.min(b, v|0)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  // Scoring (same formula both modes; tracked separately)
  function scorePerSecond(){
    let mult = 1.0;
    if(state.effects.glitch) mult += 0.15;
    if(state.effects.scanlines) mult += 0.10;
    if(state.effects.invert) mult += 0.10;
    if(state.effects.lasers) mult += 0.20;
    mult *= (0.85 + state.baseSpeed * 0.35);
    return 30 * mult;
  }

  // Effects schedule: first effect at 30s, stack earlier
  function updateEffects(){
    const t = state.t;

    // Speed ramps steadily (Endless ramps forever; Campaign also ramps during a run)
    const speedRamp = 1 + (t * 0.010);
    state.baseSpeed = clamp(speedRamp, 1.0, 3.0);

    // Hazard rate ramp
    state.hazardRate = clamp(1 + (t * 0.012), 1, 3.4);

    // Begin at 30s
    state.effects.glitch = (t >= 30);
    state.effects.scanlines = (t >= 42);
    state.effects.lasers = (t >= 55);   // vertical lasers
    state.effects.invert = (t >= 75);

    // shake pops
    if(t >= 30 && Math.floor(t) % 12 === 0){
      state.effects.shake = Math.max(state.effects.shake, 6);
    }
  }

  // Pause
  function setPaused(p, auto){
    state.paused = p;
    state.autoPaused = !!auto;
    overlay.classList.toggle("show", p);

    btnPause.textContent = p ? "Resume" : "Pause";
    modalTitle.textContent = auto ? "Paused (Auto)" : (p ? "Paused" : "Paused");
    modalText.textContent = p
      ? `Score: ${Math.floor(state.score).toLocaleString()} • Time: ${state.t.toFixed(1)}s`
      : "Game paused.";
  }
  function togglePause(){
    setPaused(!state.paused, false);
  }

  // Start / Restart / Menu
  function startCampaign(worldId, level, index, worldName){
    state.mode = "campaign";
    state.worldId = worldId;
    state.level = level;
    state.index = index;
    state.worldName = worldName;
    startRun();
  }

  function startEndless(){
    state.mode = "endless";
    // Ensure endless starts at W1-L1 difficulty baseline
    state.worldId = 1;
    state.level = 1;
    state.index = 1;
    state.worldName = WORLDS[0].name;
    startRun();
  }

  function startRun(){
    state.screen = "game";
    state.running = true;
    state.paused = false;
    state.autoPaused = false;

    state.t = 0;
    state.score = 0;

    state.player.x = 0.5;
    state.player.inv = 0;

    state.hazards.length = 0;
    state.particles.length = 0;

    state.spawnAcc = 0;
    state.laserAcc = 0;
    state.glitchAcc = 0;

    state.effects.glitch = false;
    state.effects.scanlines = false;
    state.effects.invert = false;
    state.effects.lasers = false;
    state.effects.shake = 0;

    // Campaign baseline bumps by progression, but NEVER below W1-L1 baseline
    if(state.mode === "campaign"){
      const bump = (state.index - 1) * 0.03; // gentle progression
      state.baseSpeed = 1.0 + bump;
      state.hazardRate = 1.0 + bump;
    } else {
      state.baseSpeed = 1.0;
      state.hazardRate = 1.0;
    }

    // UI
    showScreen("game");
    overlay.classList.remove("show");

    const label = (state.mode === "campaign")
      ? `Campaign • ${state.worldName} • L${state.level}`
      : "Endless";
    runLabel.textContent = label;

    statMode.textContent = (state.mode === "campaign") ? `Campaign` : "Endless";
    setPaused(false,false);
  }

  function restartRun(){
    if(state.screen !== "game") return;
    startRun();
  }

  function goToMenu(){
    state.screen = "menu";
    state.running = false;
    setPaused(false,false);

    statMode.textContent = "Menu";
    statScore.textContent = "0";
    statTime.textContent = "0.0";
    statSpeed.textContent = "1.00";

    showScreen("main");
  }

  // End run / save / LB
  function endRun(){
    state.running = false;
    setPaused(true,false);

    // Update save + boards
    if(state.mode === "campaign"){
      const idxKey = String(state.index);
      const prevBest = save.campaign.bestByIndex[idxKey] || 0;
      if(state.score > prevBest){
        save.campaign.bestByIndex[idxKey] = Math.floor(state.score);
      }

      // Unlock next level if "completed"
      const unlockIf = (state.t >= 20) || (state.score >= 900);
      if(unlockIf){
        save.campaign.unlockedIndex = Math.max(save.campaign.unlockedIndex, Math.min(totalLevels, state.index + 1));
      }
      saveSave(save);

      addLeaderboardScore("campaign", state.score, { index: state.index, worldId: state.worldId, level: state.level });
    } else {
      addLeaderboardScore("endless", state.score, {});
    }
  }

  // =========================
  // Loop
  // =========================
  let last = performance.now();

  function tick(now){
    requestAnimationFrame(tick);

    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // Update HUD regardless
    statScore.textContent = Math.floor(state.score).toLocaleString();
    statTime.textContent = state.t.toFixed(1);
    statSpeed.textContent = state.baseSpeed.toFixed(2);

    if(state.screen !== "game"){
      draw(dt);
      return;
    }

    if(!state.running || state.paused){
      draw(dt);
      return;
    }

    // update
    state.t += dt;

    // effects schedule + difficulty
    updateEffects();

    // score
    state.score += scorePerSecond() * dt;

    // player move
    const targetX = dragging ? inputX : state.player.x;
    state.player.x += (targetX - state.player.x) * (1 - Math.pow(0.0005, dt));
    state.player.x = clamp(state.player.x, 0.07, 0.93);

    if(state.player.inv > 0) state.player.inv = Math.max(0, state.player.inv - dt);

    // spawning
    const baseSpawn = 0.55;
    const spawnInterval = clamp(baseSpawn / state.hazardRate, 0.20, 0.55);
    state.spawnAcc += dt;
    while(state.spawnAcc >= spawnInterval){
      state.spawnAcc -= spawnInterval;
      state.hazards.push(makeBlock());
    }

    // vertical lasers
    if(state.effects.lasers){
      const baseLaser = 1.45;
      const laserInterval = clamp(baseLaser / (0.7 + state.hazardRate*0.25), 0.65, 1.45);
      state.laserAcc += dt;
      if(state.laserAcc >= laserInterval){
        state.laserAcc = 0;
        state.hazards.push(makeLaserVertical());
      }
    }

    // glitch pulses
    if(state.effects.glitch){
      state.glitchAcc += dt;
      if(state.glitchAcc >= 0.18){
        state.glitchAcc = 0;
        state.effects.shake = Math.max(state.effects.shake, rand(2, 7));
      }
    }

    // hazards update
    for(let i = state.hazards.length - 1; i >= 0; i--){
      const h = state.hazards[i];

      if(h.kind === "block"){
        h.y += h.vy * dt * state.baseSpeed;
        h.x += h.vx * dt * (0.6 + state.baseSpeed*0.25);
        if(h.x < 0.02 || h.x + h.w > 0.98) h.vx *= -1;
        if(h.y > 1.15){
          state.hazards.splice(i,1);
          continue;
        }
      } else if(h.kind === "vlaser"){
        h.t += dt * state.baseSpeed;
        if(h.phase === "warn" && h.t >= h.warnTime){
          h.phase = "fire";
          h.t = 0;
          state.effects.shake = Math.max(state.effects.shake, 10);
        } else if(h.phase === "fire" && h.t >= h.fireTime){
          h.phase = "fade";
          h.t = 0;
        } else if(h.phase === "fade" && h.t >= h.fadeTime){
          state.hazards.splice(i,1);
          continue;
        }
      }
    }

    // collision
    const px = state.player.x, py = state.player.y, pr = state.player.r;
    const pRect = {
      x: px - pr/720,
      y: py - pr/1280,
      w: (pr*2)/720,
      h: (pr*2)/1280
    };

    for(const h of state.hazards){
      if(h.kind === "block"){
        const r = { x: h.x, y: h.y, w: h.w, h: h.h };
        if(rectOverlap(pRect, r)){
          spawnBurst(state.player.x, state.player.y);
          endRun();
          break;
        }
      } else if(h.kind === "vlaser"){
        if(h.phase === "fire"){
          const r = { x: h.x, y: 0, w: h.w, h: 1 };
          if(rectOverlap(pRect, r)){
            spawnBurst(state.player.x, state.player.y);
            endRun();
            break;
          }
        }
      }
    }

    // particles
    for(let i = state.particles.length - 1; i >= 0; i--){
      const p = state.particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 0.35 * dt;
      if(p.t > p.life) state.particles.splice(i,1);
    }

    // shake decay
    state.effects.shake *= Math.pow(0.02, dt);

    draw(dt);
  }

  function rectOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnBurst(x,y){
    for(let i=0;i<26;i++){
      state.particles.push({
        x,y,
        vx: rand(-0.6,0.6),
        vy: rand(-0.9,0.2),
        t:0,
        life: rand(0.35, 0.9)
      });
    }
  }

  // =========================
  // DRAW
  // =========================
  function draw(dt){
    const W = canvas.width, H = canvas.height;

    // shake
    const shake = Math.min(18, state.effects.shake);
    const sx = (Math.random()*2-1) * shake;
    const sy = (Math.random()*2-1) * shake;

    ctx.save();
    ctx.clearRect(0,0,W,H);

    ctx.translate(sx, sy);

    // background gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(20,22,50,0.95)");
    g.addColorStop(1, "rgba(0,0,0,0.95)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // grid lines
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    const grid = 54;
    for(let y=0;y<=H;y+=grid){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    for(let x=0;x<=W;x+=grid){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // lane glow
    ctx.globalAlpha = 0.20;
    const gg = ctx.createRadialGradient(W/2,H*0.65, 10, W/2,H*0.65, H*0.7);
    gg.addColorStop(0, "rgba(110,231,255,0.40)");
    gg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gg;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // hazards
    for(const h of state.hazards){
      if(h.kind === "block"){
        const x = h.x * W, y = h.y * H, w = h.w * W, hh = h.h * H;
        ctx.save();
        ctx.shadowColor = "rgba(255,110,231,0.35)";
        ctx.shadowBlur = 16;
        ctx.fillStyle = "rgba(255,110,231,0.85)";
        ctx.fillRect(x, y, w, hh);
        ctx.restore();

        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x+1, y+1, w-2, hh-2);
      } else if(h.kind === "vlaser"){
        const x = h.x * W, w = h.w * W;

        if(h.phase === "warn"){
          ctx.save();
          ctx.globalAlpha = 0.55;
          ctx.fillStyle = "rgba(110,231,255,0.15)";
          ctx.fillRect(x, 0, w, H);

          ctx.globalAlpha = 0.9;
          ctx.strokeStyle = "rgba(110,231,255,0.85)";
          ctx.setLineDash([12, 10]);
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x + w/2, 0);
          ctx.lineTo(x + w/2, H);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        } else if(h.phase === "fire"){
          ctx.save();
          ctx.shadowColor = "rgba(110,231,255,0.55)";
          ctx.shadowBlur = 28;
          ctx.fillStyle = "rgba(110,231,255,0.85)";
          ctx.fillRect(x, 0, w, H);
          ctx.restore();
        } else {
          const alpha = 1 - (h.t / h.fadeTime);
          ctx.save();
          ctx.globalAlpha = alpha * 0.8;
          ctx.fillStyle = "rgba(110,231,255,0.70)";
          ctx.fillRect(x, 0, w, H);
          ctx.restore();
        }
      }
    }

    // player
    const px = state.player.x * W;
    const py = state.player.y * H;
    const r = state.player.r;

    ctx.save();
    ctx.shadowColor = "rgba(183,255,110,0.45)";
    ctx.shadowBlur = 26;

    const jitter = (state.effects.glitch && state.running && !state.paused) ? rand(-3,3) : 0;
    ctx.translate(jitter, 0);

    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(183,255,110,0.92)";
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(px, py, r*0.45, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fill();
    ctx.restore();

    // particles
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillRect(p.x * W, p.y * H, 4, 4);
    }
    ctx.globalAlpha = 1;

    // scanlines
    if(state.effects.scanlines){
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      for(let y=0; y<H; y+=8){
        ctx.fillRect(0, y, W, 1);
      }
      ctx.restore();
    }

    // invert overlay
    if(state.effects.invert){
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "rgba(255,110,231,0.35)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    ctx.restore();
  }

  // =========================
  // INIT
  // =========================
  function init(){
    // screens
    showScreen("main");

    // render initial
    renderCampaignMenu();
    renderLeaderboards("campaign");

    // start in menu
    goToMenu();

    // loop
    requestAnimationFrame(tick);
  }

  init();

})();
</script>
</body>
</html>
