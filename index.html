<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no" />
  <title>GRIDRUN</title>
  <style>
    /* Reset and General Styling */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Verdana', sans-serif;
      background: linear-gradient(135deg, #1a1c30, #292942, #1a1c30);
      animation: backgroundMove 10s infinite alternate;
      height: 100vh;
      overflow: hidden;
      color: white;
    }

    @keyframes backgroundMove {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    #game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      text-align: center;
    }

    /* Phaser gameplay container (separate “screen”) */
    #phaser-container {
      display: none;
      width: 100%;
      height: 100%;
      justify-content: center;
      align-items: center;
    }

    canvas { display:block; margin:0 auto; }

    h1 {
      font-size: 3rem;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 20px #ff5733, 0 0 30px #ff5733;
    }

    p { font-size: 18px; margin: 10px 0; }

    button {
      margin: 8px;
      padding: 15px 30px;
      font-size: 1rem;
      font-weight: bold;
      color: white;
      background: linear-gradient(45deg, #ff5733, #ff8b3d);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4), 0 0 15px rgba(255, 87, 51, 0.7);
      transition: transform 0.2s, box-shadow 0.3s;
    }
    button:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 0 25px rgba(255, 110, 60, 1);
    }
    button:active {
      transform: translateY(2px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 79, 40, 0.9);
    }
    button:disabled{
      opacity: 0.35;
      cursor: not-allowed;
      filter: grayscale(0.25);
      box-shadow: none;
      transform: none;
    }

    .menu-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
      max-width: 520px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Main Menu -->
    <div class="menu-screen" id="main-menu">
      <h1>GRIDRUN</h1>
      <button onclick="loadModeSelect()">PLAY</button>
      <button onclick="alert('Login Placeholder')">LOGIN</button>
      <button onclick="alert('Coming Soon!')">SETTINGS</button>
    </div>
  </div>

  <div id="phaser-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>
    /***********************
     * LOCAL SAVE (menus)
     ***********************/
    const SAVE_KEY = "gridrun_dom_progress_v1";

    // Progress Model:
    // worldsUnlocked: 1..3
    // levelsUnlocked: array length 3 with int 1..5 representing how many levels unlocked in each world
    // bestScores: 3x5 int
    function defaultProgress() {
      return {
        worldsUnlocked: 1,
        levelsUnlocked: [1, 0, 0],
        bestScores: [
          [0,0,0,0,0],
          [0,0,0,0,0],
          [0,0,0,0,0],
        ],
        endlessBest: 0
      };
    }

    function loadProgress() {
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return defaultProgress();
        const p = JSON.parse(raw);
        const d = defaultProgress();
        // shallow merge + sanitize
        const out = { ...d, ...p };
        if (!Array.isArray(out.levelsUnlocked) || out.levelsUnlocked.length !== 3) out.levelsUnlocked = d.levelsUnlocked.slice();
        if (!Array.isArray(out.bestScores) || out.bestScores.length !== 3) out.bestScores = d.bestScores.map(r=>r.slice());
        for (let w=0; w<3; w++){
          if (!Array.isArray(out.bestScores[w]) || out.bestScores[w].length !== 5) out.bestScores[w] = [0,0,0,0,0];
          for (let l=0; l<5; l++) out.bestScores[w][l] = Math.max(0, Math.floor(out.bestScores[w][l] || 0));
        }
        out.worldsUnlocked = Math.max(1, Math.min(3, Math.floor(out.worldsUnlocked || 1)));
        out.levelsUnlocked = out.levelsUnlocked.map((x,i)=>Math.max(0, Math.min(5, Math.floor(x || 0))));
        out.endlessBest = Math.max(0, Math.floor(out.endlessBest || 0));
        return out;
      } catch {
        return defaultProgress();
      }
    }

    function saveProgress(p) {
      localStorage.setItem(SAVE_KEY, JSON.stringify(p));
    }

    let progress = loadProgress();

    /***********************
     * WORLD + LEVEL DATA (menus)
     ***********************/
    const worlds = [
      { name: "Neon Plains", description: "A beginner-friendly area to learn the game mechanics." },
      { name: "Quantum Abyss", description: "Faster movements and denser obstacles. Watch out!" },
      { name: "Hypernova Zone", description: "Master your skills in this high-intensity zone." },
    ];

    // Time-based clears + tier score targets (your current values)
    const levels = [
      { time: 30, scores: { bronze: 100, silver: 200, gold: 300 } },
      { time: 45, scores: { bronze: 150, silver: 300, gold: 450 } },
      { time: 60, scores: { bronze: 200, silver: 400, gold: 600 } },
      { time: 75, scores: { bronze: 250, silver: 500, gold: 750 } },
      { time: 90, scores: { bronze: 300, silver: 600, gold: 900 } },
    ];

    /***********************
     * MENU NAV
     ***********************/
    function loadModeSelect() {
      const container = document.getElementById("game-container");
      container.innerHTML = `
        <div class="menu-screen">
          <h1>Select Mode</h1>
          <button onclick="loadCampaignMode()">Campaign</button>
          <button onclick="loadEndlessIntro()">Endless</button>
          <button onclick="loadMainMenu()">Back</button>
        </div>
      `;
    }

    function loadCampaignMode() {
      progress = loadProgress();
      const container = document.getElementById("game-container");
      const worldButtons = worlds.map((world, i) => `
        <button onclick="loadWorld(${i + 1})" ${progress.worldsUnlocked > i ? '' : 'disabled'}>
          ${progress.worldsUnlocked > i ? world.name : 'Locked'}
        </button>
      `).join("");

      container.innerHTML = `
        <div class="menu-screen">
          <h1>Campaign</h1>
          <p>Select a World</p>
          ${worldButtons}
          <button onclick="loadModeSelect()">Back</button>
        </div>
      `;
    }

    function loadWorld(worldNumber) {
      progress = loadProgress();
      const container = document.getElementById("game-container");
      const levelsUnlocked = progress.levelsUnlocked[worldNumber - 1] || 0;

      const levelButtons = Array.from({ length: 5 }, (_, i) => {
        const unlocked = i < levelsUnlocked;
        const best = progress.bestScores[worldNumber-1]?.[i] || 0;
        return `
          <button onclick="loadLevelIntro(${worldNumber}, ${i + 1})" ${unlocked ? '' : 'disabled'}>
            ${unlocked ? `Level ${i + 1} (Best: ${best})` : 'Locked'}
          </button>
        `;
      }).join("");

      container.innerHTML = `
        <div class="menu-screen">
          <h1>${worlds[worldNumber - 1].name}</h1>
          <p>${worlds[worldNumber - 1].description}</p>
          ${levelButtons}
          <button onclick="loadCampaignMode()">Back</button>
        </div>
      `;
    }

    function loadLevelIntro(worldNumber, levelNumber) {
      progress = loadProgress();
      const levelData = levels[levelNumber - 1];
      const container = document.getElementById("game-container");
      const best = progress.bestScores[worldNumber-1]?.[levelNumber-1] || 0;

      container.innerHTML = `
        <div class="menu-screen">
          <h1>Level ${levelNumber} - ${worlds[worldNumber - 1].name}</h1>
          <p><strong>Requirement:</strong> Survive <strong>${levelData.time} seconds</strong></p>
          <p><strong>Your Best:</strong> ${best}</p>
          <p>Performance Tiers:</p>
          <ul style="list-style: none; padding: 0; text-align: left;">
            <li>Bronze: ${levelData.scores.bronze} points</li>
            <li>Silver: ${levelData.scores.silver} points</li>
            <li>Gold: ${levelData.scores.gold} points</li>
          </ul>
          <button onclick="playLevel(${worldNumber}, ${levelNumber})">Start</button>
          <button onclick="loadWorld(${worldNumber})">Back</button>
        </div>
      `;
    }

    function loadEndlessIntro(){
      progress = loadProgress();
      const container = document.getElementById("game-container");
      container.innerHTML = `
        <div class="menu-screen">
          <h1>Endless</h1>
          <p>Survive as long as you can. Difficulty ramps continuously.</p>
          <p><strong>Local Best:</strong> ${progress.endlessBest}</p>
          <button onclick="startGameplay({ mode:'endless' })">Start Endless</button>
          <button onclick="loadModeSelect()">Back</button>
        </div>
      `;
    }

    function loadMainMenu() {
      const container = document.getElementById("game-container");
      container.innerHTML = `
        <div class="menu-screen" id="main-menu">
          <h1>GRIDRUN</h1>
          <button onclick="loadModeSelect()">PLAY</button>
          <button onclick="alert('Login Placeholder')">LOGIN</button>
          <button onclick="alert('Coming Soon!')">SETTINGS</button>
        </div>
      `;
    }

    /***********************
     * START GAMEPLAY (Phaser)
     ***********************/
    function playLevel(worldNumber, levelNumber) {
      startGameplay({ mode: "campaign", world: worldNumber-1, level: levelNumber-1 });
    }

    function showMenus(){
      document.getElementById("phaser-container").style.display = "none";
      document.getElementById("game-container").style.display = "flex";
    }

    function showGameplay(){
      document.getElementById("game-container").style.display = "none";
      const ph = document.getElementById("phaser-container");
      ph.style.display = "flex";
    }

    // Exposed for Phaser scenes to call back into menus
    window.GRIDRUN = {
      // update progress on clear
      completeCampaignLevel: (worldIdx, levelIdx, score) => {
        const p = loadProgress();

        // best score
        p.bestScores[worldIdx][levelIdx] = Math.max(p.bestScores[worldIdx][levelIdx] || 0, score);

        // unlock logic: if cleared the latest unlocked level, unlock next
        const currentUnlocked = p.levelsUnlocked[worldIdx] || 0;
        if (currentUnlocked === (levelIdx + 1)) {
          p.levelsUnlocked[worldIdx] = Math.min(5, currentUnlocked + 1);

          // if finished world, unlock next world + level 1
          if (levelIdx === 4 && worldIdx < 2) {
            p.worldsUnlocked = Math.max(p.worldsUnlocked, worldIdx + 2);
            p.levelsUnlocked[worldIdx + 1] = Math.max(p.levelsUnlocked[worldIdx + 1] || 0, 1);
          }
        }

        saveProgress(p);
      },

      setEndlessBest: (score) => {
        const p = loadProgress();
        p.endlessBest = Math.max(p.endlessBest || 0, score);
        saveProgress(p);
      },

      backToLevelSelect: (worldIdx) => {
        showMenus();
        loadWorld(worldIdx + 1);
      },

      backToMainMenu: () => {
        showMenus();
        loadMainMenu();
      }
    };

    /***********************
     * PHASER GAMEPLAY MODULE
     ***********************/
    let phaserGame = null;

    function startGameplay(payload){
      showGameplay();

      if (!phaserGame) {
        phaserGame = createPhaserGame();
      }

      // jump to play scene with payload
      phaserGame.scene.stop("Results");
      phaserGame.scene.stop("Play");
      phaserGame.scene.start("Play", payload);
    }

    function createPhaserGame(){
      const W = 420, H = 760;
      const uiFont = "system-ui,-apple-system,Segoe UI,Roboto,sans-serif";

      // ===== GRID =====
      const GRID_COLS = 7, GRID_ROWS = 13, TILE = 52;
      const GRID_W = GRID_COLS * TILE, GRID_H = GRID_ROWS * TILE;
      const GRID_X = (W - GRID_W) / 2, GRID_Y = (H - GRID_H) / 2;

      // ===== Movement =====
      const PLAYER_SPEED = 320;
      const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

      // Mobile DIRECT FOLLOW tuning
      const FOLLOW_RADIUS = 7;
      const FOLLOW_LERP = 0.40;
      const FOLLOW_MAX_SPEED_MULT = 3.0;

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const lerp = (a,b,t) => a + (b-a)*t;

      // ===== Worlds visuals (mapped to your names) =====
      const WORLDS = [
        {
          id: 0,
          name: "Neon Plains",
          subtitle: "Beginner-friendly. Learn the flow.",
          bg: 0x070812,
          border: 0x2a2a55,
          gridLine: 0x20204a,
          player: 0x6ef3ff,
          fx: "scanlines",
          gridStyle: "circuit",
          obstacleStyle: { palette: [0xff4d7d, 0xff6aa2, 0xff7bd0], shapes: ["tri","hex","frame","rect"] },
        },
        {
          id: 1,
          name: "Quantum Abyss",
          subtitle: "Faster movement. Denser patterns.",
          bg: 0x050611,
          border: 0x3a4a88,
          gridLine: 0x243056,
          player: 0x7cffd2,
          fx: "rain",
          gridStyle: "industrial",
          obstacleStyle: { palette: [0xffd166, 0xff4d7d, 0x7cffd2], shapes: ["bar","plus","rect","frame"] },
        },
        {
          id: 2,
          name: "Hypernova Zone",
          subtitle: "High intensity. Laser hazards.",
          bg: 0x02030a,
          border: 0x4b4bb0,
          gridLine: 0x1e1f3f,
          player: 0x9aa7ff,
          fx: "stars",
          gridStyle: "glitch",
          obstacleStyle: { palette: [0xff4d7d, 0xffb0ff, 0x9aa7ff], shapes: ["hex","tri","bar","frame"] },
          boss: { enabled:true, cycleSeconds:5.7, warnSeconds:1.20, activeSeconds:1.12, thickness:16, warnThickness:6 }
        }
      ];

      // ===== Level difficulty generator (MEDIUM, slightly harder than easy) =====
      // Uses your per-level survival time.
      function mkLevelsForWorld(worldIndex){
        const base = [
          // World 1 baseline
          { baseScroll0: 84, baseScrollStep: 18, ramp0: 8.4, rampStep: 3.0, spawnStart0: 980, spawnStep: 110, spawnRamp0: 10.5, spawnRampStep: 3.0, spawnMin0: 500, spawnMinStep: 55, spawnMinFloor: 290, sizeMin0: 22, sizeMinStep: 1, sizeMax0: 34, sizeMaxStep: 1 },
          // World 2 baseline
          { baseScroll0: 96, baseScrollStep: 20, ramp0: 9.2, rampStep: 3.2, spawnStart0: 940, spawnStep: 120, spawnRamp0: 11.2, spawnRampStep: 3.2, spawnMin0: 480, spawnMinStep: 60, spawnMinFloor: 275, sizeMin0: 21, sizeMinStep: 1, sizeMax0: 33, sizeMaxStep: 1 },
          // World 3 baseline
          { baseScroll0: 104, baseScrollStep: 22, ramp0: 9.8, rampStep: 3.5, spawnStart0: 900, spawnStep: 125, spawnRamp0: 12.0, spawnRampStep: 3.5, spawnMin0: 460, spawnMinStep: 62, spawnMinFloor: 260, sizeMin0: 21, sizeMinStep: 1, sizeMax0: 33, sizeMaxStep: 1 },
        ][worldIndex];

        return levels.map((lv, i) => ({
          seconds: lv.time,
          baseScroll: base.baseScroll0 + base.baseScrollStep * i,
          scrollRamp: base.ramp0 + base.rampStep * i,
          spawnStart: base.spawnStart0 - base.spawnStep * i,
          spawnRamp: base.spawnRamp0 + base.spawnRampStep * i,
          spawnMin: Math.max(base.spawnMinFloor, base.spawnMin0 - base.spawnMinStep * i),
          size: [base.sizeMin0 - base.sizeMinStep*i, base.sizeMax0 - base.sizeMaxStep*i]
        }));
      }

      WORLDS[0].levels = mkLevelsForWorld(0);
      WORLDS[1].levels = mkLevelsForWorld(1);
      WORLDS[2].levels = mkLevelsForWorld(2);

      // ===== FX =====
      function buildBackdrop(scene, fxType, colorA, colorB) {
        const items = [];
        if (fxType === "scanlines") {
          const g = scene.add.graphics();
          g.setAlpha(0.20);
          g.lineStyle(1, colorB, 1);
          for (let y = 0; y < H; y += 8) {
            g.beginPath(); g.moveTo(0, y); g.lineTo(W, y); g.strokePath();
          }
          items.push(g);
        }
        if (fxType === "rain") {
          const drops = [];
          for (let i = 0; i < 42; i++) {
            const r = scene.add.rectangle(
              Phaser.Math.Between(0, W),
              Phaser.Math.Between(-H, H),
              2,
              Phaser.Math.Between(18, 48),
              colorB
            ).setAlpha(0.14);
            r._vy = Phaser.Math.FloatBetween(240, 460);
            drops.push(r);
          }
          scene.events.on("update", (_, dtMs) => {
            const dt = dtMs / 1000;
            for (const d of drops) {
              d.y += d._vy * dt;
              if (d.y > H + 60) { d.y = Phaser.Math.Between(-120, -20); d.x = Phaser.Math.Between(0, W); }
            }
          });
          items.push(...drops);
        }
        if (fxType === "stars") {
          const stars = [];
          for (let i = 0; i < 62; i++) {
            const s = scene.add.rectangle(
              Phaser.Math.Between(0, W),
              Phaser.Math.Between(0, H),
              2, 2, colorA
            ).setAlpha(Phaser.Math.FloatBetween(0.06, 0.28));
            s._vy = Phaser.Math.FloatBetween(12, 52);
            stars.push(s);
          }
          scene.events.on("update", (_, dtMs) => {
            const dt = dtMs / 1000;
            for (const s of stars) {
              s.y += s._vy * dt;
              if (s.y > H + 10) { s.y = -10; s.x = Phaser.Math.Between(0, W); }
            }
          });
          items.push(...stars);
        }
        return items;
      }

      // ===== Obstacle textures =====
      function ensureObstacleTextures(scene) {
        const makeTex = (key, drawFn) => {
          if (scene.textures.exists(key)) return;
          const g = scene.make.graphics({ x:0, y:0, add:false });
          g.clear();
          drawFn(g);
          g.generateTexture(key, 64, 64);
          g.destroy();
        };

        makeTex("obs_rect", (g) => { g.fillStyle(0xffffff, 1); g.fillRoundedRect(8, 8, 48, 48, 10); });
        makeTex("obs_frame", (g) => {
          g.lineStyle(6, 0xffffff, 1);
          g.strokeRoundedRect(10, 10, 44, 44, 10);
          g.lineStyle(2, 0xffffff, 0.7);
          g.strokeRoundedRect(16, 16, 32, 32, 8);
        });
        makeTex("obs_tri", (g) => {
          g.fillStyle(0xffffff, 1);
          g.beginPath(); g.moveTo(32, 8); g.lineTo(56, 56); g.lineTo(8, 56); g.closePath(); g.fillPath();
          g.lineStyle(2, 0xffffff, 0.35); g.strokePath();
        });
        makeTex("obs_hex", (g) => {
          g.fillStyle(0xffffff, 1);
          const pts = [{x:32,y:6},{x:54,y:18},{x:54,y:46},{x:32,y:58},{x:10,y:46},{x:10,y:18}];
          g.beginPath(); g.moveTo(pts[0].x, pts[0].y);
          for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
          g.closePath(); g.fillPath();
          g.lineStyle(2, 0xffffff, 0.35); g.strokePath();
        });
        makeTex("obs_bar", (g) => {
          g.fillStyle(0xffffff, 1);
          g.fillRoundedRect(6, 24, 52, 16, 8);
          g.lineStyle(2, 0xffffff, 0.35);
          g.strokeRoundedRect(6, 24, 52, 16, 8);
        });
        makeTex("obs_plus", (g) => {
          g.fillStyle(0xffffff, 1);
          g.fillRoundedRect(26, 10, 12, 44, 5);
          g.fillRoundedRect(10, 26, 44, 12, 5);
          g.lineStyle(2, 0xffffff, 0.35);
          g.strokeRoundedRect(26, 10, 12, 44, 5);
          g.strokeRoundedRect(10, 26, 44, 12, 5);
        });
      }

      const shapeToTex = { rect:"obs_rect", frame:"obs_frame", tri:"obs_tri", hex:"obs_hex", bar:"obs_bar", plus:"obs_plus" };

      // ===== Scoring (MEDIUM) =====
      const SCORE_PPS = 12;

      // Your request: near-miss is hard → increase threshold slightly
      const NEAR_DIST = 38;        // was ~30
      const NEAR_POINTS = 20;

      const COMBO_DECAY_SEC = 1.35;
      const COMBO_STEP = 0.12;
      const COMBO_MAX = 3.25;

      const LEVEL_CLEAR_BONUS = 160;

      // Extra bonus mechanic: survival streak bonus
      const STREAK_EVERY = 10;     // seconds
      const STREAK_BONUS = 85;     // points each streak

      function formatTime(sec) {
        const m = Math.floor(sec / 60);
        const s = Math.floor(sec % 60);
        return m > 0 ? `${m}:${String(s).padStart(2,"0")}` : `${s}s`;
      }

      // ===== Endless blending =====
      const ENDLESS = {
        baseScroll0: WORLDS[0].levels[0].baseScroll,
        ramp0: WORLDS[0].levels[0].scrollRamp,
        spawnStart0: WORLDS[0].levels[0].spawnStart,
        spawnRamp0: WORLDS[0].levels[0].spawnRamp,
        spawnMinFloor: 230,

        scrollRampGrowth: 0.012,
        scrollBaseGrowth: 0.025,
        spawnTighten: 0.26,
        spawnRampGrowth: 0.012,

        // earlier effects
        t_industrial: 25,
        t_glitch: 48,
        t_blackout: 58,
        t_laserWarnOnly: 72,
        t_laserActive: 96,
        t_verticalLaser: 125
      };

      function getEndlessBlend(t) {
        const w1 = 1;
        const w2 = clamp((t - ENDLESS.t_industrial) / 55, 0, 1);
        const w3 = clamp((t - ENDLESS.t_glitch) / 65, 0, 1);
        const total = w1 + w2 + w3;

        return {
          a1: w1/total, a2: w2/total, a3: w3/total,
          blackout: t >= ENDLESS.t_blackout,
          laserWarn: t >= ENDLESS.t_laserWarnOnly,
          laserActive: t >= ENDLESS.t_laserActive,
          verticalLaser: t >= ENDLESS.t_verticalLaser
        };
      }

      function mixColor(c1, c2, t) {
        const r1 = (c1>>16)&255, g1 = (c1>>8)&255, b1 = c1&255;
        const r2 = (c2>>16)&255, g2 = (c2>>8)&255, b2 = c2&255;
        const r = Math.floor(lerp(r1,r2,t));
        const g = Math.floor(lerp(g1,g2,t));
        const b = Math.floor(lerp(b1,b2,t));
        return (r<<16)|(g<<8)|b;
      }

      // ===== Surge speed window modifier =====
      const SURGE = { period: 9.0, active: 1.2, mult: 1.22 };

      // ===== Blackout pulse modifier =====
      const BLACKOUT = { period: 10.5, active: 0.65, alpha: 0.35 };

      // ===== Play Scene =====
      class PlayScene extends Phaser.Scene {
        constructor() {
          super("Play");
          this.mode = "campaign";
          this.world = 0;
          this.level = 0;

          this.wcfg = WORLDS[0];
          this.lcfg = WORLDS[0].levels[0];

          this.t = 0;
          this.rawTime = 0;
          this.score = 0;
          this.paused = false;

          this.countdown = 0;
          this.canMove = false;

          this.survivalPts = 0;
          this.nearPts = 0;
          this.clearBonusPts = 0;
          this.combo = 1;
          this.comboTimer = 0;
          this.maxCombo = 1;

          this.scrollSpeed = 0;
          this.baseScroll = 0;
          this.spawnEvery = 0;
          this.spawnTimer = 0;

          this.surgeMult = 1;

          this.blackoutOn = false;
          this.blackoutEnabled = false;

          this.gridGraphics = null;
          this.gridOffset = 0;

          this.obstacles = null;
          this.player = null;

          this.touchTarget = null;
          this.touchDot = null;

          this.pauseBtn = null;
          this.pauseOverlay = null;

          this.hLaser = null;
          this.hLaserWarn = null;
          this.vLaser = null;
          this.vLaserWarn = null;

          this.bossT = 0;
          this.hLaserMode = "off";
          this.vLaserMode = "off";

          this.flash = null;
          this.blackout = null;

          this.decor = [];

          // streak
          this._lastStreakTick = 0;
        }

        init(data) {
          this.mode = data?.mode || "campaign";
          if (this.mode === "campaign") {
            this.world = clamp(data?.world ?? 0, 0, WORLDS.length - 1);
            this.level = clamp(data?.level ?? 0, 0, 4);
            this.wcfg = WORLDS[this.world];
            this.lcfg = this.wcfg.levels[this.level];
          } else {
            this.world = 0;
            this.level = 0;
            this.wcfg = WORLDS[0];
            this.lcfg = WORLDS[0].levels[0];
          }
        }

        create() {
          ensureObstacleTextures(this);

          this.cameras.main.setBackgroundColor(this.wcfg.bg);
          buildBackdrop(this, this.wcfg.fx, this.wcfg.player, this.wcfg.border);

          this.gridGraphics = this.add.graphics();
          this.gridOffset = 0;

          this.obstacles = this.physics.add.group({ immovable: true, allowGravity: false });

          const startX = GRID_X + GRID_W / 2;
          const startY = GRID_Y + GRID_H * 0.72;

          this.player = this.add.rectangle(startX, startY, 28, 28, this.wcfg.player);
          this.physics.add.existing(this.player);
          this.player.body.setAllowGravity(false);

          this.physics.add.overlap(this.player, this.obstacles, () => this.endRun({ reason: "OBSTACLE" }));

          this.cursors = this.input.keyboard.createCursorKeys();
          this.keys = this.input.keyboard.addKeys("W,A,S,D,ESC");

          this.flash = this.add.rectangle(W/2, H/2, W, H, 0xffffff).setAlpha(0).setDepth(200);
          this.blackout = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0).setDepth(180);

          this.touchDot = this.add.circle(0, 0, 6, this.wcfg.player).setAlpha(0).setDepth(50);
          this.touchTarget = null;

          // HUD (allowed on gameplay)
          this.uiTop = this.add.text(14, 10, "", { fontFamily: uiFont, fontSize: "14px", color: "#ffffff" }).setAlpha(0.95).setDepth(60);
          this.uiSub = this.add.text(14, 30, "", { fontFamily: uiFont, fontSize: "12px", color: "#b7b7ff" }).setAlpha(0.95).setDepth(60);
          this.uiCombo = this.add.text(W-14, 10, "", { fontFamily: uiFont, fontSize: "12px", color: "#ffffff" })
            .setOrigin(1,0).setAlpha(0.85).setDepth(60);

          // PAUSE
          this.pauseBtn = this.add.text(W-14, 30, "PAUSE", {
            fontFamily: uiFont, fontSize: "12px",
            color: "#ffffff", backgroundColor: "rgba(255,255,255,0.16)",
            padding: { left: 10, right: 10, top: 6, bottom: 6 }
          }).setOrigin(1,0).setDepth(9999).setInteractive({ useHandCursor:true });

          this.input.topOnly = true;
          const pb = this.pauseBtn.getBounds();
          this.pauseBtn.input.hitArea.setTo(pb.x-24, pb.y-16, pb.width+38, pb.height+28);

          this.pauseBtn.on("pointerdown", (p) => {
            p.event?.stopPropagation?.();
            this.togglePause(!this.paused);
          });

          // countdown
          this.countText = this.add.text(W/2, H*0.42, "", { fontFamily: uiFont, fontSize:"54px", color:"#ffffff" })
            .setOrigin(0.5).setDepth(160).setAlpha(0);
          this.countSub = this.add.text(W/2, H*0.50, "", { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" })
            .setOrigin(0.5).setDepth(160).setAlpha(0);

          // do not steal pause taps
          this.uiNoTouchZone = { x: W-200, y: 0, w: 200, h: 100 };

          this.input.on("pointerdown", (p) => {
            if (this.paused) { this.togglePause(false); return; }
            if (this.isInNoTouchZone(p.x, p.y)) return;
            this.touchTarget = { x: p.x, y: p.y };
            this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
          });
          this.input.on("pointermove", (p) => {
            if (!p.isDown || this.paused) return;
            if (this.isInNoTouchZone(p.x, p.y)) return;
            this.touchTarget = { x: p.x, y: p.y };
            this.touchDot.setPosition(p.x, p.y).setAlpha(0.85);
          });
          this.input.on("pointerup", () => {
            this.touchTarget = null;
            this.touchDot.setAlpha(0);
          });

          this.input.keyboard.on("keydown-ESC", () => this.togglePause(!this.paused));

          this.resetRunState();
          this.setupDecor();
          this.setupLasers();
          this.startCountdown(3);
        }

        isInNoTouchZone(x,y){
          const z = this.uiNoTouchZone;
          return x >= z.x && x <= z.x+z.w && y >= z.y && y <= z.y+z.h;
        }

        resetRunState(){
          this.t = 0;
          this.rawTime = 0;
          this.score = 0;
          this.paused = false;
          this.canMove = false;

          this.survivalPts = 0;
          this.nearPts = 0;
          this.clearBonusPts = 0;
          this.combo = 1;
          this.comboTimer = 0;
          this.maxCombo = 1;

          this.spawnTimer = 0;

          this._lastStreakTick = 0;

          if (this.mode === "campaign") {
            this.baseScroll = this.lcfg.baseScroll;
            this.scrollSpeed = this.lcfg.baseScroll;
            this.spawnEvery = this.lcfg.spawnStart;
          } else {
            this.baseScroll = ENDLESS.baseScroll0;
            this.scrollSpeed = ENDLESS.baseScroll0;
            this.spawnEvery = ENDLESS.spawnStart0;
          }

          this.surgeMult = 1;
          this.blackoutOn = false;
          this.blackoutEnabled = false;

          if (this.obstacles) {
            this.obstacles.children.iterate((o)=>{ if(o) o.destroy(); });
          }
        }

        startCountdown(n){
          this.countdown = n;
          this.countText.setAlpha(1);
          this.countSub.setAlpha(1);

          const show = (txt, subtxt) => {
            this.countText.setText(txt);
            this.countSub.setText(subtxt || "");
            this.countText.setScale(1.0);
            this.tweens.add({ targets: this.countText, scale: 1.10, yoyo: true, duration: 180, ease: "Sine.easeInOut" });
          };

          show(String(this.countdown), this.mode==="endless" ? "ENDLESS" : `${this.wcfg.name} • LEVEL ${this.level+1}`);

          this.time.addEvent({
            delay: 1000,
            repeat: n,
            callback: () => {
              this.countdown--;
              if (this.countdown > 0) {
                show(String(this.countdown), "");
              } else if (this.countdown === 0) {
                show("GO", "");
                this.flash.setAlpha(0.10);
                this.tweens.add({ targets: this.flash, alpha: 0, duration: 180, ease: "Linear" });
                this.time.addEvent({
                  delay: 450,
                  callback: () => {
                    this.countText.setAlpha(0);
                    this.countSub.setAlpha(0);
                    this.canMove = true;
                  }
                });
              }
            }
          });
        }

        togglePause(on){
          this.paused = on;
          if (on) {
            this.pauseOverlay = this.add.rectangle(W/2, H/2, W, H, 0x000000).setAlpha(0.55).setDepth(140);
            this.pauseText = this.add.text(W/2, H*0.44, "PAUSED", { fontFamily: uiFont, fontSize:"28px", color:"#ffffff" })
              .setOrigin(0.5).setDepth(141);
            this.pauseSub = this.add.text(W/2, H*0.52, "Tap anywhere to resume", { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff" })
              .setOrigin(0.5).setDepth(141).setAlpha(0.9);
            this.pauseOverlay.setInteractive();
            this.pauseOverlay.on("pointerdown", () => this.togglePause(false));
          } else {
            if (this.pauseOverlay) this.pauseOverlay.destroy();
            if (this.pauseText) this.pauseText.destroy();
            if (this.pauseSub) this.pauseSub.destroy();
            this.pauseOverlay = null;
          }
        }

        setupDecor() {
          for (const d of this.decor) d.destroy();
          this.decor = [];

          if (this.wcfg.gridStyle === "industrial") {
            for (let i = 0; i < 8; i++) {
              const r = this.add.rectangle(GRID_X - 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
              const r2 = this.add.rectangle(GRID_X + GRID_W + 18, GRID_Y + 40 + i*70, 10, 26, 0xffd166).setAlpha(0.22);
              this.decor.push(r, r2);
            }
          }

          if (this.wcfg.gridStyle === "glitch") {
            for (let i=0;i<16;i++){
              const b = this.add.rectangle(
                Phaser.Math.Between(0, W),
                Phaser.Math.Between(-H, H),
                Phaser.Math.Between(10, 26),
                Phaser.Math.Between(4, 12),
                0x9aa7ff
              ).setAlpha(Phaser.Math.FloatBetween(0.05, 0.12));
              b._vy = Phaser.Math.FloatBetween(40, 110);
              this.decor.push(b);
            }
          }
        }

        setupLasers() {
          const boss = WORLDS[2].boss || { warnThickness:6, thickness:16, cycleSeconds:6, warnSeconds:1.2, activeSeconds:1.1 };

          this.hLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.warnThickness, 0xffffff)
            .setAlpha(0).setDepth(90);
          this.hLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, GRID_W, boss.thickness, 0xff4d7d)
            .setAlpha(0).setDepth(91);

          this.vLaserWarn = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.warnThickness, GRID_H, 0xffffff)
            .setAlpha(0).setDepth(90);
          this.vLaser = this.add.rectangle(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, boss.thickness, GRID_H, 0xff4d7d)
            .setAlpha(0).setDepth(91);

          this.bossT = 0;

          if (this.mode === "campaign") {
            this.hLaserMode = (this.world === 2) ? "active" : "off";
            this.vLaserMode = "off";
          } else {
            this.hLaserMode = "off";
            this.vLaserMode = "off";
          }
        }

        applyEndlessBlend(blend){
          const w1 = WORLDS[0], w2 = WORLDS[1], w3 = WORLDS[2];

          const bg12 = mixColor(w1.bg, w2.bg, blend.a2);
          const bg = mixColor(bg12, w3.bg, blend.a3);
          const border12 = mixColor(w1.border, w2.border, blend.a2);
          const border = mixColor(border12, w3.border, blend.a3);
          const grid12 = mixColor(w1.gridLine, w2.gridLine, blend.a2);
          const grid = mixColor(grid12, w3.gridLine, blend.a3);
          const player12 = mixColor(w1.player, w2.player, blend.a2);
          const player = mixColor(player12, w3.player, blend.a3);

          let gridStyle = "circuit";
          if (blend.a3 > 0.38) gridStyle = "glitch";
          else if (blend.a2 > 0.42) gridStyle = "industrial";

          const shapes = [
            ...w1.obstacleStyle.shapes,
            ...(blend.a2 > 0.18 ? w2.obstacleStyle.shapes : []),
            ...(blend.a3 > 0.18 ? w3.obstacleStyle.shapes : [])
          ];

          this.wcfg = {
            id: 99,
            name: "Endless",
            subtitle: "",
            bg, border, gridLine: grid, player,
            fx: (gridStyle==="glitch") ? "stars" : (gridStyle==="industrial" ? "rain" : "scanlines"),
            gridStyle,
            obstacleStyle: {
              palette: [...w1.obstacleStyle.palette, ...w2.obstacleStyle.palette, ...w3.obstacleStyle.palette],
              shapes
            }
          };

          this.player.fillColor = player;
          this.touchDot.fillColor = player;

          if (!this._lastGridStyle) this._lastGridStyle = this.wcfg.gridStyle;
          if (this._lastGridStyle !== this.wcfg.gridStyle) {
            this._lastGridStyle = this.wcfg.gridStyle;
            this.setupDecor();
          }

          this.blackoutEnabled = !!blend.blackout;

          this.hLaserMode = blend.laserWarn ? (blend.laserActive ? "active" : "warn") : "off";
          this.vLaserMode = blend.verticalLaser ? (blend.laserActive ? "active" : "warn") : "off";
        }

        update(_, deltaMs){
          if (this.paused) return;

          const dt = deltaMs/1000;
          this.rawTime += dt;

          if (!this.canMove) {
            this.drawGrid(0.0001);
            this.updateHud(0);
            return;
          }

          this.t += dt;

          // combo decay
          this.comboTimer += dt;
          if (this.comboTimer > COMBO_DECAY_SEC) this.combo = 1;

          // surge
          const phase = (this.t % SURGE.period);
          const inSurge = phase < SURGE.active;
          this.surgeMult = inSurge ? SURGE.mult : 1.0;

          // blackout pulse in endless
          if (this.mode === "endless" && this.blackoutEnabled) {
            const bp = (this.t % BLACKOUT.period);
            this.blackoutOn = bp < BLACKOUT.active;
            this.blackout.setAlpha(this.blackoutOn ? BLACKOUT.alpha : 0);
          } else {
            this.blackout.setAlpha(0);
          }

          let timeLeft = 0;

          // campaign time-based clear
          if (this.mode === "campaign") {
            timeLeft = Math.max(0, this.lcfg.seconds - this.t);
            if (this.t >= this.lcfg.seconds) {
              this.clearBonusPts += LEVEL_CLEAR_BONUS;
              this.score += LEVEL_CLEAR_BONUS;
              this.levelComplete();
              return;
            }

            this.baseScroll = this.lcfg.baseScroll + this.t * this.lcfg.scrollRamp;
            this.scrollSpeed = this.baseScroll * this.surgeMult;

            const targetSpawn = this.lcfg.spawnStart - this.t * this.lcfg.spawnRamp;
            this.spawnEvery = clamp(targetSpawn, this.lcfg.spawnMin, this.lcfg.spawnStart);

          } else {
            // endless
            const blend = getEndlessBlend(this.t);
            this.applyEndlessBlend(blend);

            const base = ENDLESS.baseScroll0 + (this.t * ENDLESS.scrollBaseGrowth);
            const ramp = ENDLESS.ramp0 + this.t * ENDLESS.scrollRampGrowth;
            this.baseScroll = base + this.t * ramp;
            this.scrollSpeed = this.baseScroll * this.surgeMult;

            const spawnStart = ENDLESS.spawnStart0 - this.t * (ENDLESS.spawnTighten);
            const spawnRamp = ENDLESS.spawnRamp0 + this.t * ENDLESS.spawnRampGrowth;
            const targetSpawn = spawnStart - this.t * spawnRamp;
            this.spawnEvery = clamp(targetSpawn, ENDLESS.spawnMinFloor, ENDLESS.spawnStart0);
          }

          // survival points
          const add = SCORE_PPS * dt;
          this.survivalPts += add;
          this.score += add;

          // streak bonus every N seconds survived (simple + readable)
          const tick = Math.floor(this.t / STREAK_EVERY);
          if (tick > this._lastStreakTick) {
            this._lastStreakTick = tick;
            this.score += STREAK_BONUS;
            // tiny flash feedback
            this.flash.setAlpha(0.06);
            this.tweens.add({ targets: this.flash, alpha: 0, duration: 120, ease: "Linear" });
          }

          // movement (keyboard vs touch direct-follow)
          if (!IS_TOUCH) {
            let kvx = 0, kvy = 0;
            const left = this.cursors.left.isDown || this.keys.A.isDown;
            const right = this.cursors.right.isDown || this.keys.D.isDown;
            const up = this.cursors.up.isDown || this.keys.W.isDown;
            const down = this.cursors.down.isDown || this.keys.S.isDown;
            if (left) kvx -= 1;
            if (right) kvx += 1;
            if (up) kvy -= 1;
            if (down) kvy += 1;
            const mag = Math.hypot(kvx, kvy);
            if (mag > 1) { kvx /= mag; kvy /= mag; }
            this.player.body.setVelocity(kvx * PLAYER_SPEED, kvy * PLAYER_SPEED);
          } else {
            if (this.touchTarget) {
              const tx = clamp(this.touchTarget.x, GRID_X + 14, GRID_X + GRID_W - 14);
              const ty = clamp(this.touchTarget.y, GRID_Y + 14, GRID_Y + GRID_H - 14);

              const dx = tx - this.player.x;
              const dy = ty - this.player.y;
              const dist = Math.hypot(dx, dy);

              if (dist > FOLLOW_RADIUS) {
                const nx = this.player.x + dx * FOLLOW_LERP;
                const ny = this.player.y + dy * FOLLOW_LERP;

                const maxStep = PLAYER_SPEED * FOLLOW_MAX_SPEED_MULT * dt;
                const stepDist = Math.hypot(nx - this.player.x, ny - this.player.y);

                if (stepDist > maxStep) {
                  const s = maxStep / stepDist;
                  this.player.x = this.player.x + (nx - this.player.x) * s;
                  this.player.y = this.player.y + (ny - this.player.y) * s;
                } else {
                  this.player.x = nx;
                  this.player.y = ny;
                }

                this.player.body.reset(this.player.x, this.player.y);
              } else {
                this.player.body.setVelocity(0, 0);
              }
            } else {
              this.player.body.setVelocity(0, 0);
            }
          }

          // clamp player to grid
          const pad = 14;
          const px = clamp(this.player.x, GRID_X + pad, GRID_X + GRID_W - pad);
          const py = clamp(this.player.y, GRID_Y + pad, GRID_Y + GRID_H - pad);
          if (px !== this.player.x || py !== this.player.y) {
            this.player.x = px; this.player.y = py;
            this.player.body.reset(px, py);
          }

          // glitch decor animation
          if (this.wcfg.gridStyle === "glitch") {
            for (const b of this.decor) {
              b.y += b._vy * dt;
              if (b.y > H + 20) { b.y = -20; b.x = Phaser.Math.Between(0, W); }
            }
            if (Math.random() < 0.012) {
              this.flash.setAlpha(0.04);
              this.tweens.add({ targets: this.flash, alpha: 0, duration: 120, ease: "Linear" });
            }
          }

          // spawns
          this.spawnTimer += deltaMs;
          while (this.spawnTimer >= this.spawnEvery) {
            this.spawnTimer -= this.spawnEvery;
            this.spawnObstacle();
          }

          // move obstacles + near miss checks
          this.obstacles.children.iterate((o) => {
            if (!o) return;
            o.y += this.scrollSpeed * dt;
            if (o.y > GRID_Y + GRID_H + 140) { o.destroy(); return; }
            this.checkNearMiss(o);
          });

          // lasers
          this.updateLasers(dt);

          // draw + HUD
          this.drawGrid(dt);
          this.updateHud(timeLeft);
        }

        updateHud(timeLeft){
          const modeLabel = this.mode === "campaign"
            ? `Campaign • ${this.wcfg.name} L${this.level+1}`
            : "Endless";

          const tLabel = this.mode === "campaign"
            ? `Time Left: ${Math.ceil(timeLeft)}s`
            : `Time: ${formatTime(this.t)}`;

          const surgeLabel = (this.surgeMult > 1.01) ? " • SURGE" : "";
          const blackoutLabel = (this.blackoutOn) ? " • BLACKOUT" : "";

          this.uiTop.setText(`${modeLabel} • Score: ${Math.floor(this.score)}${surgeLabel}${blackoutLabel}`);
          this.uiSub.setText(`${tLabel} • Near: ${Math.floor(this.nearPts)} • +${STREAK_BONUS}/${STREAK_EVERY}s`);
          const cm = Math.min(COMBO_MAX, this.combo);
          this.uiCombo.setText(cm > 1.01 ? `x${cm.toFixed(2)}` : "");
        }

        drawGrid(dt){
          this.gridOffset = (this.gridOffset + this.scrollSpeed * dt) % TILE;
          const g = this.gridGraphics;
          g.clear();

          g.lineStyle(2, this.wcfg.border, 0.92);
          g.strokeRoundedRect(GRID_X - 6, GRID_Y - 6, GRID_W + 12, GRID_H + 12, 14);

          if (this.wcfg.gridStyle === "circuit") {
            g.lineStyle(1, this.wcfg.gridLine, 0.95);
            for (let c = 0; c <= GRID_COLS; c++) {
              const x = GRID_X + c * TILE;
              g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
            }
            for (let r = -1; r <= GRID_ROWS + 1; r++) {
              const y = GRID_Y + r * TILE + this.gridOffset - TILE;
              g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
            }
            g.fillStyle(this.wcfg.player, 0.12);
            for (let c = 0; c <= GRID_COLS; c++) {
              for (let r = 0; r <= GRID_ROWS; r++) {
                if ((c + r) % 3 !== 0) continue;
                g.fillCircle(GRID_X + c*TILE, GRID_Y + r*TILE, 2.2);
              }
            }
          }

          if (this.wcfg.gridStyle === "industrial") {
            g.lineStyle(2, this.wcfg.gridLine, 0.9);
            for (let c = 0; c <= GRID_COLS; c++) {
              const x = GRID_X + c * TILE;
              g.beginPath(); g.moveTo(x, GRID_Y); g.lineTo(x, GRID_Y + GRID_H); g.strokePath();
            }
            for (let r = -1; r <= GRID_ROWS + 1; r++) {
              const y = GRID_Y + r * TILE + this.gridOffset - TILE;
              g.beginPath(); g.moveTo(GRID_X, y); g.lineTo(GRID_X + GRID_W, y); g.strokePath();
            }
            g.lineStyle(1, 0xffd166, 0.07);
            for (let x = GRID_X - GRID_H; x < GRID_X + GRID_W + GRID_H; x += 18) {
              g.beginPath();
              g.moveTo(x, GRID_Y);
              g.lineTo(x + GRID_H, GRID_Y + GRID_H);
              g.strokePath();
            }
          }

          if (this.wcfg.gridStyle === "glitch") {
            const flick = 0.75 + Math.sin(this.t * 8) * 0.10;
            g.lineStyle(1, this.wcfg.gridLine, flick);

            for (let c = 0; c <= GRID_COLS; c++) {
              const x = GRID_X + c * TILE;
              let y0 = GRID_Y;
              while (y0 < GRID_Y + GRID_H) {
                const seg = Phaser.Math.Between(18, 64);
                const gap = Phaser.Math.Between(10, 40);
                if (Math.random() > 0.22) {
                  g.beginPath();
                  g.moveTo(x, y0);
                  g.lineTo(x, Math.min(GRID_Y + GRID_H, y0 + seg));
                  g.strokePath();
                }
                y0 += seg + gap;
              }
            }

            for (let r = -1; r <= GRID_ROWS + 1; r++) {
              const y = GRID_Y + r * TILE + this.gridOffset - TILE;
              let x0 = GRID_X;
              while (x0 < GRID_X + GRID_W) {
                const seg = Phaser.Math.Between(20, 70);
                const gap = Phaser.Math.Between(12, 44);
                if (Math.random() > 0.25) {
                  g.beginPath();
                  g.moveTo(x0, y);
                  g.lineTo(Math.min(GRID_X + GRID_W, x0 + seg), y);
                  g.strokePath();
                }
                x0 += seg + gap;
              }
            }
          }
        }

        spawnObstacle(){
          const col = Phaser.Math.Between(0, GRID_COLS - 1);
          const x = GRID_X + col * TILE + TILE / 2;
          const y = GRID_Y - 70;

          const style = this.wcfg.obstacleStyle;
          const shapes = style.shapes;
          const shape = shapes[Phaser.Math.Between(0, shapes.length - 1)];
          const tex = shapeToTex[shape] || "obs_rect";
          const palette = style.palette;
          const color = palette[Phaser.Math.Between(0, palette.length - 1)];

          let smin = 20, smax = 32;
          if (this.mode === "campaign") {
            const [a,b] = this.lcfg.size;
            smin = a; smax = b;
          } else {
            smin = clamp(22 - Math.floor(this.t/120), 16, 22);
            smax = clamp(34 - Math.floor(this.t/140), 22, 34);
          }

          let w = Phaser.Math.Between(smin, smax);
          let h = Phaser.Math.Between(smin, smax);

          if (shape === "bar") { w = Phaser.Math.Between(smax+8, smax+26); h = Phaser.Math.Between(14, 22); }
          if (shape === "tri") { w = Phaser.Math.Between(smin, smax+4); h = Phaser.Math.Between(smin, smax+8); }
          if (shape === "frame") { w = Phaser.Math.Between(smin+2, smax+10); h = Phaser.Math.Between(smin+2, smax+10); }
          if (shape === "plus") { w = Phaser.Math.Between(smin, smax+10); h = Phaser.Math.Between(smin, smax+10); }

          const s = this.add.image(x, y, tex);
          s.setTint(color);
          s.setAlpha(0.95);
          s.displayWidth = w;
          s.displayHeight = h;

          this.physics.add.existing(s);
          s.body.setAllowGravity(false);
          s.body.setImmovable(true);
          s.body.setSize(w * 0.88, h * 0.88, true);
          s._nearAwarded = false;
          this.obstacles.add(s);

          // second obstacle chance (slightly harder, still fair)
          let chance = 0.06;
          if (this.mode === "campaign") {
            const worldBonus = this.world * 0.02;
            const later = this.level >= 2 ? 1 : 0;
            chance = Phaser.Math.Clamp(0.06 + later*0.06 + worldBonus + (this.t * 0.0024), 0.06, 0.25);
          } else {
            chance = Phaser.Math.Clamp(0.06 + (this.t * 0.0018), 0.06, 0.24);
          }

          if (Math.random() < chance && this.t > 5) {
            let col2 = Phaser.Math.Between(0, GRID_COLS - 1);
            if (col2 === col) col2 = (col + Phaser.Math.Between(1, GRID_COLS-1)) % GRID_COLS;
            const x2 = GRID_X + col2 * TILE + TILE / 2;

            const shape2 = shapes[Phaser.Math.Between(0, shapes.length - 1)];
            const tex2 = shapeToTex[shape2] || "obs_rect";
            const color2 = palette[Phaser.Math.Between(0, palette.length - 1)];

            const s2 = this.add.image(x2, y - Phaser.Math.Between(22, 90), tex2);
            s2.setTint(color2);
            s2.setAlpha(0.9);
            s2.displayWidth = Math.max(14, w * 0.78);
            s2.displayHeight = Math.max(14, h * 0.78);

            this.physics.add.existing(s2);
            s2.body.setAllowGravity(false);
            s2.body.setImmovable(true);
            s2.body.setSize(s2.displayWidth * 0.88, s2.displayHeight * 0.88, true);
            s2._nearAwarded = false;

            this.obstacles.add(s2);
          }
        }

        checkNearMiss(o){
          if (!o || o._nearAwarded) return;
          const dy = Math.abs(o.y - this.player.y);
          if (dy > 30) return;
          const dx = Math.abs(o.x - this.player.x);
          const dist = Math.hypot(dx, dy);
          if (dist <= NEAR_DIST) {
            o._nearAwarded = true;

            this.comboTimer = 0;
            this.combo = Math.min(COMBO_MAX, this.combo + COMBO_STEP);
            this.maxCombo = Math.max(this.maxCombo, this.combo);

            const award = NEAR_POINTS * this.combo;
            this.nearPts += award;
            this.score += award;
          }
        }

        updateLasers(dt){
          const boss = WORLDS[2].boss;
          if (!boss) return;

          this.bossT += dt;

          const cycle = boss.cycleSeconds;
          const t = this.bossT % cycle;

          const warnOn = t < boss.warnSeconds;
          const activeOn = (t >= boss.warnSeconds) && (t < boss.warnSeconds + boss.activeSeconds);

          const driftY = (this.bossT * 0.22) % 1;
          const yPos = GRID_Y + 20 + (GRID_H - 40) * ((t / cycle + driftY) % 1);
          this.hLaserWarn.setPosition(GRID_X + GRID_W/2, yPos);
          this.hLaser.setPosition(GRID_X + GRID_W/2, yPos);

          const driftX = (this.bossT * 0.19 + 0.37) % 1;
          const xPos = GRID_X + 20 + (GRID_W - 40) * ((t / cycle + driftX) % 1);
          this.vLaserWarn.setPosition(xPos, GRID_Y + GRID_H/2);
          this.vLaser.setPosition(xPos, GRID_Y + GRID_H/2);

          const applyBeam = (mode, warnRect, activeRect) => {
            if (mode === "off") { warnRect.setAlpha(0); activeRect.setAlpha(0); return; }
            if (mode === "warn") { warnRect.setAlpha(warnOn ? 0.30 : 0); activeRect.setAlpha(0); return; }
            warnRect.setAlpha(warnOn ? 0.30 : 0);
            activeRect.setAlpha(activeOn ? 0.85 : 0);
          };

          applyBeam(this.hLaserMode, this.hLaserWarn, this.hLaser);
          applyBeam(this.vLaserMode, this.vLaserWarn, this.vLaser);

          if (activeOn) {
            const pr = this.player.getBounds();
            if (this.hLaserMode === "active") {
              const lr = this.hLaser.getBounds();
              if (Phaser.Geom.Intersects.RectangleToRectangle(pr, lr)) this.endRun({ reason: "H-LASER" });
            }
            if (this.vLaserMode === "active") {
              const vr = this.vLaser.getBounds();
              if (Phaser.Geom.Intersects.RectangleToRectangle(pr, vr)) this.endRun({ reason: "V-LASER" });
            }
          }
        }

        levelComplete(){
          const thisScore = Math.floor(this.score);

          // update local progress (DOM side)
          window.GRIDRUN.completeCampaignLevel(this.world, this.level, thisScore);

          this.scene.start("Results", {
            mode: "campaign",
            world: this.world,
            level: this.level,
            score: thisScore,
            reason: "CLEAR"
          });
        }

        endRun({reason}){
          const thisScore = Math.floor(this.score);

          this.flash.setAlpha(0.10);
          this.tweens.add({ targets: this.flash, alpha: 0, duration: 170, ease: "Linear" });

          if (this.mode === "endless") {
            window.GRIDRUN.setEndlessBest(thisScore);
            this.scene.start("Results", {
              mode: "endless",
              score: thisScore,
              reason
            });
            return;
          }

          this.scene.start("Results", {
            mode: "campaign",
            world: this.world,
            level: this.level,
            score: thisScore,
            reason
          });
        }
      }

      // ===== Results Scene =====
      class ResultsScene extends Phaser.Scene {
        constructor(){ super("Results"); }

        create(data){
          this.cameras.main.setBackgroundColor(0x070710);

          const mode = data?.mode || "campaign";
          const score = data?.score || 0;
          const reason = data?.reason || "";

          const title = this.add.text(W/2, H*0.18, mode === "endless" ? "ENDLESS RESULT" : "LEVEL RESULT", {
            fontFamily: uiFont, fontSize:"30px", color:"#ffffff"
          }).setOrigin(0.5);

          const sub = this.add.text(W/2, H*0.24,
            mode === "endless"
              ? `Reason: ${reason}`
              : `${WORLDS[data.world].name} • Level ${data.level+1} • ${reason==="CLEAR"?"CLEARED":"FAILED"}`,
            { fontFamily: uiFont, fontSize:"14px", color:"#b7b7ff", align:"center" }
          ).setOrigin(0.5).setAlpha(0.95);

          this.add.text(W/2, H*0.38, `Score: ${score}`, {
            fontFamily: uiFont, fontSize:"26px", color:"#ffffff"
          }).setOrigin(0.5).setAlpha(0.95);

          const btn = (label, y, onClick, accent="rgba(255,255,255,0.16)") => {
            const t = this.add.text(W/2, y, label, {
              fontFamily: uiFont,
              fontSize: "16px",
              color: "#ffffff",
              backgroundColor: accent,
              padding: { left: 18, right: 18, top: 10, bottom: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor:true });
            t.on("pointerover", ()=>t.setAlpha(0.88));
            t.on("pointerout", ()=>t.setAlpha(1));
            t.on("pointerdown", onClick);
            return t;
          };

          if (mode === "campaign") {
            btn("RETRY", H*0.56, () => this.scene.start("Play", { mode:"campaign", world:data.world, level:data.level }), "rgba(110,243,255,0.75)");
            btn("BACK TO LEVELS", H*0.66, () => { window.GRIDRUN.backToLevelSelect(data.world); }, "rgba(255,255,255,0.14)");
            btn("MAIN MENU", H*0.76, () => { window.GRIDRUN.backToMainMenu(); }, "rgba(255,255,255,0.14)");
          } else {
            btn("RETRY ENDLESS", H*0.56, () => this.scene.start("Play", { mode:"endless" }), "rgba(124,255,210,0.75)");
            btn("MAIN MENU", H*0.68, () => { window.GRIDRUN.backToMainMenu(); }, "rgba(255,255,255,0.14)");
          }
        }
      }

      return new Phaser.Game({
        type: Phaser.AUTO,
        width: W,
        height: H,
        parent: "phaser-container",
        physics: { default: "arcade", arcade: { debug: false } },
        scene: [ PlayScene, ResultsScene ]
      });
    }
  </script>
</body>
</html>